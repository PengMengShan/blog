[{"title":"vuex理解","date":"2017-07-12T11:55:00.000Z","path":"2017/07/12/vuex/","text":"之前使用vuex一直都是半懂半不懂的今天系统的了解了下vuex终于理解差不多了下面分享下个人理解vuex是什么？ vuex是一个状态管理器把所有状态都存在store这个容器里面 vuex能做什么？ vuex能够很好的解决组件中的通信，让数据更清晰明了，更容易管理。 vuex怎么使用？ 1 安装1npm install vuex --save 2 在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：12345678910import Vue from &apos;vue&apos;;import Vuex from &apos;vuex&apos;;Vue.use(Vuex);import state from &apos;./state&apos;;import actions from &apos;./actions&apos;;import mutations from &apos;./mutations&apos;;import getters from &apos;./getters&apos;;export default new Vuex.Store(&#123; state, actions, mutations, getters&#125;) 3 在路口文件main.js中引入 store12345678import stroe from &apos;./store&apos;new Vue(&#123; el: &apos;#app&apos;, router, store, //main.js注入store template: &apos;&lt;App/&gt;&apos;, components: &#123; App &#125;&#125;) 项目store目录下的文件index为store注入vue文件.1234567├── actions.js├── getters.js├── index.js├── mutations.js├── state.js└── types.js0 directories, 6 files 重点来了 state.js文件存放store中的数据字段getters.js文件存在获取store.state的方法,mutations.js文件存放修改state的方法 mutations是同步操作actions.js存放异步操作state方法，在vuex中只有mutations才能修改state actions还是调用的mutations","content":"<p><img src=\"../images/vuex.png\" alt=\"\"></p>\n\n<a id=\"more\"></a>\n<p>之前使用vuex一直都是半懂半不懂的今天系统的了解了下vuex终于理解差不多了下面分享下个人理解<br>vuex是什么？</p>\n<p>vuex是一个状态管理器把所有状态都存在store这个容器里面</p>\n<p>vuex能做什么？</p>\n<p>vuex能够很好的解决组件中的通信，让数据更清晰明了，更容易管理。</p>\n<p>vuex怎么使用？</p>\n<p>1 安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install vuex --save</div></pre></td></tr></table></figure></p>\n<p>2 在一个模块化的打包系统中，您必须显式地通过 Vue.use() 来安装 Vuex：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">import Vue from &apos;vue&apos;;</div><div class=\"line\">import Vuex from &apos;vuex&apos;;</div><div class=\"line\">Vue.use(Vuex);</div><div class=\"line\">import state from &apos;./state&apos;;</div><div class=\"line\">import actions from &apos;./actions&apos;;</div><div class=\"line\">import mutations from &apos;./mutations&apos;;</div><div class=\"line\">import getters from &apos;./getters&apos;;</div><div class=\"line\">export default new Vuex.Store(&#123;</div><div class=\"line\">  state, actions, mutations, getters</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>3 在路口文件main.js中引入 store<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">import stroe from &apos;./store&apos;</div><div class=\"line\">new Vue(&#123;</div><div class=\"line\">  el: &apos;#app&apos;,</div><div class=\"line\">  router,</div><div class=\"line\">  store, //main.js注入store</div><div class=\"line\">  template: &apos;&lt;App/&gt;&apos;,</div><div class=\"line\">  components: &#123; App &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure></p>\n<p>项目store目录下的文件index为store注入vue文件<br>.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── actions.js</div><div class=\"line\">├── getters.js</div><div class=\"line\">├── index.js</div><div class=\"line\">├── mutations.js</div><div class=\"line\">├── state.js</div><div class=\"line\">└── types.js</div><div class=\"line\">0 directories, 6 files</div></pre></td></tr></table></figure></p>\n<p>重点来了</p>\n<p>state.js文件存放store中的数据字段<br>getters.js文件存在获取store.state的方法,<br>mutations.js文件存放修改state的方法 mutations是同步操作<br>actions.js存放异步操作state方法，在vuex中只有mutations才能修改state actions还是调用的mutations</p>\n","excerpt":"","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.pengmengshan.cn/blog/tags/ES6/"}]},{"title":"React文档翻译 (快速入门)","date":"2017-07-04T13:50:00.000Z","path":"2017/07/04/react/","text":"翻译自react的大部分文档，方便自己查阅。 目录12345678910111213141516171819202122232425262728293031323334生命周期实例化存在期销毁期stateDo Not Modify State DirectlyState Updates May Be AsynchronousState Updates are MergedThe Data Flows Down条件渲染(Conditional Rendering)使用&amp;&amp;操作符替换if使用?:替换if elsePreventing Component from RenderingLists and KeysKeys表单受控组件The textarea tagSelectHandling Multiple InputsLifting State Up组合与继承Containment特殊化(Specialization)So What About Inheritance?思考ReactStep1: Break The UI Into A Component HierarchyStep2: Build A Static Version In ReactStep3: Identify The Minimal (but complete) Representation Of UI StateStep4: Identify Where You State LiveStep5: Add Inverse Data Flow参考生命周期仅仅关于客户端的React 实例化 getDefaultProps()getInitialState()componentWillMount()render()componentDidwMount()存在期 componentWillReceiveProps()shouldComponentUpdate()componentWillUpdate()componentDidUpdate()销毁期 componentWillUnmountstateDo Not Modify State Directly 不能直接设置state, 这不会再次渲染一个component(this will not re-render a component), 只有一个地方可以直接设置state。 // wrong, thisthis.state = { comments: ‘Hello world’};应该使用setState()方法。 // truethis.setState({ comments: ‘Hello world’,});State Updates May Be Asynchronous React可以将多个setState()调用分批到单个更新中以实现性能。 因为this.props与this.state都可能是异步更新，因此不可以依靠它们的值来计算下一次的state。举例来说，下面就是错的: // wrongthis.setState({ counter: this.state.counter + this.props.increment,}); 为了解决这个问题，使用setState()的第二种形式，它接受一个函数，函数的第一个参数是之前的state, 第二个参数是props。 // correctthis.setState((prevState, props) =&gt; ({ counter: prevState.counter + props.increment,}));State Updates are Merged 当你调用setState()的时候，React合并你提供的对象到当前的state当中。(When you call setState(), React merges the object you provide into the current state.) The Data Flows Down 条件渲染(Conditional Rendering)使用&amp;&amp;操作符替换if 复制代码function MailBox(props) { return ( Hello! {unreadMessages.length &gt; 0 &amp;&amp; You have {unreadMessages.length} unread messages. } );}复制代码 但是这种方法，值得注意的是，return后面跟的最外层必须是html元素。而不能是下面这样: 复制代码function MailBox(props) { return ( {unreadMessages.length &gt; 0 &amp;&amp; You have {unreadMessages.length} unread messages. } );}复制代码 使用?:替换if else 复制代码render() { const isLoggedIn = this.state.isLoggedIn; return( The user is {isLogginIn ? ‘currently’ : ‘not’} logged in. );}复制代码还可以用于更大的表达式。 复制代码render() { const isLoggedIn = this.state.isLoggedIn; return ( {isLoggedIn ? ( ) : ( )} );}复制代码Preventing Component from Rendering 极少的情况下，要让组件隐藏起来，那么可以通过return null来实现。 Lists and Keys在react中使用list，必须要为每个list的元素指定key(每个item的key是唯一的)。 Keys keys帮助React确定哪些item已经改变了，被添加了或者被移除了。 不推荐设置key的值是索引，如果这个数组要被排序的话(We don’t recommand using indexes for keys if the items can reorder, as that would be slow.)。因为这将会被慢。 key只在周围数组的上下文中有意义。 表单在react中，HTML表单元素与其他DOM元素有所不一样。因为表单元素自然保持着一些内部状态。举例来说，这个HTML格式的表单接受一个单个的name: 复制代码 Name: 复制代码这个表单拥有HTML表单的默认行为，当提交表单的时候，浏览器会打开一个新的页面。如果你在react中这么使用的话，它依然起作用。但是在大多数情况下，拥有一个可以处理表单并可访问用户输入表单的数据的JavaScript函数是很方便的。实现这一点的标准方法是使用一种叫作’受控组件’的技术。 受控组件 在HTML中，类似于input textarea select这样的表单元素通常维持着它们自己的状态，并且基于用户的输入更新。在React中，可变状态通常保存在组件的state属性中，并且只能通过setState()来更新。 我们可以通过使react成为’真正的唯一来源’, 将两者结合起来。然后，呈现表单的React组件也控制后续用户输入时该表单中发生的情况。 一个输入表单元素的值被React控制，被称为受控组件。 一个简单的受控组件如下： 复制代码class NameForm extends React.Component { constructor(props) { super(props); this.state = {value: ‘’,}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(e) { this.setState({ value: e.target.value, }); } handleSubmit(e) { console.log(this.state.value); e.preventDefault(); } render() { return ( name: ); }}复制代码 使用受控组件，每个状态的突变都具有相关联的处理函数。这使得修改或验证用户的输入很直接。举例来说，如果我们想要用户强制性这些名称用全部大写字母写，我们可以把handleChange写为: handleChange(e) { this.setState({ value: e.target.value.toUpperCase(), });}The textarea tag 在HTML中，一个textarea元素定义它的文本通过children来定义。 而在React中，一个textarea元素是使用value属性来定义的。其使用方法和input差不多的。 Select 在HTML中，select创建一个下拉列表，比如像下面这样的: baoma benchi aodi而在React中，是在根select组件里使用value属性来选中的。在受控组件中，这更加方便，因为你只需要在一个地方更新它，比如下面这样: 复制代码class FormItem extends React.Component { constructor(props) { super(props); this.state = {value: ‘benchi’}; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); } handleChange(e) { this.setState({ value: e.target.value, }); } handleSubmit(e) { console.log(e.state.value); e.preventDefault(); } render( return (","content":"<p>翻译自react的大部分文档，方便自己查阅。</p>\n<a id=\"more\"></a>\n<p>目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">生命周期</div><div class=\"line\">实例化</div><div class=\"line\">存在期</div><div class=\"line\">销毁期</div><div class=\"line\">state</div><div class=\"line\">Do Not Modify State Directly</div><div class=\"line\">State Updates May Be Asynchronous</div><div class=\"line\">State Updates are Merged</div><div class=\"line\">The Data Flows Down</div><div class=\"line\">条件渲染(Conditional Rendering)</div><div class=\"line\">使用&amp;&amp;操作符替换if</div><div class=\"line\">使用?:替换if else</div><div class=\"line\">Preventing Component from Rendering</div><div class=\"line\">Lists and Keys</div><div class=\"line\">Keys</div><div class=\"line\">表单</div><div class=\"line\">受控组件</div><div class=\"line\">The textarea tag</div><div class=\"line\">Select</div><div class=\"line\">Handling Multiple Inputs</div><div class=\"line\">Lifting State Up</div><div class=\"line\">组合与继承</div><div class=\"line\">Containment</div><div class=\"line\">特殊化(Specialization)</div><div class=\"line\">So What About Inheritance?</div><div class=\"line\">思考React</div><div class=\"line\">Step1: Break The UI Into A Component Hierarchy</div><div class=\"line\">Step2: Build A Static Version In React</div><div class=\"line\">Step3: Identify The Minimal (but complete) Representation Of UI State</div><div class=\"line\">Step4: Identify Where You State Live</div><div class=\"line\">Step5: Add Inverse Data Flow</div><div class=\"line\">参考</div><div class=\"line\">生命周期</div><div class=\"line\">仅仅关于客户端的React</div></pre></td></tr></table></figure></p>\n<p>实例化</p>\n<p>getDefaultProps()<br>getInitialState()<br>componentWillMount()<br>render()<br>componentDidwMount()<br>存在期</p>\n<p>componentWillReceiveProps()<br>shouldComponentUpdate()<br>componentWillUpdate()<br>componentDidUpdate()<br>销毁期</p>\n<p>componentWillUnmount<br>state<br>Do Not Modify State Directly</p>\n<p>不能直接设置state, 这不会再次渲染一个component(this will not re-render a component), 只有一个地方可以直接设置state。</p>\n<p>// wrong, this<br>this.state = { comments: ‘Hello world’};<br>应该使用setState()方法。</p>\n<p>// true<br>this.setState({<br>  comments: ‘Hello world’,<br>});<br>State Updates May Be Asynchronous</p>\n<p>React可以将多个setState()调用分批到单个更新中以实现性能。</p>\n<p>因为this.props与this.state都可能是异步更新，因此不可以依靠它们的值来计算下一次的state。举例来说，下面就是错的:</p>\n<p>// wrong<br>this.setState({<br>  counter: this.state.counter + this.props.increment,<br>});</p>\n<p>为了解决这个问题，使用setState()的第二种形式，它接受一个函数，函数的第一个参数是之前的state, 第二个参数是props。</p>\n<p>// correct<br>this.setState((prevState, props) =&gt; ({<br>  counter: prevState.counter + props.increment,<br>}));<br>State Updates are Merged</p>\n<p>当你调用setState()的时候，React合并你提供的对象到当前的state当中。(When you call setState(), React merges the object you provide into the current state.)</p>\n<p>The Data Flows Down</p>\n<p>条件渲染(Conditional Rendering)<br>使用&amp;&amp;操作符替换if</p>\n<p>复制代码<br>function MailBox(props) {<br>  return (<br>    <div><br>      <h1>Hello!</h1><br>      {unreadMessages.length &gt; 0 &amp;&amp;<br>        <h2><br>          You have {unreadMessages.length} unread messages.<br>        </h2><br>      }<br>    </div><br>  );<br>}<br>复制代码</p>\n<p>但是这种方法，值得注意的是，return后面跟的最外层必须是html元素。而不能是下面这样:</p>\n<p>复制代码<br>function MailBox(props) {<br>  return (<br>    {unreadMessages.length &gt; 0 &amp;&amp;<br>      </p><h2><br>        You have {unreadMessages.length} unread messages.<br>      </h2><br>    }<br>  );<br>}<br>复制代码<p></p>\n<p>使用?:替换if else</p>\n<p>复制代码<br>render() {<br>  const isLoggedIn = this.state.isLoggedIn;<br>  return(<br>    <div><br>      The user is <b>{isLogginIn ? ‘currently’ : ‘not’}</b> logged in.<br>    </div><br>  );<br>}<br>复制代码<br>还可以用于更大的表达式。</p>\n<p>复制代码<br>render() {<br>  const isLoggedIn = this.state.isLoggedIn;<br>  return (<br>    <div><br>      {isLoggedIn ? (<br>        <logoutbutton onclick=\"{this.handleLogoutClick}\"><br>      ) : (<br>        <loginbutton onclick=\"{this.handleLoginClick}\"><br>      )}<br>    </loginbutton></logoutbutton></div><br>  );<br>}<br>复制代码<br>Preventing Component from Rendering</p>\n<p>极少的情况下，要让组件隐藏起来，那么可以通过return null来实现。</p>\n<p>Lists and Keys<br>在react中使用list，必须要为每个list的元素指定key(每个item的key是唯一的)。</p>\n<p>Keys</p>\n<p>keys帮助React确定哪些item已经改变了，被添加了或者被移除了。</p>\n<p>不推荐设置key的值是索引，如果这个数组要被排序的话(We don’t recommand using indexes for keys if the items can reorder, as that would be slow.)。因为这将会被慢。</p>\n<p>key只在周围数组的上下文中有意义。</p>\n<p>表单<br>在react中，HTML表单元素与其他DOM元素有所不一样。因为表单元素自然保持着一些内部状态。举例来说，这个HTML格式的表单接受一个单个的name:</p>\n<p>复制代码</p>\n<p><form><br>  <label><br>    Name:<br>    <input type=\"text\" name=\"name\"><br>  </label><br>  <input type=\"submit\" value=\"Submit\"><br></form><br>复制代码<br>这个表单拥有HTML表单的默认行为，当提交表单的时候，浏览器会打开一个新的页面。如果你在react中这么使用的话，它依然起作用。但是在大多数情况下，拥有一个可以处理表单并可访问用户输入表单的数据的JavaScript函数是很方便的。实现这一点的标准方法是使用一种叫作’受控组件’的技术。</p>\n<p>受控组件</p>\n<p>在HTML中，类似于input textarea select这样的表单元素通常维持着它们自己的状态，并且基于用户的输入更新。在React中，可变状态通常保存在组件的state属性中，并且只能通过setState()来更新。</p>\n<p>我们可以通过使react成为’真正的唯一来源’, 将两者结合起来。然后，呈现表单的React组件也控制后续用户输入时该表单中发生的情况。 一个输入表单元素的值被React控制，被称为受控组件。</p>\n<p>一个简单的受控组件如下：</p>\n<p>复制代码<br>class NameForm extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {value: ‘’,};<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br>  }</p>\n<p>  handleChange(e) {<br>    this.setState({<br>      value: e.target.value,<br>    });<br>  }</p>\n<p>  handleSubmit(e) {<br>    console.log(this.state.value);<br>    e.preventDefault();<br>  }</p>\n<p>  render() {<br>    return (<br>      <form onsubmit=\"{this.handleSubmit}\"><br>        <label><br>          name:<br>          <input type=\"text\" value=\"{this.state.value}\" onchange=\"{this.handleChange}\"><br>        </label><br>        <input type=\"submit\" value=\"Submit\"><br>      </form><br>    );<br>  }<br>}<br>复制代码</p>\n<p>使用受控组件，每个状态的突变都具有相关联的处理函数。这使得修改或验证用户的输入很直接。举例来说，如果我们想要用户强制性这些名称用全部大写字母写，我们可以把handleChange写为:</p>\n<p>handleChange(e) {<br>  this.setState({<br>    value: e.target.value.toUpperCase(),<br>  });<br>}<br>The textarea tag</p>\n<p>在HTML中，一个textarea元素定义它的文本通过children来定义。</p>\n<p>而在React中，一个textarea元素是使用value属性来定义的。其使用方法和input差不多的。</p>\n<p>Select</p>\n<p>在HTML中，select创建一个下拉列表，比如像下面这样的:</p>\n<p><select><br>  <option value=\"baoma\">baoma</option><br>  <option selected value=\"benchi\">benchi</option><br>  <option value=\"aodi\">aodi</option><br></select><br>而在React中，是在根select组件里使用value属性来选中的。在受控组件中，这更加方便，因为你只需要在一个地方更新它，比如下面这样:</p>\n<p>复制代码<br>class FormItem extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {value: ‘benchi’};<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSubmit = this.handleSubmit.bind(this);<br>  }</p>\n<p>  handleChange(e) {<br>    this.setState({<br>      value: e.target.value,<br>    });<br>  }</p>\n<p>  handleSubmit(e) {<br>    console.log(e.state.value);<br>    e.preventDefault();<br>  }</p>\n<p>  render(<br>    return (<br>      <form onsubmit=\"{this.handleSubmit}\" <label=\"\"><br>          Pick your favorite car:<br>          <select value=\"{this.state.value}\" onchange=\"{this.handleChange}\"><br>            <option value=\"baoma\">baoma</option><br>            <option value=\"benchi\">benchi</option><br>            <option value=\"aodi\">aodi</option><br>          </select><br>        <br>        <input type=\"submit\" value=\"Submit\"><br>      /&gt;<br>    );<br>  );<br>}</form></p>\n<p><input type=\"text\"> <textarea> </textarea><select>它们都工作的差不多，它们都接受一个value属性，这个属性可以用来实现一个受控组件。<br>复制代码<br>Handling Multiple Inputs<br>当你需要处理多个受控组件input元素的时候，你可以给每个元素添加name属性，并且让处理函数根据该值(event.target.name)选择要进行的操作。</select></p>\n<p>举个例子:</p>\n<p>复制代码<br>class Reservation extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.setState = {<br>      isGoing: true,<br>      numberOfGuests: 2,<br>    };</p>\n<pre><code>this.handleChange = this.handleChange.bind(this);\n</code></pre><p>  }</p>\n<p>  handleChange(e) {<br>    const target = e.target;<br>    const value = target.type === ‘checkbox’ ? target.checked : target.value;<br>    const name = target.name;</p>\n<pre><code>// es6 computed property name\nthis.setState({\n  [name]: value,\n});\n</code></pre><p>  }</p>\n<p>  render() {<br>    return (<br>      <form><br>        <label><br>          Is going:<br>          <input name=\"isGoing\" type=\"checkbox\" checked=\"{this.state.isGoing}\" onchange=\"{this.handleChange}\"><br>        </label><br>        <br><br>        <label><br>          Number of guests:<br>          <input name=\"numberOfGuests\" type=\"number\" value=\"={this.state.numberOfGuests}\" onchange=\"{this.handleChange}\"><br>        </label><br>      </form><br>    );<br>  }<br>}<br>复制代码<br>可能你觉得太麻烦，你需要非受控组件</p>\n<p>Lifting State Up<br>在react中，共享state是通过将它移动到需要它的组件的最接近的共同祖先来实现的。这被称为提升状态。如果祖先拥有了共享状态，那么就有了source of true。</p>\n<p>官方文档给的那个例子，简单来说，两个组件的值相互依赖的时候，就将state提升到它们最近的共同祖先，通过在父组件里进行相应的值转换，然后通过props将值传递给子组件。然后两个子组件的值改变时，调用的函数是父组件传递下来的。</p>\n<p>因此, 可以通过子组件调父组件传递过来的函数,将子组件的值传递给父组件， 来改变父组件的state, 然后父组件计算值后，通过props将计算后的值分发到各个子组件，这样就保证了唯一的来源，而子组件的值也是相互依赖(有关联)的。 如下:</p>\n<p>复制代码<br>// 子组件<br>handleChange(e) {<br>  this.props.onTemperatureChange(e.target.value);<br>}</p>\n<input onchange=\"{this.handleChange}\" type=\"text\">\n\n<p>// 父组件<br>handleChange(value) {<br>  this.setState({<br>    temperature: value,<br>  });<br>}</p>\n<p><temperatureinput ontemperaturechage=\"{this.handleChange}\"><br>复制代码<br>组合与继承<br>在React中，我们推荐使用组合来复用代码而不是继承。</temperatureinput></p>\n<p>Containment</p>\n<p>一些容器不能提前知道它们的children是谁。在Sidebar和Dialog里尤其的正常。</p>\n<p>我们推荐这类的组件使用特殊的children prop来将children直接传递到它们的输出中:</p>\n<p>复制代码<br>function FancyBorder(props) {<br>  return (<br>    <div classname=\"{'FancyBorder\" fancyborder-'=\"\" +=\"\" props.color}=\"\"><br>      {this.props.children}<br>   </div><br>  );<br>}<br>复制代码<br>然后让其他组件通过嵌入JSX传递任意个child给FancyBorder:</p>\n<p>复制代码<br>function WelcomeDialog() {<br>  return (<br>    <fancyborder color=\"blue\"><br>      <h1 classname=\"Dialog-title\"><br>        Welcome<br>      </h1><br>      <p classname=\"Dialog-message\"><br>        Thank you for visiting our spacecraft!<br>      </p><br>    </fancyborder><br>  );<br>}<br>复制代码</p>\n<p><fancyborder>JSX标签中的任何内容都会作为子菜单传入FancyBorder组件。由于FancyBorder将{props.children}呈现在</fancyborder></p>\n<p>中，所以传递的元素将显示在最终输出中。一般在开发中，还可以在路由中控制this.props.children是谁。比如下面这样:<br>复制代码<br>// News.js<br>render() {<br>  return (<br>    <div classname=\"{style.container}\"><br>      {this.props.children}<br>    </div><br>  );<br>}</p>\n<p>// routers.js<br>export function createRoutes() {<br>  return {<br>    path: ‘/‘,<br>    component: App,<br>    indexRoute: { component: Main },<br>    childRoutes: [<br>      {<br>        path: ‘:channel’,<br>        component: NewsList,<br>      }<br>    ],<br>  };<br>}<br>复制代码<br>这里News组件的子组件就是NewsList。</p>\n<p>虽然不常见，但是有时候你可能在组件里需要多个’hole’, 在这种情况下，你可能想出自己的习惯，而不是使用children:</p>\n<p>复制代码<br>function SplitPane(props) {<br>  return (<br>    <div classname=\"SplitPane\"><br>      <div classname=\"SplitPane-left\"><br>        {props.left}<br>      </div><br>      <div classname=\"SplitPane-right\"><br>        {props.right}<br>      </div><br>    </div><br>  );<br>}</p>\n<p>function App() {<br>  return (<br>    <splitpane left=\"{\" <contacts=\"\"><br>      }<br>      right={<br>        <chat><br>      }<br>    /&gt;<br>  );<br>}<br>复制代码<br>特殊化(Specialization)<br>有时我们将组件视为其他组件的”特殊情况”。举例来说，我们可以说WelcomeDialog是Dialog的一种特殊情况。</chat></splitpane></p>\n<p>在React中，这通常由组合来实现，其中一个更”特定”的组件呈现出更”通用的组件”, 并且使用props来配置它。</p>\n<p>复制代码<br>function Dialog(props) {<br>  return (<br>    <fancyborder color=\"blue\"><br>      <h1 classname=\"Dialog-title\"><br>        {props.title}<br>      </h1><br>      <p classname=\"Dialog-title\"><br>        {props.message}<br>      </p><br>    </fancyborder><br>  );<br>}</p>\n<p>function WelcomeDialog() {<br>  return (<br>    <dialog title=\"Welcome\" message=\"Thank you for visiting our spacecraft!\"><br>  );<br>}<br>复制代码<br>组合对于定义为类的组件同样适用。</dialog></p>\n<p>复制代码<br>function Dialog(props) {<br>  return (<br>    <fancyborder color=\"blue\"><br>      <h1 classname=\"Dialog-title\"><br>        {props.title}<br>      </h1><br>      <p classname=\"Dialog-message\"><br>        {props.messgae}<br>      </p><br>      {props.children}<br>    </fancyborder><br>  );<br>}</p>\n<p>class SignUpDialog extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.handleChange = this.handleChange.bind(this);<br>    this.handleSignUp = this.handleSignUp.bind(this);<br>    this.state = {login: ‘’};<br>  }</p>\n<p>  handleChange(e) {<br>    this.setState({<br>      login: e.target.value,<br>    });<br>  }</p>\n<p>  handleSignUp() {<br>    alert(<code>Welcome aboard, ${this.state.login}!</code>);<br>  }</p>\n<p>  render() {<br>    return (<br>      <dialog title=\"Mars Exploration Program\" message=\"How should we refer to you?\"><br>        <input value=\"{this.state.login}\" onchange=\"{this.handleChange}\"><br>        <button onclick=\"{this.handleSignUp}\"><br>          Sign Me Up!<br>        </button><br>      </dialog><br>    );<br>  }<br>}</p>\n<p>So What About Inheritance?</p>\n<p>在Facebook, 我们在数千计的组件中，还没有发现任何一种情况值得我们推荐使用继承。使用Props和composition就已经很完美了。</p>\n<p>思考React<br>Step1: Break The UI Into A Component Hierarchy</p>\n<p>使用单一任务原则，也就是说，一个组件理想上只做一件事情。</p>\n<p>Step2: Build A Static Version In React</p>\n<p>使用mock数据构架一个没有交互的静态版本。因为构建一个静态的版本，需要大量的typing和不需要思考太多，而构建一个交互性的版本需要大量的思考，而不需要大量的typing。<br>如果你很熟悉state的概念，那么就不要使用state来构建静态的版本, state只是为了交互而保留的。<br>你既可以自下向上进行构建，也可以自上向下构建。在简单的例子中，通常更容易自上而下；而在较大的例子中，自下而上通常更容易一些，并且也更容易写测试。</p>\n<p>Step3: Identify The Minimal (but complete) Representation Of UI State</p>\n<p>要使你的应用可以交互，你需要能够触发底层数据模型的更改, State让这一切变得很容易。<br>为了正确的构建你的app，首先你需要思考你的app需要的最小的可变的state集。这里很关键的是DRY: Don’t repeat yourself。找出你的app需要的state集的最小表示，并计算出你所需要的其他需求。举例来说，如果你要构建一个Todo List, 只需要维持一个todo items的数组，不需要为数量单独保持一个state的变量。当你想要渲染todo的数量时，只需要取todos数组的长度就可以了。</p>\n<p>如何区分是数据是state还是props，只需要问下面这三个问题:</p>\n<p>它是从父组件从props传递过来的吗？如果是，那么它不是state。<br>它会随着时间的推移保持不变吗？如果是，那么它不是state。<br>你可以根据组件中的其他state或props计算出它来吗？如果可以，那么它不是state。<br>Step4: Identify Where You State Live</p>\n<p>当我们确定app的最小的state集后。下一步，我们需要确定是哪一个组件拥有state。<br>记住: React是单向数据流，可能不能立即清楚哪个组件拥有哪个state。这对于新手来说也是最大的挑战，因此根据下面这些步骤来解决这个问题:</p>\n<p>对于你的应用中的每个state:</p>\n<p>识别出基于那个state渲染的所有组件。<br>找一个通用的组件find a common owner component(单个组件，它是所有需要那个state的组件的父级组件)。<br>公共所有者(The common owner)或层次结构中较高的其他组件应该拥有state。<br>如果你找不到拥有state的组件，就创建一个新的组件，仅用于保存state，并将其添加到所有者组件上方的层次结构中。<br>Step5: Add Inverse Data Flow</p>\n<p>子组件通过props调用父级组件 传递过来的方法(回调)来改变父级的state。</p>\n<p>参考<br>react官方文档<br>react生命周期</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n\n","excerpt":"翻译自react的大部分文档，方便自己查阅。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.pengmengshan.cn/blog/tags/ES6/"}]},{"title":"Immutable的认识","date":"2017-06-25T12:32:08.000Z","path":"2017/06/25/it-2017Immutable/","text":"Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce``find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。其中有 3 种最重要的数据结构说明一下：（Java 程序员应该最熟悉了）Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象List：有序可重复的列表，对应于 ArraySet：无序且不可重复的列表1seamless-immutable 与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。下面上代码来感受一下两者的不同： 1234567891011121314151617181920// 原来的写法let foo = &#123;a: &#123;b: 1&#125;&#125;;let bar = foo;bar.a.b = 2;console.log(foo.a.b); // 打印 2console.log(foo === bar); // 打印 true// 使用 immutable.js 后import Immutable from &apos;immutable&apos;;foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);bar = foo.setIn([&apos;a&apos;, &apos;b&apos;], 2); // 使用 setIn 赋值console.log(foo.getIn([&apos;a&apos;, &apos;b&apos;])); // 使用 getIn 取值，打印 1console.log(foo === bar); // 打印 false// 使用 seamless-immutable.js 后import SImmutable from &apos;seamless-immutable&apos;;foo = SImmutable(&#123;a: &#123;b: 1&#125;&#125;)bar = foo.merge(&#123;a: &#123; b: 2&#125;&#125;) // 使用 merge 赋值console.log(foo.a.b); // 像原生 Object 一样取值，打印 1console.log(foo === bar); // 打印 false IMMUTABLE 优点1.Immutable 降低了 Mutable 带来的复杂度 可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。 比如下面一段代码：12345function touchAndLog(touchFn) &#123; let data = &#123; key: &apos;value&apos; &#125;; touchFn(data); console.log(data.key); // 猜猜会打印什么？&#125; 在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。 2.节省内存 Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。 123456789import &#123; Map&#125; from &apos;immutable&apos;;let a = Map(&#123; select: &apos;users&apos;, filter: Map(&#123; name: &apos;Cam&apos; &#125;)&#125;)let b = a.set(&apos;select&apos;, &apos;people&apos;);a === b; // falsea.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true 上面 a 和 b 共享了没有变化的 filter 节点。 3.Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟 因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。 后面我会提供 Flux 做 Undo 的示例。 4.并发安全 传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。 然而现在并没什么卵用，因为 JavaScript 还是单线程运行的啊。但未来可能会加入，提前解决未来的问题不也挺好吗？ 5.拥抱函数式编程 Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。 像 ClojureScript，Elm 等函数式编程语言中的数据类型天生都是 Immutable 的，这也是为什么 ClojureScript 基于 React 的框架 — Om 性能比 React 还要好的原因。 IMMUTABLE 缺点1.需要学习新的 API 1No Comments 2.增加了资源文件大小 1No Comments 3.容易与原生对象混淆 这点是我们使用 Immutable.js 过程中遇到最大的问题。写代码要做思维上的转变。 虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有的时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。 Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get(‘key’)而不是 map.key，array.get(0) 而不是 array[0]。另外 Immutable 每次修改都会返回新对象，也很容易忘记赋值。 当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。 下面给出一些办法来避免类似问题发生： 使用 Flow 或 TypeScript 这类有静态类型检查的工具约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。更多认识Immutable.is 两个 immutable 对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回 false： 123let map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);let map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);map1 === map2; // false 为了直接比较对象的值，immutable.js 提供了 Immutable.is 来做『值比较』，结果如下： 1Immutable.is(map1, map2); // true Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。 后面会使用 Immutable.is 来减少 React 重复渲染，提高性能。 另外，还有 mori、cortex 等，因为类似就不再介绍。 与 Object.freeze、const 区别 Object.freeze 和 ES6 中新加入的 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。 Cursor 的概念 这个 Cursor 和数据库中的游标是完全不同的概念。 由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。 12345678910111213import Immutable from &apos;immutable&apos;;import Cursor from &apos;immutable/contrib/cursor&apos;;let data = Immutable.fromJS(&#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125;);// 让 cursor 指向 &#123; c: 1 &#125;let cursor = Cursor.from(data, [&apos;a&apos;, &apos;b&apos;], newData =&gt; &#123; // 当 cursor 或其子 cursor 执行 update 时调用 console.log(newData);&#125;);cursor.get(&apos;c&apos;); // 1cursor = cursor.update(&apos;c&apos;, x =&gt; x + 1);cursor.get(&apos;c&apos;); // 2 实践与 React 搭配使用，Pure Render 熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate()，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。 当然我们也可以在 shouldComponentUpdate() 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render()，但 deepCopy 和 deepCompare 一般都是非常耗性能的。 Immutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 shouldComponentUpdate 是这样的： 注意：React 中规定 state 和 props 只能是一个普通对象，所以比较时要比较对象的 key 12345678910111213141516171819202122import &#123; is &#125; from &apos;immutable&apos;;shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123; const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;; if (Object.keys(thisProps).length !== Object.keys(nextProps).length || Object.keys(thisState).length !== Object.keys(nextState).length) &#123; return true; &#125; for (const key in nextProps) &#123; if (!is(thisProps[key], nextProps[key])) &#123; return true; &#125; &#125; for (const key in nextState) &#123; if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) &#123; return true; &#125; &#125; return false;&#125; 与 Redux 搭配使用 Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -&gt; Action -&gt; Middleware -&gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。 由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。 幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。 上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。 总结 Immutable 可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外接口中。 如果 JS 原生 Immutable 类型会不会太美，被称为 React API 终结者的 Sebastian Markbåge 有一个这样的提案，能否通过现在还不确定。不过可以肯定的是 Immutable 会被越来越多的项目使用。以上纯属个人的理解！！ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>  Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce``find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。<br><a id=\"more\"></a><br>其中有 3 种最重要的数据结构说明一下：（Java 程序员应该最熟悉了）<br>Map：键值对集合，对应于 Object，ES6 也有专门的 Map 对象<br>List：有序可重复的列表，对应于 Array<br>Set：无序且不可重复的列表<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">seamless-immutable</div></pre></td></tr></table></figure></p>\n<p>与 Immutable.js 学院派的风格不同，seamless-immutable 并没有实现完整的 Persistent Data Structure，而是使用 Object.defineProperty（因此只能在 IE9 及以上使用）扩展了 JavaScript 的 Array 和 Object 对象来实现，只支持 Array 和 Object 两种数据类型，API 基于与 Array 和 Object 操持不变。代码库非常小，压缩后下载只有 2K。而 Immutable.js 压缩后下载有 16K。<br>下面上代码来感受一下两者的不同：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 原来的写法</div><div class=\"line\">let foo = &#123;a: &#123;b: 1&#125;&#125;;</div><div class=\"line\">let bar = foo;</div><div class=\"line\">bar.a.b = 2;</div><div class=\"line\">console.log(foo.a.b);  // 打印 2</div><div class=\"line\">console.log(foo === bar);  //  打印 true</div><div class=\"line\"></div><div class=\"line\">// 使用 immutable.js 后</div><div class=\"line\">import Immutable from &apos;immutable&apos;;</div><div class=\"line\">foo = Immutable.fromJS(&#123;a: &#123;b: 1&#125;&#125;);</div><div class=\"line\">bar = foo.setIn([&apos;a&apos;, &apos;b&apos;], 2);   // 使用 setIn 赋值</div><div class=\"line\">console.log(foo.getIn([&apos;a&apos;, &apos;b&apos;]));  // 使用 getIn 取值，打印 1</div><div class=\"line\">console.log(foo === bar);  //  打印 false</div><div class=\"line\"></div><div class=\"line\">// 使用  seamless-immutable.js 后</div><div class=\"line\">import SImmutable from &apos;seamless-immutable&apos;;</div><div class=\"line\">foo = SImmutable(&#123;a: &#123;b: 1&#125;&#125;)</div><div class=\"line\">bar = foo.merge(&#123;a: &#123; b: 2&#125;&#125;)   // 使用 merge 赋值</div><div class=\"line\">console.log(foo.a.b);  // 像原生 Object 一样取值，打印 1</div><div class=\"line\">console.log(foo === bar);  //  打印 false</div></pre></td></tr></table></figure>\n<p></p><p style=\"font-weight: bold;font-size: 20px;\">IMMUTABLE 优点</p>1.Immutable 降低了 Mutable 带来的复杂度<p></p>\n<pre><code>可变（Mutable）数据耦合了 Time 和 Value 的概念，造成了数据很难被回溯。\n</code></pre><p>比如下面一段代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">function touchAndLog(touchFn) &#123;</div><div class=\"line\">  let data = &#123; key: &apos;value&apos; &#125;;</div><div class=\"line\">  touchFn(data);</div><div class=\"line\">  console.log(data.key); // 猜猜会打印什么？</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 在不查看 touchFn 的代码的情况下，因为不确定它对 data 做了什么，你是不可能知道会打印什么（这不是废话吗）。但如果 data 是 Immutable 的呢，你可以很肯定的知道打印的是 value。</p>\n<p>2.节省内存</p>\n<p>Immutable.js 使用了 Structure Sharing 会尽量复用内存，甚至以前使用的对象也可以再次被复用。没有被引用的对象会被垃圾回收。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; Map&#125; from &apos;immutable&apos;;</div><div class=\"line\">let a = Map(&#123;</div><div class=\"line\">  select: &apos;users&apos;,</div><div class=\"line\">  filter: Map(&#123; name: &apos;Cam&apos; &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\">let b = a.set(&apos;select&apos;, &apos;people&apos;);</div><div class=\"line\"></div><div class=\"line\">a === b; // false</div><div class=\"line\">a.get(&apos;filter&apos;) === b.get(&apos;filter&apos;); // true</div></pre></td></tr></table></figure>\n<p>上面 a 和 b 共享了没有变化的 filter 节点。</p>\n<p>3.Undo/Redo，Copy/Paste，甚至时间旅行这些功能做起来小菜一碟</p>\n<p>因为每次数据都是不一样的，只要把这些数据放到一个数组里储存起来，想回退到哪里就拿出对应数据即可，很容易开发出撤销重做这种功能。</p>\n<p>后面我会提供 Flux 做 Undo 的示例。</p>\n<p>4.并发安全</p>\n<p>传统的并发非常难做，因为要处理各种数据不一致问题，因此『聪明人』发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，并发锁就不需要了。</p>\n<p>然而现在并没什么卵用，因为 JavaScript 还是单线程运行的啊。但未来可能会加入，提前解决未来的问题不也挺好吗？</p>\n<p>5.拥抱函数式编程</p>\n<p>Immutable 本身就是函数式编程中的概念，纯函数式编程比面向对象更适用于前端开发。因为只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</p>\n<p>像 ClojureScript，Elm 等函数式编程语言中的数据类型天生都是 Immutable 的，这也是为什么 ClojureScript 基于 React 的框架 — Om 性能比 React 还要好的原因。</p>\n<p>IMMUTABLE 缺点<br>1.需要学习新的 API</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">No Comments</div></pre></td></tr></table></figure>\n<p>2.增加了资源文件大小</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">No Comments</div></pre></td></tr></table></figure>\n<p>3.容易与原生对象混淆</p>\n<p>这点是我们使用 Immutable.js 过程中遇到最大的问题。写代码要做思维上的转变。</p>\n<p>虽然 Immutable.js 尽量尝试把 API 设计的原生对象类似，有的时候还是很难区别到底是 Immutable 对象还是原生对象，容易混淆操作。</p>\n<p>Immutable 中的 Map 和 List 虽对应原生 Object 和 Array，但操作非常不同，比如你要用 map.get(‘key’)而不是 map.key，array.get(0) 而不是 array[0]。另外               Immutable 每次修改都会返回新对象，也很容易忘记赋值。</p>\n<p>当使用外部库的时候，一般需要使用原生对象，也很容易忘记转换。</p>\n<p>下面给出一些办法来避免类似问题发生：</p>\n<p>使用 Flow 或 TypeScript 这类有静态类型检查的工具<br>约定变量命名规则：如所有 Immutable 类型对象以 $$ 开头。<br>使用 Immutable.fromJS 而不是 Immutable.Map 或 Immutable.List 来创建对象，这样可以避免 Immutable 和原生对象间的混用。<br>更多认识<br>Immutable.is</p>\n<p>两个 immutable 对象可以使用 === 来比较，这样是直接比较内存地址，性能最好。但即使两个对象的值是一样的，也会返回 false：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let map1 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);</div><div class=\"line\">let map2 = Immutable.Map(&#123;a:1, b:1, c:1&#125;);</div><div class=\"line\">map1 === map2;             // false</div></pre></td></tr></table></figure>\n<p>为了直接比较对象的值，immutable.js 提供了 Immutable.is 来做『值比较』，结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Immutable.is(map1, map2);  // true</div></pre></td></tr></table></figure>\n<p>Immutable.is 比较的是两个对象的 hashCode 或 valueOf（对于 JavaScript 对象）。由于 immutable 内部使用了 Trie 数据结构来存储，只要两个对象的 hashCode 相等，值就是一样的。这样的算法避免了深度遍历比较，性能非常好。</p>\n<p>后面会使用 Immutable.is 来减少 React 重复渲染，提高性能。</p>\n<p>另外，还有 mori、cortex 等，因为类似就不再介绍。</p>\n<p>与 Object.freeze、const 区别</p>\n<p>  Object.freeze 和 ES6 中新加入的 const 都可以达到防止对象被篡改的功能，但它们是 shallowCopy 的。对象层级一深就要特殊处理了。</p>\n<p>Cursor 的概念</p>\n<p>这个 Cursor 和数据库中的游标是完全不同的概念。</p>\n<p> 由于 Immutable 数据一般嵌套非常深，为了便于访问深层数据，Cursor 提供了可以直接访问这个深层数据的引用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">import Immutable from &apos;immutable&apos;;</div><div class=\"line\">import Cursor from &apos;immutable/contrib/cursor&apos;;</div><div class=\"line\"></div><div class=\"line\">let data = Immutable.fromJS(&#123; a: &#123; b: &#123; c: 1 &#125; &#125; &#125;);</div><div class=\"line\">// 让 cursor 指向 &#123; c: 1 &#125;</div><div class=\"line\">let cursor = Cursor.from(data, [&apos;a&apos;, &apos;b&apos;], newData =&gt; &#123;</div><div class=\"line\">  // 当 cursor 或其子 cursor 执行 update 时调用</div><div class=\"line\">  console.log(newData);</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">cursor.get(&apos;c&apos;); // 1</div><div class=\"line\">cursor = cursor.update(&apos;c&apos;, x =&gt; x + 1);</div><div class=\"line\">cursor.get(&apos;c&apos;); // 2</div></pre></td></tr></table></figure>\n<p>实践<br>与 React 搭配使用，Pure Render</p>\n<p>熟悉 React 的都知道，React 做性能优化时有一个避免重复渲染的大招，就是使用 shouldComponentUpdate()，但它默认返回 true，即始终会执行 render() 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 更新，这里往往会带来很多无必要的渲染并成为性能瓶颈。</p>\n<p>当然我们也可以在 shouldComponentUpdate() 中使用使用 deepCopy 和 deepCompare 来避免无必要的 render()，但 deepCopy 和 deepCompare 一般都是非常耗性能的。<br> Immutable 则提供了简洁高效的判断数据是否变化的方法，只需 === 和 is 比较就能知道是否需要执行 render()，而这个操作几乎 0 成本，所以可以极大提高性能。修改后的 shouldComponentUpdate 是这样的：</p>\n<p>注意：React 中规定 state 和 props 只能是一个普通对象，所以比较时要比较对象的 key</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">import &#123; is &#125; from &apos;immutable&apos;;</div><div class=\"line\">shouldComponentUpdate: (nextProps = &#123;&#125;, nextState = &#123;&#125;) =&gt; &#123;</div><div class=\"line\">  const thisProps = this.props || &#123;&#125;, thisState = this.state || &#123;&#125;;</div><div class=\"line\"></div><div class=\"line\">  if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||</div><div class=\"line\">      Object.keys(thisState).length !== Object.keys(nextState).length) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  for (const key in nextProps) &#123;</div><div class=\"line\">    if (!is(thisProps[key], nextProps[key])) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  for (const key in nextState) &#123;</div><div class=\"line\">    if (thisState[key] !== nextState[key] || !is(thisState[key], nextState[key])) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>与 Redux 搭配使用<br> Redux 是目前流行的 Flux 衍生库。它简化了 Flux 中多个 Store 的概念，只有一个 Store，数据操作通过 Reducer 中实现；同时它提供更简洁和清晰的单向数据流（View -&gt; Action -&gt; Middleware -&gt; Reducer），也更易于开发同构应用。目前已经在我们项目中大规模使用。</p>\n<p>由于 Redux 中内置的 combineReducers 和 reducer 中的 initialState 都为原生的 Object 对象，所以不能和 Immutable 原生搭配使用。</p>\n<p>幸运的是，Redux 并不排斥使用 Immutable，可以自己重写 combineReducers 或使用 redux-immutablejs 来提供支持。</p>\n<p>上面我们提到 Cursor 可以方便检索和 update 层级比较深的数据，但因为 Redux 中已经有了 select 来做检索，Action 来更新数据，因此 Cursor 在这里就没有用武之地了。</p>\n<p>总结<br> Immutable 可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要评估迁移。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外接口中。</p>\n<p>如果 JS 原生 Immutable 类型会不会太美，被称为 React API 终结者的 Sebastian Markbåge 有一个这样的提案，能否通过现在还不确定。不过可以肯定的是 Immutable 会被越来越多的项目使用。<br>以上纯属个人的理解！！</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"Facebook 工程师 Lee Byron 花费 3 年时间打造，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的 Persistent Data Structure，还有很多易用的数据类型。像 Collection、List、Map、Set、Record、Seq。有非常全面的map、filter、groupBy、reduce``find函数式操作方法。同时 API 也尽量与 Object 或 Array 类似。","categories":[],"tags":[{"name":"React","slug":"React","permalink":"http://www.pengmengshan.cn/blog/tags/React/"},{"name":"immutable","slug":"immutable","permalink":"http://www.pengmengshan.cn/blog/tags/immutable/"}]},{"title":"原生Ajax的实现","date":"2017-06-12T14:52:08.000Z","path":"2017/06/12/ajax /","text":"近端时间一个项目用到原生来实现Ajax,一直也没时间发布博客，不过近期在博客园这个平台活跃起来了，大家也可以去访问我的 博客园 哦!! 123456789101112131415161718192021222324252627282930313233&lt;script type=\"text/javascript\"&gt; // Ajax固定的模版 // 第一步：创建xhr对象，使用new关键字来调用内置的构造函数 var xhr = new XMLHttpRequest(); // 第二步：指定接收回来的内容。监听xhr // 对象的onreadystatechange事件，这个事件xhr对象的\"就绪状态\"改变的时候触发。我们只关心就绪状态为4的时候的事情； xhr.onreadystatechange = function()&#123; if( xhr.readyState == 4 )&#123; // 接收完文件要做的事情，让txt文本中的内容读取出来 document.getElementById(\"info\").innerHTML = xhr.responseText; &#125; &#125;; // 第三步，创建哪一个请求，第一个参数请求是类型是get或post，第二个参数是请求的路径，第三个参数：是否是异步的机制；一定是true； xhr.open(\"get\",\"test.txt\",true); // 第四步：发送请求,圆括号内是请求的内容，get请求没有报文体写null； xhr.send(null);&lt;/script&gt; 以上纯属个人的理解！！ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>近端时间一个项目用到原生来实现Ajax,一直也没时间发布博客，不过近期在博客园这个平台活跃起来了，大家也可以去访问我的<a href=\"http://www.cnblogs.com/pms01/\" style=\"color:red;text-decoration: underline;\" target=\"_blank\" rel=\"external\"> 博客园 </a>哦!!<br><a id=\"more\"></a></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Ajax固定的模版</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第一步：创建xhr对象，使用new关键字来调用内置的构造函数</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第二步：指定接收回来的内容。监听xhr</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 对象的onreadystatechange事件，这个事件xhr对象的\"就绪状态\"改变的时候触发。我们只关心就绪状态为4的时候的事情；</span></div><div class=\"line\"></div><div class=\"line\">    xhr.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span>( xhr.readyState == <span class=\"number\">4</span> )&#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"comment\">// 接收完文件要做的事情，让txt文本中的内容读取出来</span></div><div class=\"line\"></div><div class=\"line\">            <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">\"info\"</span>).innerHTML = xhr.responseText;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第三步，创建哪一个请求，第一个参数请求是类型是get或post，第二个参数是请求的路径，第三个参数：是否是异步的机制；一定是true；</span></div><div class=\"line\"></div><div class=\"line\">    xhr.open(<span class=\"string\">\"get\"</span>,<span class=\"string\">\"test.txt\"</span>,<span class=\"literal\">true</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 第四步：发送请求,圆括号内是请求的内容，get请求没有报文体写null；</span></div><div class=\"line\"></div><div class=\"line\">    xhr.send(<span class=\"literal\">null</span>);</div><div class=\"line\"></div><div class=\"line\">&lt;/script&gt;</div></pre></td></tr></table></figure>\n<p>以上纯属个人的理解！！</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"近端时间一个项目用到原生来实现Ajax,一直也没时间发布博客，不过近期在博客园这个平台活跃起来了，大家也可以去访问我的 博客园 哦!!","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.pengmengshan.cn/blog/tags/js/"},{"name":"Ajax","slug":"Ajax","permalink":"http://www.pengmengshan.cn/blog/tags/Ajax/"}]},{"title":"谈谈JS构造函数!!","date":"2017-06-01T00:52:08.000Z","path":"2017/06/01/it-20170601js/","text":"今天是六一儿童节，有段时间没发博客了，今天先祝贺各位儿童节快乐！！！今天我就对JS构造函数进行个详解，请看下面代码 12345678910111213141516171819202122232425262728293031323334353637//构造函数//使自己的对象多次复制，同时实例根据设置的访问等级可以访问其内部的属性和方法//当对象被实例化后，构造函数会立即执行它所包含的任何代码function myObject(msg) &#123; //特权属性(公有属性) this.myMsg = msg; //只在被实例化后的实例中可调用 this.address = 'Chengdu'; //私有属性：无法通过对象直接访问 var name = 'Tirion'; var that = this; //私有方法 function sayName() &#123; alert(that.name); &#125; //特权方法(公有方法) //能被外部公开访问 //这个方法每次实例化都要重新构造而prototype是原型共享，所有实例化后，都共同引用同一个 this.sayAge = function() &#123; alert(name); //在公有方法中可以访问私有成员 &#125; //私有和特权成员在函数的内部，在构造函数创建的每个实例中都会包含同样的私有和特权成员的副本，因而实例越多占用的内存越多&#125;//公有方法//适用于通过new关键字实例化的该对象的每个实例//向prototype中添加成员将会把新方法添加到构造函数的底层中去myObject.prototype.sayHello = function() &#123; alert('hello everyone!'); &#125;//静态属性：通过一个对象实例修改后，其它对象实例来访问，也是修改后的值//适用于对象的特殊实例，就是作为Function对象实例的构造函数本身myObject.name = 'china'; //函数也是特殊的对象，所以可以给函数添加属性和方法。而要通过对象来访问，就要先得到这个构造函数，再访问构造函数的属性即可：m1.constructor.name//静态方法myObject.alertname = function() &#123; //访问方式同静态属性 alert(this.name); //当通过对象实例的constructor访问这个静态方法的时候，执行上下文也是constructor即myObject，所以会得到myObject的name即china &#125;//实例化var m1 = new myObject('111'); 以上纯属个人的理解！！ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>今天是六一儿童节，有段时间没发博客了，今天先祝贺各位儿童节快乐！！！今天我就对JS构造函数进行个详解，请看下面代码</p>\n<a id=\"more\"></a>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//构造函数</span></div><div class=\"line\"><span class=\"comment\">//使自己的对象多次复制，同时实例根据设置的访问等级可以访问其内部的属性和方法</span></div><div class=\"line\"><span class=\"comment\">//当对象被实例化后，构造函数会立即执行它所包含的任何代码</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myObject</span>(<span class=\"params\">msg</span>) </span>&#123;</div><div class=\"line\">    <span class=\"comment\">//特权属性(公有属性)</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.myMsg = msg; <span class=\"comment\">//只在被实例化后的实例中可调用</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.address = <span class=\"string\">'Chengdu'</span>;</div><div class=\"line\">    <span class=\"comment\">//私有属性：无法通过对象直接访问</span></div><div class=\"line\">    <span class=\"keyword\">var</span> name = <span class=\"string\">'Tirion'</span>;</div><div class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">    <span class=\"comment\">//私有方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sayName</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        alert(that.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//特权方法(公有方法)</span></div><div class=\"line\">    <span class=\"comment\">//能被外部公开访问</span></div><div class=\"line\">    <span class=\"comment\">//这个方法每次实例化都要重新构造而prototype是原型共享，所有实例化后，都共同引用同一个</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.sayAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            alert(name); <span class=\"comment\">//在公有方法中可以访问私有成员</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"comment\">//私有和特权成员在函数的内部，在构造函数创建的每个实例中都会包含同样的私有和特权成员的副本，因而实例越多占用的内存越多</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//公有方法</span></div><div class=\"line\"><span class=\"comment\">//适用于通过new关键字实例化的该对象的每个实例</span></div><div class=\"line\"><span class=\"comment\">//向prototype中添加成员将会把新方法添加到构造函数的底层中去</span></div><div class=\"line\">myObject.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        alert(<span class=\"string\">'hello everyone!'</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//静态属性：通过一个对象实例修改后，其它对象实例来访问，也是修改后的值</span></div><div class=\"line\"><span class=\"comment\">//适用于对象的特殊实例，就是作为Function对象实例的构造函数本身</span></div><div class=\"line\">myObject.name = <span class=\"string\">'china'</span>;  <span class=\"comment\">//函数也是特殊的对象，所以可以给函数添加属性和方法。而要通过对象来访问，就要先得到这个构造函数，再访问构造函数的属性即可：m1.constructor.name</span></div><div class=\"line\"><span class=\"comment\">//静态方法</span></div><div class=\"line\">myObject.alertname = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  <span class=\"comment\">//访问方式同静态属性</span></div><div class=\"line\">        alert(<span class=\"keyword\">this</span>.name);  <span class=\"comment\">//当通过对象实例的constructor访问这个静态方法的时候，执行上下文也是constructor即myObject，所以会得到myObject的name即china</span></div><div class=\"line\">    &#125;</div><div class=\"line\"><span class=\"comment\">//实例化</span></div><div class=\"line\"><span class=\"keyword\">var</span> m1 = <span class=\"keyword\">new</span> myObject(<span class=\"string\">'111'</span>);</div></pre></td></tr></table></figure>\n<p>以上纯属个人的理解！！</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"今天是六一儿童节，有段时间没发博客了，今天先祝贺各位儿童节快乐！！！今天我就对JS构造函数进行个详解，请看下面代码","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.pengmengshan.cn/blog/tags/js/"}]},{"title":"搭建ES6运行环境","date":"2017-05-25T08:50:00.000Z","path":"2017/05/25/es6/","text":"当ES5还没有完全普及时，ES6就接踵而来了，2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015，我们也简称它为ES6或ES2015。在发布之后的将近一年内，很多小伙伴都踊跃的学习这门新的语言，之所以说是一门新的语言，是因为跟ES5相比，语法方面变化确实有点大，可以说新的JavaScript语法看上去有种脱胎换骨的感觉。博主也曾跃跃欲试，看了很多语法方面的教程，可是无奈浏览器还未完全支持ES6的规范，只看不练，有种眼高手低的感觉，相信朋友们也会有同样的心情，那么怎样可以愉快的写ES6代码，进而将学到的东西转化成实践呢，别担心，今天我们就来学习ES6构建方面的知识，并搭建一个简单的学习环境。 首先需要介绍一个ES6开发利器：Babel。Babel是一个编译器，负责将\b源代码转换成指定的语法的目标代码，可以使之很好的在运行环境中执行我们的代码。下面我们就来详细介绍这个神器，利用它来编译我们的ES6代码。Babel给我们提供了一个很方便的命令行工具：babel-cli，利用它我们可以在命令行中执行编译命令，我们只需使用npm来安装它即可：1npm install -g babel-cli 除此之外，我们还需要安装转码规则包，Babel支持很多语法的转码，比如我们想要将ES6转换成ES5，那么需要安装babel-preset-es2015包，如果我们想要编译React源码，就需要安装babel-preset-react，这里我们需要安装babel-preset-es2015。为此我们创建一个babel-test目录，在这个目录里我们创建两个目录，es6和js，分别用于放置ES6源代码和编译后的ES5目标代码，然后我们使用“npm init –yes”命令生成一个默认的package.json文件，babel-test目录结构如下图所示： 然后在当前目录执行下面这行命令安装ES6转码规则包：1npm install babel-preset-es2015 --save-dev 在es6目录中我们创建了一个test.es6文件用于写入ES6源代码，Babel编译源文件时没有过多的限制，所以我们也可以选择使用js或es作为文件后缀名。现在我们将下面这段ES6代码写入到test.es6中：123let name = &apos;Scott&apos;;let greeting = `hello $&#123;name&#125;`;console.log(greeting); 接下来我们就可以来运行babel的命令编译我们的ES6源代码了： 1babel es6/test.es6 --out-file js/test.js --presets es2015 这行命令的含义是：编译es6下面的test.es6文件，输出文件为js下面的test.js，同时指定编译规则包为es2015。命令执行完成后，我们会在js目录中找到一个test.js文件，如图所示： 看以看到，上面的ES6语法已经被编译成ES5的语法了，这个文件就可以被加载到现有的运行环境执行了。另外，如果我们也可以编译整个目录的源文件，只需指定“–out-dir”参数即可： 1babel es6 --out-dir js --presets es2015 这行命令的作用是对整个es6目录中的文件进行编译，编译结果输出到js目录，如下图所示： 到目前为止，我们仍手动执行babel命令编译源代码，并且我们使用了全局的babel-cli库，这显然不是最好的解决方案。如果我们checkout出一个项目，必须要先在全局安装babel-cli库才能运行，我们不希望有这样的依赖。另外不同的项目依赖库的版本可能都不同，全局的babel-cli库也不能保证兼容各个项目中其他依赖库的版本。除此之外，每次手动运行编译命令也太繁琐了，我们希望将babel-cli库安装到本地，并且使用一个简单的命令执行编译任务。首先我们需要在本地安装babel-cli库：1npm install babel-cli --save-dev 现在我们可以卸载全局的babel-cli库了：1npm uninstall -g babel-cli 最后，我们需要在package.json里面修改一下scripts：123&quot;scripts&quot;: &#123; &quot;compile&quot;: &quot;babel es6 --out-dir js --presets es2015&quot;&#125; 修改完成之后，我们就可以使用npm来运行这个编译任务了，只需下面一条简单的指令即可：1npm run compile 上面只是利用babel将ES6源代码编译成JS，在开发中，我们还需要考虑更多东西，比如模块化开发、自动编译和构建等等。接下来，我们就搭建一个简单的ES6开发环境，来支持ES6学习阶段的开发。首先，我们创建一个简单的应用，它包含一个index.html和es6目录，es6目录中又包含hello.es6和main.es6两个文件，在构建完成后，会多出js和bundle两个目录，分别放置编译后的JS代码和打包后的bundle文件： 其中，hello.es6定义了greet函数，而main.es6是入口文件，下面是相关的代码： 1234567891011//hello.es6function greet(name) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&apos;hello &apos; + name); &#125;, 1000); &#125;);&#125;exports.greet = greet; 1234567891011//main.es6import &quot;babel-polyfill&quot;;import &#123;greet&#125; from &apos;./hello&apos;;greet(&apos;Scott&apos;).then((greeting) =&gt; &#123; document.getElementById(&apos;container&apos;).innerHTML += greeting;&#125;);document.getElementById(&apos;container&apos;).innerHTML = &apos;I am greeting: &apos;; 可以看到，hello.es6中使用了ES6的箭头函数和Promise来定义一个greet函数，模拟1秒后返回一个hello开头的字符串，而main.es6中引入了hello.es6并调用了greet函数，最后将结果刷新到DOM元素中。要使这两个源代码文件生效，首先需要把它们编译成JS，然后再将JS文件打包，现在我们就来使用gulp的方式构建这个过程。要完成这个任务，我们需要先安装相关的依赖包： 1234567891011&quot;devDependencies&quot;: &#123; &quot;babel-polyfill&quot;: &quot;^6.9.1&quot;, &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-babel&quot;: &quot;^6.1.2&quot;, &quot;gulp-browserify&quot;: &quot;^0.5.1&quot;, &quot;gulp-connect&quot;: &quot;^3.2.2&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-sync&quot;: &quot;^0.1.4&quot;, &quot;gulp-uglify&quot;: &quot;^1.5.3&quot;&#125; 其中，babel-polyfill是ES6的补丁，由于babel只支持ES6语法部分的编译，对于新增的类我们还需要安装额外的polyfill，虽然现在Chrome和Firefox都已经添加了Promise等新增的类，但为了兼容旧版本的浏览器，这里还是安装比较好。然后，我们就创建几个简单的tasks，下面是gulpfile.js的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546var gulp = require(&apos;gulp&apos;);var babel = require(&apos;gulp-babel&apos;);var connect = require(&apos;gulp-connect&apos;);var browserify = require(&apos;gulp-browserify&apos;);var uglify = require(&apos;gulp-uglify&apos;);var rename = require(&apos;gulp-rename&apos;);var gulpsync = require(&apos;gulp-sync&apos;)(gulp);gulp.task(&apos;compile-es6&apos;, function() &#123; return gulp.src(&apos;app/es6/*&apos;) .pipe(babel(&#123; presets: [&apos;es2015&apos;] &#125;)) .pipe(gulp.dest(&apos;app/js&apos;));&#125;);gulp.task(&apos;pack-js&apos;, function() &#123; return gulp.src(&apos;app/js/main.js&apos;) .pipe(browserify()) .pipe(rename(&apos;bundle.js&apos;)) .pipe(gulp.dest(&apos;app/bundle&apos;));&#125;);gulp.task(&apos;compress-bundle&apos;, function() &#123; return gulp.src(&apos;app/bundle/bundle.js&apos;) .pipe(uglify()) .pipe(rename(&apos;bundle.min.js&apos;)) .pipe(gulp.dest(&apos;app/bundle&apos;));&#125;);//build source files to released bundle filegulp.task(&apos;build&apos;, gulpsync.sync([&apos;compile-es6&apos;, &apos;pack-js&apos;, &apos;compress-bundle&apos;]), function() &#123; if (process.argv.pop() == &apos;--dev&apos;) &#123; //watch any change and then re-run the tasks gulp.watch(&apos;app/es6/*&apos;, gulpsync.sync([&apos;compile-es6&apos;, &apos;pack-js&apos;, &apos;compress-bundle&apos;])); &#125;&#125;);//run a server listening at port 8000gulp.task(&apos;server&apos;, function() &#123; connect.server(&#123; root: &apos;app&apos;, port: 8000, livereload: true &#125;);&#125;); 最后，只需在命令行中执行两个命令就可以了：1gulp build --dev 1gulp server 第一个命令我们是指定了开发模式，开发模式会监听es6目录中的文件改动，并重新构建；而第二个命令是用来启动一个服务，在8000端口监听。 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>当ES5还没有完全普及时，ES6就接踵而来了，2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015，我们也简称它为ES6或ES2015。在发布之后的将近一年内，很多小伙伴都踊跃的学习这门新的语言，之所以说是一门新的语言，是因为跟ES5相比，语法方面变化确实有点大，可以说新的JavaScript语法看上去有种脱胎换骨的感觉。博主也曾跃跃欲试，看了很多语法方面的教程，可是无奈浏览器还未完全支持ES6的规范，只看不练，有种眼高手低的感觉，相信朋友们也会有同样的心情，那么怎样可以愉快的写ES6代码，进而将学到的东西转化成实践呢，别担心，今天我们就来学习ES6构建方面的知识，并搭建一个简单的学习环境。</p>\n<a id=\"more\"></a>\n<p>首先需要介绍一个ES6开发利器：Babel。<br>Babel是一个编译器，负责将\b源代码转换成指定的语法的目标代码，可以使之很好的在运行环境中执行我们的代码。下面我们就来详细介绍这个神器，利用它来编译我们的ES6代码。<br>Babel给我们提供了一个很方便的命令行工具：babel-cli，利用它我们可以在命令行中执行编译命令，我们只需使用npm来安装它即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g babel-cli</div></pre></td></tr></table></figure></p>\n<p>   除此之外，我们还需要安装转码规则包，Babel支持很多语法的转码，比如我们想要将ES6转换成ES5，那么需要安装babel-preset-es2015包，如果我们想要编译React源码，就需要安装babel-preset-react，这里我们需要安装babel-preset-es2015。为此我们创建一个babel-test目录，在这个目录里我们创建两个目录，es6和js，分别用于放置ES6源代码和编译后的ES5目标代码，然后我们使用“npm init –yes”命令生成一个默认的package.json文件，babel-test目录结构如下图所示：</p>\n<p>然后在当前目录执行下面这行命令安装ES6转码规则包：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install babel-preset-es2015 --save-dev</div></pre></td></tr></table></figure></p>\n<p>在es6目录中我们创建了一个test.es6文件用于写入ES6源代码，Babel编译源文件时没有过多的限制，所以我们也可以选择使用js或es作为文件后缀名。现在我们将下面这段ES6代码写入到test.es6中：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">let name = &apos;Scott&apos;;</div><div class=\"line\">let greeting = `hello $&#123;name&#125;`;</div><div class=\"line\">console.log(greeting);</div></pre></td></tr></table></figure></p>\n<p>接下来我们就可以来运行babel的命令编译我们的ES6源代码了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">babel es6/test.es6 --out-file js/test.js --presets es2015</div></pre></td></tr></table></figure>\n<p>这行命令的含义是：编译es6下面的test.es6文件，输出文件为js下面的test.js，同时指定编译规则包为es2015。命令执行完成后，我们会在js目录中找到一个test.js文件，如图所示：</p>\n<p>看以看到，上面的ES6语法已经被编译成ES5的语法了，这个文件就可以被加载到现有的运行环境执行了。另外，如果我们也可以编译整个目录的源文件，只需指定“–out-dir”参数即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">babel es6 --out-dir js --presets es2015</div></pre></td></tr></table></figure>\n<p>这行命令的作用是对整个es6目录中的文件进行编译，编译结果输出到js目录，如下图所示：</p>\n<p>到目前为止，我们仍手动执行babel命令编译源代码，并且我们使用了全局的babel-cli库，这显然不是最好的解决方案。如果我们checkout出一个项目，必须要先在全局安装babel-cli库才能运行，我们不希望有这样的依赖。另外不同的项目依赖库的版本可能都不同，全局的babel-cli库也不能保证兼容各个项目中其他依赖库的版本。除此之外，每次手动运行编译命令也太繁琐了，我们希望将babel-cli库安装到本地，并且使用一个简单的命令执行编译任务。<br>首先我们需要在本地安装babel-cli库：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install babel-cli --save-dev</div></pre></td></tr></table></figure></p>\n<p>现在我们可以卸载全局的babel-cli库了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm uninstall -g babel-cli</div></pre></td></tr></table></figure></p>\n<p>最后，我们需要在package.json里面修改一下scripts：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;scripts&quot;: &#123;</div><div class=\"line\">    &quot;compile&quot;: &quot;babel es6 --out-dir js --presets es2015&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>修改完成之后，我们就可以使用npm来运行这个编译任务了，只需下面一条简单的指令即可：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm run compile</div></pre></td></tr></table></figure></p>\n<p>上面只是利用babel将ES6源代码编译成JS，在开发中，我们还需要考虑更多东西，比如模块化开发、自动编译和构建等等。接下来，我们就搭建一个简单的ES6开发环境，来支持ES6学习阶段的开发。<br>首先，我们创建一个简单的应用，它包含一个index.html和es6目录，es6目录中又包含hello.es6和main.es6两个文件，在构建完成后，会多出js和bundle两个目录，分别放置编译后的JS代码和打包后的bundle文件：</p>\n<p>其中，hello.es6定义了greet函数，而main.es6是入口文件，下面是相关的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//hello.es6</div><div class=\"line\"></div><div class=\"line\">function greet(name) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">        setTimeout(() =&gt; &#123;</div><div class=\"line\">            resolve(&apos;hello &apos; + name);</div><div class=\"line\">        &#125;, 1000);</div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">exports.greet = greet;</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">//main.es6</div><div class=\"line\"></div><div class=\"line\">import &quot;babel-polyfill&quot;;</div><div class=\"line\"></div><div class=\"line\">import &#123;greet&#125; from &apos;./hello&apos;;</div><div class=\"line\"></div><div class=\"line\">greet(&apos;Scott&apos;).then((greeting) =&gt; &#123;</div><div class=\"line\">    document.getElementById(&apos;container&apos;).innerHTML += greeting;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">document.getElementById(&apos;container&apos;).innerHTML = &apos;I am greeting: &apos;;</div></pre></td></tr></table></figure>\n<p>可以看到，hello.es6中使用了ES6的箭头函数和Promise来定义一个greet函数，模拟1秒后返回一个hello开头的字符串，而main.es6中引入了hello.es6并调用了greet函数，最后将结果刷新到DOM元素中。<br>要使这两个源代码文件生效，首先需要把它们编译成JS，然后再将JS文件打包，现在我们就来使用gulp的方式构建这个过程。<br>要完成这个任务，我们需要先安装相关的依赖包：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;devDependencies&quot;: &#123;</div><div class=\"line\">  &quot;babel-polyfill&quot;: &quot;^6.9.1&quot;,</div><div class=\"line\">  &quot;babel-preset-es2015&quot;: &quot;^6.6.0&quot;,</div><div class=\"line\">  &quot;gulp&quot;: &quot;^3.9.1&quot;,</div><div class=\"line\">  &quot;gulp-babel&quot;: &quot;^6.1.2&quot;,</div><div class=\"line\">  &quot;gulp-browserify&quot;: &quot;^0.5.1&quot;,</div><div class=\"line\">  &quot;gulp-connect&quot;: &quot;^3.2.2&quot;,</div><div class=\"line\">  &quot;gulp-rename&quot;: &quot;^1.2.2&quot;,</div><div class=\"line\">  &quot;gulp-sync&quot;: &quot;^0.1.4&quot;,</div><div class=\"line\">  &quot;gulp-uglify&quot;: &quot;^1.5.3&quot;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中，babel-polyfill是ES6的补丁，由于babel只支持ES6语法部分的编译，对于新增的类我们还需要安装额外的polyfill，虽然现在Chrome和Firefox都已经添加了Promise等新增的类，但为了兼容旧版本的浏览器，这里还是安装比较好。<br>然后，我们就创建几个简单的tasks，下面是gulpfile.js的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">var gulp = require(&apos;gulp&apos;);</div><div class=\"line\">var babel = require(&apos;gulp-babel&apos;);</div><div class=\"line\">var connect = require(&apos;gulp-connect&apos;);</div><div class=\"line\">var browserify = require(&apos;gulp-browserify&apos;);</div><div class=\"line\">var uglify = require(&apos;gulp-uglify&apos;);</div><div class=\"line\">var rename = require(&apos;gulp-rename&apos;);</div><div class=\"line\">var gulpsync = require(&apos;gulp-sync&apos;)(gulp);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;compile-es6&apos;, function() &#123;</div><div class=\"line\">  return gulp.src(&apos;app/es6/*&apos;)</div><div class=\"line\">    .pipe(babel(&#123;</div><div class=\"line\">      presets: [&apos;es2015&apos;]</div><div class=\"line\">    &#125;))</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/js&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;pack-js&apos;, function() &#123;</div><div class=\"line\">  return gulp.src(&apos;app/js/main.js&apos;)</div><div class=\"line\">    .pipe(browserify())</div><div class=\"line\">    .pipe(rename(&apos;bundle.js&apos;))</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/bundle&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;compress-bundle&apos;, function() &#123;</div><div class=\"line\">  return gulp.src(&apos;app/bundle/bundle.js&apos;)</div><div class=\"line\">    .pipe(uglify())</div><div class=\"line\">    .pipe(rename(&apos;bundle.min.js&apos;))</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/bundle&apos;));</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//build source files to released bundle file</div><div class=\"line\">gulp.task(&apos;build&apos;, gulpsync.sync([&apos;compile-es6&apos;, &apos;pack-js&apos;, &apos;compress-bundle&apos;]), function() &#123;</div><div class=\"line\">  if (process.argv.pop() == &apos;--dev&apos;) &#123;</div><div class=\"line\">    //watch any change and then re-run the tasks</div><div class=\"line\">    gulp.watch(&apos;app/es6/*&apos;, gulpsync.sync([&apos;compile-es6&apos;, &apos;pack-js&apos;, &apos;compress-bundle&apos;]));</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">//run a server listening at port 8000</div><div class=\"line\">gulp.task(&apos;server&apos;, function() &#123;</div><div class=\"line\">  connect.server(&#123;</div><div class=\"line\">    root: &apos;app&apos;,</div><div class=\"line\">    port: 8000,</div><div class=\"line\">    livereload: true</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>最后，只需在命令行中执行两个命令就可以了：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp build --dev</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp server</div></pre></td></tr></table></figure>\n<p>第一个命令我们是指定了开发模式，开发模式会监听es6目录中的文件改动，并重新构建；而第二个命令是用来启动一个服务，在8000端口监听。</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n\n","excerpt":"当ES5还没有完全普及时，ES6就接踵而来了，2015年6月17日，ECMAScript 6发布正式版本，即ECMAScript 2015，我们也简称它为ES6或ES2015。在发布之后的将近一年内，很多小伙伴都踊跃的学习这门新的语言，之所以说是一门新的语言，是因为跟ES5相比，语法方面变化确实有点大，可以说新的JavaScript语法看上去有种脱胎换骨的感觉。博主也曾跃跃欲试，看了很多语法方面的教程，可是无奈浏览器还未完全支持ES6的规范，只看不练，有种眼高手低的感觉，相信朋友们也会有同样的心情，那么怎样可以愉快的写ES6代码，进而将学到的东西转化成实践呢，别担心，今天我们就来学习ES6构建方面的知识，并搭建一个简单的学习环境。","categories":[],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://www.pengmengshan.cn/blog/tags/ES6/"}]},{"title":"一些心得","date":"2017-05-17T01:42:35.000Z","path":"2017/05/17/qianduan/","text":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在前端这个行业不得不要求你不断地学习、成长，想想现在与五年前相比，都发生了多么翻天覆地的变化。引用一句之前我看到的话“一时间出现这么多新东西，让我有些恐慌”，一面是成长的压力，另一面是各种的选择困难。还有一点也挺残酷的，这个行业不是谁资历越老就越牛逼的，说到根本还是比拼的内功，还有的是比别人更加的努力学习，这又让我想起了另一句话“很多人所谓的多年经验，无非是一年学来的经验在多年里面不断地重复着”，这真的挺可怕的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 自身的成长是个长期而且持续的过程，要有所取舍。前端的基础知识、各种框架的设计理念等可以多去了解一下。关于新技术，学习并且最好能落地到应用场景中去，同时不要盲目追求新技术，那会使你限入一个无底的黑洞。特别是这些年，越发地觉得要回归本质，我们现在用的大多数技是为了解决我们“谋生”的问题，而将来还是要更多地去关注一些偏向于底层的东西，就比如js的框架不管怎样日新月异，现在react、Vue等大行其道各种新的框架百花奇放，但js本身却在稳定地慢慢完善中，相比很多年前，你能看到它已经好了不知道多少，但这一切却不会让人有一种不知所措的失控感。前几周在做项目的时候，看到一个开发哥们捧着一本计算机原理的书在温习，我觉得挺好的，与其面对现在层出不穷的新语言新框架，不如退而温习一下这些失落已久的东西。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外，可以挖掘一下业务中还有哪些值得一做的，往往不直接产生价值，但具备共享特点并且需要长期投入的事情会少有人做，大家都喜欢做短平快的事情，能为年底晋升加薪争取亮点。尝试去主导这么一两件事，做你认为有价值的事，所以你会特别专注其中，你得去思考很多，去找寻一切可以帮助你的力量去推动这个事情的前进，这与平时别人交给你的任务不同，以前是别人都安排好了，你只不过是个“资源”，负责执行，而现在你是一个规划者、决策者和执行者，你即面对痛苦，又收获快乐，而以往的需求、项目，你可能做着做着就麻木了。技术人员在初入行业时候，是来什么做什么，而资深的技术人员在多年的折腾和磨练以后，具备了更为完善的思考能力，能够不仅仅只是交给什么做什么，并且是能发掘更有价值的事情去做，想想这样子的话，你带着小D们去做事，才能让他们看到未来和希望，用你的思维去影响他们，他们也才会有成长和收获，不然他们同样会问一个类似一样的问题，然后从根本就没有解决这个问题。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有就是业余时候，可以自己每年做一个小项目（比如app，一些新框架的项目），你能体会不同技术乐趣，也会因此意识到自己还需要再学点什么。其实现在的前端，要学的东西太多了，正如前面提到的，会让人陷入选择的恐慌中。在自己有时间的时候除了巩固久的知识外，也要不断的学习新的技术，毕竟这行更新迭代太快，一不学习我们就得落后，更严重的就是失去饭碗。如果坚定走这条路，请一定要不断为自己充电，方能始终！！ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在前端这个行业不得不要求你不断地学习、成长，想想现在与五年前相比，都发生了多么翻天覆地的变化。引用一句之前我看到的话“一时间出现这么多新东西，让我有些恐慌”，一面是成长的压力，另一面是各种的选择困难。还有一点也挺残酷的，这个行业不是谁资历越老就越牛逼的，说到根本还是比拼的内功，还有的是比别人更加的努力学习，这又让我想起了另一句话“很多人所谓的多年经验，无非是一年学来的经验在多年里面不断地重复着”，这真的挺可怕的。</p>\n<a id=\"more\"></a>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 自身的成长是个长期而且持续的过程，要有所取舍。前端的基础知识、各种框架的设计理念等可以多去了解一下。关于新技术，学习并且最好能落地到应用场景中去，同时不要盲目追求新技术，那会使你限入一个无底的黑洞。特别是这些年，越发地觉得要回归本质，我们现在用的大多数技是为了解决我们“谋生”的问题，而将来还是要更多地去关注一些偏向于底层的东西，就比如js的框架不管怎样日新月异，现在react、Vue等大行其道各种新的框架百花奇放，但js本身却在稳定地慢慢完善中，相比很多年前，你能看到它已经好了不知道多少，但这一切却不会让人有一种不知所措的失控感。前几周在做项目的时候，看到一个开发哥们捧着一本计算机原理的书在温习，我觉得挺好的，与其面对现在层出不穷的新语言新框架，不如退而温习一下这些失落已久的东西。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外，可以挖掘一下业务中还有哪些值得一做的，往往不直接产生价值，但具备共享特点并且需要长期投入的事情会少有人做，大家都喜欢做短平快的事情，能为年底晋升加薪争取亮点。尝试去主导这么一两件事，做你认为有价值的事，所以你会特别专注其中，你得去思考很多，去找寻一切可以帮助你的力量去推动这个事情的前进，这与平时别人交给你的任务不同，以前是别人都安排好了，你只不过是个“资源”，负责执行，而现在你是一个规划者、决策者和执行者，你即面对痛苦，又收获快乐，而以往的需求、项目，你可能做着做着就麻木了。技术人员在初入行业时候，是来什么做什么，而资深的技术人员在多年的折腾和磨练以后，具备了更为完善的思考能力，能够不仅仅只是交给什么做什么，并且是能发掘更有价值的事情去做，想想这样子的话，你带着小D们去做事，才能让他们看到未来和希望，用你的思维去影响他们，他们也才会有成长和收获，不然他们同样会问一个类似一样的问题，然后从根本就没有解决这个问题。</p>\n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 还有就是业余时候，可以自己每年做一个小项目（比如app，一些新框架的项目），你能体会不同技术乐趣，也会因此意识到自己还需要再学点什么。其实现在的前端，要学的东西太多了，正如前面提到的，会让人陷入选择的恐慌中。在自己有时间的时候除了巩固久的知识外，也要不断的学习新的技术，毕竟这行更新迭代太快，一不学习我们就得落后，更严重的就是失去饭碗。如果坚定走这条路，请一定要不断为自己充电，方能始终！！</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在前端这个行业不得不要求你不断地学习、成长，想想现在与五年前相比，都发生了多么翻天覆地的变化。引用一句之前我看到的话“一时间出现这么多新东西，让我有些恐慌”，一面是成长的压力，另一面是各种的选择困难。还有一点也挺残酷的，这个行业不是谁资历越老就越牛逼的，说到根本还是比拼的内功，还有的是比别人更加的努力学习，这又让我想起了另一句话“很多人所谓的多年经验，无非是一年学来的经验在多年里面不断地重复着”，这真的挺可怕的。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.pengmengshan.cn/blog/tags/随笔/"},{"name":"心得","slug":"心得","permalink":"http://www.pengmengshan.cn/blog/tags/心得/"}]},{"title":"JavaScript 设计模式 ② 巧用'工厂模式'和'创建者'模式","date":"2017-04-28T01:28:24.000Z","path":"2017/04/28/it-20170428js/","text":"我为什么把他们两个放在一起讲？我觉得这两个设计模式有相似之处，有时候会一个设计模式不能满足你的需求而采用另一种设计模式。基于这点考虑，而且为了大家更好地理解，我放到了一起，加深大家的印象，活学活用。 [这里我为了能更好的体现下设计模式与JS本体语言的结合，我用了一点继承关系.有的同学都不知道JS能继承，就算大家不懂继承也希望大家能看下去，弄懂它！] 工厂模式 创建对象跟对不同需求进行不同的实例化 在我们Team协作开发过程当中，不同于我们写个人项目，对全局变量的限制很大，我们要尽量少的使用全局变量，对于一类对象在不同需求上的不同使用，甚至将一些有些类似的方法抽象化，可以用工厂模式来负责创建这些对象，调用者可以使用一部分资源也可以在基础上私人订制一套资源。 就拿昨天入群的小伙伴举个栗子：他设计一个网页播放器有四个按钮： 我们不讨论他的实现方式，我们按照工厂模式来简单创建一个吧！ 12345678910111213141516171819202122232425262728293031323334353637function wangyiMusicAction(action)&#123; var o = new Object; o.vender = '网易云音乐'; o.playingMusic = 'see you again' switch (action)&#123; case 'last': o.information = &#123;currentMusic:'Ich will',status:'200|404',message:'上一曲'&#125; break case 'next': o.information = &#123;currentMusic:'一人我编程累',status:'200|404',message:'下一曲'&#125; break case 'play': o.information = &#123;currentMusic:'see you again',status:'200|500',message:'播放'&#125; break case 'mute': o.information = &#123;currentMusic:'see you again',status:'200|500',message:'静音'&#125; break &#125; return o;&#125;var music = wangyiMusicAction('next')console.log('音乐提供商 : '+music.vender);console.log('正在播放 : '+music.playingMusic);console.log('执行动作 : ' +music.information.message);console.log('接口状态 : ' +music.information.status);console.log('执行动作后歌曲 : ' +music.information.currentMusic);----------执行结果--------音乐提供商 : 网易云音乐正在播放 : see you again执行动作 : 下一曲接口状态 : 200|404执行动作后歌曲 : 一人我编程累 这其实使我们经常使用的，不过这是面向过程的，不太符合我们的设计模式。我们用上篇学到的模式：对象 我们可以修改一下： 1234567891011121314151617181920212223242526272829303132333435363738394041var WangyiMusicAction = function(action)&#123; this.vender = '网易云音乐'; this.playingMusic = 'see you again'&#125;WangyiMusicAction.prototype = &#123; last : function() &#123; this.information = &#123;currentMusic:'Ich will',status:'200|404',message:'上一曲'&#125; &#125;, next : function() &#123; this.information = &#123;currentMusic:'一人我编程累',status:'200|404',message:'下一曲'&#125; &#125;, play : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'播放'&#125; &#125;, mute : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'静音'&#125; &#125;&#125;var music = new WangyiMusicAction()music.next(); //执行下一曲动作console.log('音乐提供商 : '+music.vender);console.log('正在播放 : '+music.playingMusic);console.log('执行动作 : ' +music.information.message);console.log('接口状态 : ' +music.information.status);console.log('执行动作后歌曲 : ' +music.information.currentMusic);音乐提供商 : 网易云音乐正在播放 : see you again执行动作 : 下一曲接口状态 : 200|400----------执行结果--------执行动作后歌曲 : 一人我编程累 这样就算是面向对象的了，虽然达到目的，但是上面所说的，但是这算是Music的网易云音乐实现版本、总不能再来一个QQMusic、XiaMiMusic吧？我们建立一个Factory工厂来管理所有的音乐： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182var WangyiMusicAction = function(action)&#123; this.vender = '网易云音乐'; this.playingMusic = 'see you again'&#125;//为网易音乐提供共有方法WangyiMusicAction.prototype = &#123; last : function() &#123; this.information = &#123;currentMusic:'Ich will',status:'200|404',message:'上一曲'&#125; &#125;, next : function() &#123; this.information = &#123;currentMusic:'一人我编程累',status:'200|404',message:'下一曲'&#125; &#125;, play : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'播放'&#125; &#125;, mute : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'静音'&#125; &#125;&#125;var QQMusicAction = function(action)&#123; this.vender = 'QQ音乐'; this.playingMusic = '其实我不low'&#125;//为QQ音乐提供共有方法QQMusicAction.prototype = &#123; last : function() &#123; this.information = &#123;currentMusic:'Ich will',status:'200|404',message:'上一曲'&#125; &#125;, next : function() &#123; this.information = &#123;currentMusic:'网易才low',status:'200|404',message:'下一曲'&#125; &#125;, play : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'播放'&#125; &#125;, mute : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'静音'&#125; &#125;&#125;//音乐工厂var MusicFactory = function(type)&#123; switch (type)&#123; case 'qq': return new QQMusicAction(); case 'wangyi': return new WangyiMusicAction() &#125;&#125;var music = new MusicFactory('qq')music.next(); //执行下一曲动作console.log('音乐提供商 : '+music.vender);console.log('正在播放 : '+music.playingMusic);console.log('执行动作 : ' +music.information.message);console.log('接口状态 : ' +music.information.status);console.log('执行动作后歌曲 : ' +music.information.currentMusic);----------执行结果--------音乐提供商 : QQ音乐正在播放 : 其实我不low执行动作 : 下一曲接口状态 : 200|404执行动作后歌曲 : 网易才low 这样调用者需要用音乐接口，只需要记住MusicFactory就可以了，MusicFactory就像一个大工厂，对于music可以返回他要的一切。 好，我们回过头来看一下： 第一种方法:是创建一个新的对象 o 对他来增强 属性 的功能来实现的.第二种方法:是实例化对象来创建的。第二种方法:如果他们继承同一个父类 BaseMusic 那么他们父类的原型方法是可以和它们公用的!第一种方法:我们内部 new 了一个新的个体，就不能与父类共用了. 具体哪种还是看你需求的，不过我更倾向第二种，因为他扩展性高，需求多的时候我们甚至可以将通用的抽离出来放到父类BaseMusic中。 在下面的继承中我运用了类式继承 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//基类（父类）music方法var BaseMusic = function()&#123; this.playingMusic = 'see you again'&#125;//实现通用方法BaseMusic.prototype = &#123; last : function() &#123; this.information = &#123;status:'200|404',message:'上一曲'&#125; &#125;, next : function() &#123; this.information = &#123;currentMusic:'一人我编程累',status:'200|404',message:'下一曲'&#125; &#125;, play : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'播放'&#125; &#125;, mute : function() &#123; this.information = &#123;currentMusic:'see you again',status:'200|500',message:'静音'&#125; &#125;&#125;//网易云的不同于父类的构造方法var WangyiMusicAction = function(action)&#123; this.vender = '网易云音乐';&#125;//这里通过prototype实现类继承WangyiMusicAction.prototype = new BaseMusic();//这些动作我都放在基类了，达到代码复用的目的//QQvar QQMusicAction = function(action)&#123; this.vender = 'QQ音乐'; this.playingMusic = '其实我不low'&#125;QQMusicAction.prototype = new BaseMusic() //这些动作我都放在基类了，达到代码复用的目的//音乐工厂var MusicFactory = function(type)&#123; switch (type)&#123; case 'qq': return new QQMusicAction(); case 'wangyi': return new WangyiMusicAction() &#125;&#125;var music = new MusicFactory('wangyi')music.next(); //执行下一曲动作console.log('音乐提供商 : '+music.vender);console.log('正在播放 : '+music.playingMusic);console.log('执行动作 : ' +music.information.message);console.log('接口状态 : ' +music.information.status);console.log('执行动作后歌曲 : ' +music.information.currentMusic);----------执行结果--------音乐提供商 : 网易云音乐正在播放 : see you again执行动作 : 下一曲接口状态 : 200|404执行动作后歌曲 : 一人我编程累 这样看起来是不是更好、更简洁呢？ 创建者模式工厂模式职责：我不管你想干啥，我只返回给你一个你想要的对象创建者模式职责：主要针对复杂业务的解耦，算是工厂的一种拆解、拼接。我可以将你的需求分解多个对象创建，更关心的是创建对象的过程。不复杂不能突显出他的魅力,举个稍微复杂栗子： 我们公司是卖车的，用户下单要买车，这个车呢： 品牌：迈巴赫、林肯、宾利、特斯拉[如果不选品牌，默认特斯拉]颜色：赤橙黄绿青蓝紫…[如果不选颜色，默认黄色]动力：燃油、电力、混合动力[如果不选动力，默认电力]购买人的一些备注信息[购买人可能会修改备注需要提供方法]针对购买人选择的车型返回对车型的简单描述[描述可以修改]最终根据用户选择来生成一个订单：想下这用工厂模式是不是要写很多的if else来返回这么一个Car的对象呢？ 我们先将 车 购买人的动作 反馈 分解为三个对象再在最后进行拼接 ： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//创建一个汽车var Car = function(param)&#123; this.color = param &amp;&amp; param.color || 'yellow'; this.brand = param &amp;&amp; param.brand || 'Tesla'; this.power = param &amp;&amp; param.power || 'electric';&#125;//提供原型方法Car.prototype = &#123; getColor : function () &#123; return this.color; &#125;, getBrand : function () &#123; return this.brand; &#125;, getPower : function () &#123; return this.power; &#125;&#125;//创建一个反馈var FeedBack = function(brand)&#123; var that = this; (function(brand,that)&#123; switch (brand)&#123; case 'Tesla': // that.brand = brand; that.information = '特斯拉是好车' break case 'Rolls' : that.information = '劳斯来时是好车' &#125; &#125;)(brand,that)&#125;FeedBack.prototype.changeBrand = function (information) &#123; this.information = information;&#125;//创建一个顾客var Client = function(name,message)&#123; this.name = name; this.message = message || '无留言';&#125;//顾客修改备注Client.prototype.changeMessage = function(message)&#123; this.message = message;&#125;//然后重点在这里！我们在这里将我们分解的拼接起来。var Order = function(name)&#123; var object = new Car(); object.client = new Client(name); object.feedBack = new FeedBack(object.brand); return object;&#125;var orderCar = new Order('Vendar-MH');console.log('The' + orderCar.client.name + '先生、下单一辆' + orderCar.color + '的' + orderCar.brand +' 留言内容 : ' +orderCar.client.message );orderCar.client.changeMessage('请马上电话联系我')console.log('The' + orderCar.client.name + '先生、下单一辆' + orderCar.color + '的' + orderCar.brand +' 留言内容 : ' +orderCar.client.message );----------执行结果--------TheVendar-MH先生、下单一辆yellow的Tesla 留言内容 : 无留言TheVendar-MH先生、下单一辆yellow的Tesla 留言内容 : 请马上电话联系我 好了,就算是关于这个订单的更加复杂的需求，或者修改需求，不管我们多少各功能在用，我们只要微微一笑，修改下prototype等实现就好了0.0 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>我为什么把他们两个放在一起讲？我觉得这两个设计模式有相似之处，有时候会一个设计模式不能满足你的需求而采用另一种设计模式。基于这点考虑，而且为了大家更好地理解，我放到了一起，加深大家的印象，活学活用。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>[这里我为了能更好的体现下设计模式与JS本体语言的结合，我用了一点继承关系.<br>有的同学都不知道JS能继承，就算大家不懂继承也希望大家能看下去，弄懂它！]</p>\n</blockquote>\n<h3 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h3><ul>\n<li>创建对象跟对不同需求进行不同的实例化</li>\n</ul>\n<p>在我们Team协作开发过程当中，不同于我们写个人项目，对全局变量的限制很大，我们要尽量少的使用全局变量，对于一类对象在不同需求上的不同使用，甚至将一些有些类似的方法抽象化，可以用工厂模式来负责创建这些对象，调用者可以使用一部分资源也可以在基础上私人订制一套资源。</p>\n<p>就拿昨天入群的小伙伴举个栗子：他设计一个网页播放器有四个按钮：</p>\n<p>我们不讨论他的实现方式，我们按照工厂模式来简单创建一个吧！</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wangyiMusicAction</span>(<span class=\"params\">action</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>;</div><div class=\"line\">    o.vender = <span class=\"string\">'网易云音乐'</span>;</div><div class=\"line\">    o.playingMusic = <span class=\"string\">'see you again'</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (action)&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'last'</span>:</div><div class=\"line\">            o.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'Ich will'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'上一曲'</span>&#125;</div><div class=\"line\">            <span class=\"keyword\">break</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'next'</span>:</div><div class=\"line\">            o.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'一人我编程累'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'下一曲'</span>&#125;</div><div class=\"line\">            <span class=\"keyword\">break</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'play'</span>:</div><div class=\"line\">            o.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'播放'</span>&#125;</div><div class=\"line\">            <span class=\"keyword\">break</span></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'mute'</span>:</div><div class=\"line\">            o.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'静音'</span>&#125;</div><div class=\"line\">            <span class=\"keyword\">break</span></div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> o;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> music = wangyiMusicAction(<span class=\"string\">'next'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'音乐提供商 : '</span>+music.vender);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'正在播放 : '</span>+music.playingMusic);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作 : '</span> +music.information.message);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'接口状态 : '</span> +music.information.status);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作后歌曲 : '</span> +music.information.currentMusic);</div><div class=\"line\"></div><div class=\"line\">----------执行结果--------</div><div class=\"line\"></div><div class=\"line\">音乐提供商 : 网易云音乐</div><div class=\"line\">正在播放 : see you again</div><div class=\"line\">执行动作 : 下一曲</div><div class=\"line\">接口状态 : <span class=\"number\">200</span>|<span class=\"number\">404</span></div><div class=\"line\">执行动作后歌曲 : 一人我编程累</div></pre></td></tr></table></figure>\n<p>这其实使我们经常使用的，不过这是面向过程的，不太符合我们的设计模式。我们用上篇学到的模式：对象</p>\n<p>我们可以修改一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> WangyiMusicAction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.vender = <span class=\"string\">'网易云音乐'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.playingMusic = <span class=\"string\">'see you again'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">WangyiMusicAction.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">last</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'Ich will'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'上一曲'</span>&#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">next</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'一人我编程累'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'下一曲'</span>&#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">play</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'播放'</span>&#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">mute</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'静音'</span>&#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> music = <span class=\"keyword\">new</span> WangyiMusicAction()</div><div class=\"line\">music.next(); <span class=\"comment\">//执行下一曲动作</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'音乐提供商 : '</span>+music.vender);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'正在播放 : '</span>+music.playingMusic);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作 : '</span> +music.information.message);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'接口状态 : '</span> +music.information.status);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作后歌曲 : '</span> +music.information.currentMusic);</div><div class=\"line\">音乐提供商 : 网易云音乐</div><div class=\"line\">正在播放 : see you again</div><div class=\"line\">执行动作 : 下一曲</div><div class=\"line\">接口状态 : <span class=\"number\">200</span>|<span class=\"number\">400</span></div><div class=\"line\"></div><div class=\"line\">----------执行结果--------</div><div class=\"line\"></div><div class=\"line\">执行动作后歌曲 : 一人我编程累</div></pre></td></tr></table></figure>\n<p>这样就算是面向对象的了，虽然达到目的，但是上面所说的，但是这算是Music的网易云音乐实现版本、总不能再来一个QQMusic、XiaMiMusic吧？我们建立一个Factory工厂来管理所有的音乐：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> WangyiMusicAction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.vender = <span class=\"string\">'网易云音乐'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.playingMusic = <span class=\"string\">'see you again'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//为网易音乐提供共有方法</span></div><div class=\"line\">WangyiMusicAction.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">last</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'Ich will'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'上一曲'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">next</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'一人我编程累'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'下一曲'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">play</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'播放'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">mute</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'静音'</span>&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> QQMusicAction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.vender = <span class=\"string\">'QQ音乐'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.playingMusic = <span class=\"string\">'其实我不low'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//为QQ音乐提供共有方法</span></div><div class=\"line\">QQMusicAction.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">last</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'Ich will'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'上一曲'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">next</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'网易才low'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'下一曲'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">play</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'播放'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">mute</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'静音'</span>&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//音乐工厂</span></div><div class=\"line\"><span class=\"keyword\">var</span> MusicFactory = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (type)&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'qq'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> QQMusicAction();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'wangyi'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WangyiMusicAction()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> music = <span class=\"keyword\">new</span> MusicFactory(<span class=\"string\">'qq'</span>)</div><div class=\"line\">music.next(); <span class=\"comment\">//执行下一曲动作</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'音乐提供商 : '</span>+music.vender);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'正在播放 : '</span>+music.playingMusic);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作 : '</span> +music.information.message);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'接口状态 : '</span> +music.information.status);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作后歌曲 : '</span> +music.information.currentMusic);</div><div class=\"line\"></div><div class=\"line\">----------执行结果--------</div><div class=\"line\"></div><div class=\"line\">音乐提供商 : QQ音乐</div><div class=\"line\">正在播放 : 其实我不low</div><div class=\"line\">执行动作 : 下一曲</div><div class=\"line\">接口状态 : <span class=\"number\">200</span>|<span class=\"number\">404</span></div><div class=\"line\">执行动作后歌曲 : 网易才low</div></pre></td></tr></table></figure>\n<p>这样调用者需要用音乐接口，只需要记住MusicFactory就可以了，MusicFactory就像一个大工厂，对于music可以返回他要的一切。</p>\n<p>好，我们回过头来看一下：</p>\n<p>第一种方法:是创建一个新的对象 o 对他来增强 属性 的功能来实现的.<br>第二种方法:是实例化对象来创建的。<br>第二种方法:如果他们继承同一个父类 BaseMusic 那么他们父类的原型方法是可以和它们公用的!<br>第一种方法:我们内部 new 了一个新的个体，就不能与父类共用了.</p>\n<p>具体哪种还是看你需求的，不过我更倾向第二种，因为他扩展性高，需求多的时候我们甚至可以将通用的抽离出来放到父类BaseMusic中。</p>\n<p>在下面的继承中我运用了类式继承</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//基类（父类）music方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> BaseMusic = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.playingMusic = <span class=\"string\">'see you again'</span></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//实现通用方法</span></div><div class=\"line\">BaseMusic.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">last</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'上一曲'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">next</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'一人我编程累'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|404'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'下一曲'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">play</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'播放'</span>&#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\"></div><div class=\"line\">    <span class=\"attr\">mute</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.information = &#123;<span class=\"attr\">currentMusic</span>:<span class=\"string\">'see you again'</span>,<span class=\"attr\">status</span>:<span class=\"string\">'200|500'</span>,<span class=\"attr\">message</span>:<span class=\"string\">'静音'</span>&#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//网易云的不同于父类的构造方法</span></div><div class=\"line\"><span class=\"keyword\">var</span> WangyiMusicAction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.vender = <span class=\"string\">'网易云音乐'</span>;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//这里通过prototype实现类继承</span></div><div class=\"line\">WangyiMusicAction.prototype = <span class=\"keyword\">new</span> BaseMusic();<span class=\"comment\">//这些动作我都放在基类了，达到代码复用的目的</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//QQ</span></div><div class=\"line\"><span class=\"keyword\">var</span> QQMusicAction = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">action</span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">this</span>.vender = <span class=\"string\">'QQ音乐'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.playingMusic = <span class=\"string\">'其实我不low'</span></div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">QQMusicAction.prototype = <span class=\"keyword\">new</span> BaseMusic() <span class=\"comment\">//这些动作我都放在基类了，达到代码复用的目的</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//音乐工厂</span></div><div class=\"line\"><span class=\"keyword\">var</span> MusicFactory = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">type</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (type)&#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'qq'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> QQMusicAction();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">case</span> <span class=\"string\">'wangyi'</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> WangyiMusicAction()</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> music = <span class=\"keyword\">new</span> MusicFactory(<span class=\"string\">'wangyi'</span>)</div><div class=\"line\">music.next(); <span class=\"comment\">//执行下一曲动作</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'音乐提供商 : '</span>+music.vender);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'正在播放 : '</span>+music.playingMusic);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作 : '</span> +music.information.message);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'接口状态 : '</span> +music.information.status);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'执行动作后歌曲 : '</span> +music.information.currentMusic);</div><div class=\"line\"></div><div class=\"line\">----------执行结果--------</div><div class=\"line\"></div><div class=\"line\">音乐提供商 : 网易云音乐</div><div class=\"line\">正在播放 : see you again</div><div class=\"line\">执行动作 : 下一曲</div><div class=\"line\">接口状态 : <span class=\"number\">200</span>|<span class=\"number\">404</span></div><div class=\"line\">执行动作后歌曲 : 一人我编程累</div></pre></td></tr></table></figure>\n<p>这样看起来是不是更好、更简洁呢？</p>\n<h3 id=\"创建者模式\"><a href=\"#创建者模式\" class=\"headerlink\" title=\"创建者模式\"></a>创建者模式</h3><p>工厂模式职责：我不管你想干啥，我只返回给你一个你想要的对象<br>创建者模式职责：主要针对复杂业务的解耦，算是工厂的一种拆解、拼接。我可以将你的需求分解多个对象创建，更关心的是创建对象的过程。<br>不复杂不能突显出他的魅力,举个稍微复杂栗子：</p>\n<p>我们公司是卖车的，用户下单要买车，这个车呢：</p>\n<p>品牌：迈巴赫、林肯、宾利、特斯拉[如果不选品牌，默认特斯拉]<br>颜色：赤橙黄绿青蓝紫…[如果不选颜色，默认黄色]<br>动力：燃油、电力、混合动力[如果不选动力，默认电力]<br>购买人的一些备注信息[购买人可能会修改备注需要提供方法]<br>针对购买人选择的车型返回对车型的简单描述[描述可以修改]<br>最终根据用户选择来生成一个订单：<br>想下这用工厂模式是不是要写很多的if else来返回这么一个Car的对象呢？</p>\n<p>我们先将 车 购买人的动作 反馈 分解为三个对象再在最后进行拼接 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//创建一个汽车</span></div><div class=\"line\"><span class=\"keyword\">var</span> Car  = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">param</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.color = param &amp;&amp; param.color || <span class=\"string\">'yellow'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.brand = param &amp;&amp; param.brand || <span class=\"string\">'Tesla'</span>;</div><div class=\"line\">    <span class=\"keyword\">this</span>.power = param &amp;&amp; param.power || <span class=\"string\">'electric'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//提供原型方法</span></div><div class=\"line\">Car.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">getColor</span> : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.color;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">getBrand</span> : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.brand;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"attr\">getPower</span> : <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.power;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建一个反馈</span></div><div class=\"line\"><span class=\"keyword\">var</span> FeedBack = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">brand</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> that = <span class=\"keyword\">this</span>;</div><div class=\"line\">    (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">brand,that</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (brand)&#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'Tesla'</span>:</div><div class=\"line\">                <span class=\"comment\">// that.brand = brand;</span></div><div class=\"line\">                that.information = <span class=\"string\">'特斯拉是好车'</span></div><div class=\"line\">                <span class=\"keyword\">break</span></div><div class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'Rolls'</span> :</div><div class=\"line\">                that.information = <span class=\"string\">'劳斯来时是好车'</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;)(brand,that)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">FeedBack.prototype.changeBrand = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">information</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.information = information;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//创建一个顾客</span></div><div class=\"line\"><span class=\"keyword\">var</span> Client = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name,message</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    <span class=\"keyword\">this</span>.message = message || <span class=\"string\">'无留言'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//顾客修改备注</span></div><div class=\"line\">Client.prototype.changeMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">message</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.message = message;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//然后重点在这里！我们在这里将我们分解的拼接起来。</span></div><div class=\"line\"><span class=\"keyword\">var</span> Order = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> object = <span class=\"keyword\">new</span> Car();</div><div class=\"line\">    object.client  = <span class=\"keyword\">new</span> Client(name);</div><div class=\"line\">    object.feedBack = <span class=\"keyword\">new</span> FeedBack(object.brand);</div><div class=\"line\">    <span class=\"keyword\">return</span> object;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> orderCar = <span class=\"keyword\">new</span> Order(<span class=\"string\">'Vendar-MH'</span>);</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'The'</span> + orderCar.client.name + <span class=\"string\">'先生、下单一辆'</span> + orderCar.color + <span class=\"string\">'的'</span> + orderCar.brand +<span class=\"string\">' 留言内容 : '</span> +orderCar.client.message );</div><div class=\"line\">orderCar.client.changeMessage(<span class=\"string\">'请马上电话联系我'</span>)</div><div class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'The'</span> + orderCar.client.name + <span class=\"string\">'先生、下单一辆'</span> + orderCar.color + <span class=\"string\">'的'</span> + orderCar.brand +<span class=\"string\">' 留言内容 : '</span> +orderCar.client.message );</div><div class=\"line\"></div><div class=\"line\">----------执行结果--------</div><div class=\"line\"></div><div class=\"line\">TheVendar-MH先生、下单一辆yellow的Tesla 留言内容 : 无留言</div><div class=\"line\">TheVendar-MH先生、下单一辆yellow的Tesla 留言内容 : 请马上电话联系我</div></pre></td></tr></table></figure>\n<p>好了,就算是关于这个订单的更加复杂的需求，或者修改需求，不管我们多少各功能在用，我们只要微微一笑，修改下prototype等实现就好了0.0</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n","excerpt":"我为什么把他们两个放在一起讲？我觉得这两个设计模式有相似之处，有时候会一个设计模式不能满足你的需求而采用另一种设计模式。基于这点考虑，而且为了大家更好地理解，我放到了一起，加深大家的印象，活学活用。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.pengmengshan.cn/blog/tags/js/"}]},{"title":"vue-cli#2.0 webpack 配置分析","date":"2017-04-26T03:10:48.000Z","path":"2017/04/26/vue-cli/","text":"前言 作为 Vue 的使用者我们对于 vue-cli 都很熟悉，但是对它的 webpack 配置我们可能关注甚少，今天我们为大家带来 vue-cli#2.0 的 webpack 配置分析 vue-cli 的简介、安装我们不在这里赘述，对它还不熟悉的同学可以直接访问 vue-cli 查看 目录结构 12345678910111213141516171819202122232425.├── README.md├── build│ ├── build.js│ ├── check-versions.js│ ├── dev-client.js│ ├── dev-server.js│ ├── utils.js│ ├── webpack.base.conf.js│ ├── webpack.dev.conf.js│ └── webpack.prod.conf.js├── config│ ├── dev.env.js│ ├── index.js│ └── prod.env.js├── index.html├── package.json├── src│ ├── App.vue│ ├── assets│ │ └── logo.png│ ├── components│ │ └── Hello.vue│ └── main.js└── static 本篇文章的主要关注点在 build - 编译任务的代码 config - webpack 的配置文件 package.json - 项目的基本信息 入口 从 package.json 中我们可以看到 12345\"scripts\": &#123; \"dev\": \"node build/dev-server.js\", \"build\": \"node build/build.js\", \"lint\": \"eslint --ext .js,.vue src\"&#125; 当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js dev-server.js让我们先从 build/dev-server.js 入手 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384require('./check-versions')() // 检查 Node 和 npm 版本var config = require('../config') // 获取 config/index.js 的默认配置/*** 如果 Node 的环境无法判断当前是 dev / product 环境** 使用 config.dev.env.NODE_ENV 作为当前的环境*/if (!process.env.NODE_ENV) process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)var path = require('path') // 使用 NodeJS 自带的文件路径工具var express = require('express') // 使用 expressvar webpack = require('webpack') // 使用 webpackvar opn = require('opn') // 一个可以强制打开浏览器并跳转到指定 url 的插件var proxyMiddleware = require('http-proxy-middleware') // 使用 proxyTablevar webpackConfig = require('./webpack.dev.conf') // 使用 dev 环境的 webpack 配置/* 如果没有指定运行端口，使用 config.dev.port 作为运行端口 */var port = process.env.PORT || config.dev.port/* 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置 *//* 项目参考 https://github.com/chimurai/http-proxy-middleware */var proxyTable = config.dev.proxyTable/* 使用 express 启动一个服务 */var app = express()var compiler = webpack(webpackConfig) // 启动 webpack 进行编译/* 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中 */var devMiddleware = require('webpack-dev-middleware')(compiler, &#123; publicPath: webpackConfig.output.publicPath, stats: &#123; colors: true, chunks: false &#125;&#125;)/* 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload */var hotMiddleware = require('webpack-hot-middleware')(compiler)/* 当 html-webpack-plugin 模板更新的时候强制刷新页面 */compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(context, options))&#125;)// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址app.use(require('connect-history-api-fallback')())// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// 将 Hot-reload 挂在到 express 服务上并且输出相关的状态、错误app.use(hotMiddleware)// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 为静态资源提供响应服务app.use(staticPath, express.static('./static'))// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; var uri = 'http://localhost:' + port console.log('Listening at ' + uri + '\\n') // 如果不是测试环境，自动打开浏览器并跳到我们的开发地址 if (process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125;&#125;) webpack.dev.conf.js刚刚我们在 dev-server.js 中用到了 webpack.dev.conf.js 和 index.js，我们先来看一下 webpack.dev.conf.js 1234567891011121314151617181920212223242526272829303132333435363738394041var config = require('../config') // 同样的使用了 config/index.jsvar webpack = require('webpack') // 使用 webpackvar merge = require('webpack-merge') // 使用 webpack 配置合并插件var utils = require('./utils') // 使用一些小工具var baseWebpackConfig = require('./webpack.base.conf') // 加载 webpack.base.conf/* 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中 */var HtmlWebpackPlugin = require('html-webpack-plugin')// 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前Object.keys(baseWebpackConfig.entry).forEach(function (name) &#123; baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])&#125;)/* 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并 */module.exports = merge(baseWebpackConfig, &#123; module: &#123; // 使用 styleLoaders loaders: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;) &#125;, // 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解 devtool: '#eval-source-map', plugins: [ /* definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 */ new webpack.DefinePlugin(&#123; 'process.env': config.dev.env &#125;), // 参考项目 https://github.com/glenjamin/webpack-hot-middleware#installation--usage new webpack.optimize.OccurenceOrderPlugin(), /* HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件 */ new webpack.HotModuleReplacementPlugin(), /* 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错 */ new webpack.NoErrorsPlugin(), // 参考项目 https://github.com/ampedandwired/html-webpack-plugin /* 将 index.html 作为入口，注入 html 代码后生成 index.html文件 */ new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;) ]&#125;) webpack.base.conf.js我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js， 它看起来很重要的样子，所以我们只能在下一章来看看 config/index.js 了 （摊手） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103var path = require('path') // 使用 NodeJS 自带的文件路径插件var config = require('../config') // 引入 config/index.jsvar utils = require('./utils') // 引入一些小工具var projectRoot = path.resolve(__dirname, '../') // 拼接我们的工作区路径为一个绝对路径/* 将 NodeJS 环境作为我们的编译环境 */var env = process.env.NODE_ENV/* 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置 */var cssSourceMapDev = (env === 'development' &amp;&amp; config.dev.cssSourceMap)/* 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置 */var cssSourceMapProd = (env === 'production' &amp;&amp; config.build.productionSourceMap)/* 最终是否使用 cssSourceMap */var useCssSourceMap = cssSourceMapDev || cssSourceMapProdmodule.exports = &#123; entry: &#123; app: './src/main.js' // 编译文件入口 &#125;, output: &#123; path: config.build.assetsRoot, // 编译输出的静态资源根路径 publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath, // 正式发布环境下编译输出的上线路径的根路径 filename: '[name].js' // 编译输出的文件名 &#125;, resolve: &#123; // 自动补全的扩展名 extensions: ['', '.js', '.vue'], // 不进行自动补全或处理的文件或者文件夹 fallback: [path.join(__dirname, '../node_modules')], alias: &#123; // 默认路径代理，例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找 'vue$': 'vue/dist/vue.common.js', 'src': path.resolve(__dirname, '../src'), 'assets': path.resolve(__dirname, '../src/assets'), 'components': path.resolve(__dirname, '../src/components') &#125; &#125;, resolveLoader: &#123; fallback: [path.join(__dirname, '../node_modules')] &#125;, module: &#123; preLoaders: [ // 预处理的文件及使用的 loader &#123; test: /\\.vue$/, loader: 'eslint', include: projectRoot, exclude: /node_modules/ &#125;, &#123; test: /\\.js$/, loader: 'eslint', include: projectRoot, exclude: /node_modules/ &#125; ], loaders: [ // 需要处理的文件及使用的 loader &#123; test: /\\.vue$/, loader: 'vue' &#125;, &#123; test: /\\.js$/, loader: 'babel', include: projectRoot, exclude: /node_modules/ &#125;, &#123; test: /\\.json$/, loader: 'json' &#125;, &#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: 'url', query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)?$/, loader: 'url', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;, eslint: &#123; // eslint 代码检查配置工具 formatter: require('eslint-friendly-formatter') &#125;, vue: &#123; // .vue 文件配置 loader 及工具 (autoprefixer) loaders: utils.cssLoaders(&#123; sourceMap: useCssSourceMap &#125;), postcss: [ require('autoprefixer')(&#123; browsers: ['last 2 versions'] &#125;) ] &#125;&#125; config/index.js终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js index.js 中有 dev 和 production 两种环境的配置 1234567891011121314151617181920212223242526var path = require('path')module.exports = &#123; build: &#123; // production 环境 env: require('./prod.env'), // 使用 config/prod.env.js 中定义的编译环境 index: path.resolve(__dirname, '../dist/index.html'), // 编译输入的 index.html 文件 assetsRoot: path.resolve(__dirname, '../dist'), // 编译输出的静态资源路径 assetsSubDirectory: 'static', // 编译输出的二级目录 assetsPublicPath: '/', // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 productionSourceMap: true, // 是否开启 cssSourceMap // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin productionGzip: false, // 是否开启 gzip productionGzipExtensions: ['js', 'css'] // 需要使用 gzip 压缩的文件扩展名 &#125;, dev: &#123; // dev 环境 env: require('./dev.env'), // 使用 config/dev.env.js 中定义的编译环境 port: 8080, // 运行测试页面的端口 assetsSubDirectory: 'static', // 编译输出的二级目录 assetsPublicPath: '/', // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 proxyTable: &#123;&#125;, // 需要 proxyTable 代理的接口（可跨域） cssSourceMap: false // 是否开启 cssSourceMap(因为一些 bug 此选项默认关闭，详情可参考 https://github.com/webpack/css-loader#sourcemaps) &#125;&#125; 至此，我们的 npm run dev 命令就讲解完毕，下面让我们来看一看执行 npm run build 命令时发生了什么 ～ build.js123456789101112131415161718192021222324252627282930313233343536373839404142require('./check-versions')() // 检查 Node 和 npm 版本require('shelljs/global') // 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shellenv.NODE_ENV = 'production'var path = require('path') // 不再赘述var config = require('../config') // 加载 config.jsvar ora = require('ora') // 一个很好看的 loading 插件var webpack = require('webpack') // 加载 webpackvar webpackConfig = require('./webpack.prod.conf') // 加载 webpack.prod.confconsole.log( // 输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页 ' Tip:\\n' + ' Built files are meant to be served over an HTTP server.\\n' + ' Opening index.html over file:// won\\'t work.\\n')var spinner = ora('building for production...') // 使用 ora 打印出 loading + logspinner.start() // 开始 loading 动画/* 拼接编译输出文件路径 */var assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)/* 删除这个文件夹 （递归删除） */rm('-rf', assetsPath)/* 创建此文件夹 */mkdir('-p', assetsPath)/* 复制 static 文件夹到我们的编译输出目录 */cp('-R', 'static/*', assetsPath)// 开始 webpack 的编译webpack(webpackConfig, function (err, stats) &#123; // 编译成功的回调函数 spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\\n') &#125;) + '\\n')&#125;) webpack.prod.conf.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111require('path')var config = require('../config') // 加载 confi.index.jsvar utils = require('./utils') // 使用一些小工具var webpack = require('webpack') // 加载 webpackvar merge = require('webpack-merge') // 加载 webpack 配置合并工具var baseWebpackConfig = require('./webpack.base.conf') // 加载 webpack.base.conf.js/* 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开 *//* 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件 */var ExtractTextPlugin = require('extract-text-webpack-plugin')/* 一个可以插入 html 并且创建新的 .html 文件的插件 */var HtmlWebpackPlugin = require('html-webpack-plugin')var env = config.build.env/* 合并 webpack.base.conf.js */var webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; /* 使用的 loader */ loaders: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true &#125;) &#125;, /* 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章 */ devtool: config.build.productionSourceMap ? '#source-map' : false, output: &#123; /* 编译输出目录 */ path: config.build.assetsRoot, /* 编译输出文件名 */ filename: utils.assetsPath('js/[name].[chunkhash].js'), // 我们可以在 hash 后加 :6 决定使用几位 hash 值 // 没有指定输出名的文件输出的文件名 chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, vue: &#123; /* 编译 .vue 文件时使用的 loader */ loaders: utils.cssLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true &#125;) &#125;, plugins: [ /* 使用的插件 */ /* definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 */ new webpack.DefinePlugin(&#123; 'process.env': env &#125;), /* 压缩 js (同样可以压缩 css) */ new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125; &#125;), new webpack.optimize.OccurrenceOrderPlugin(), /* 将 css 文件分离出来 */ new ExtractTextPlugin(utils.assetsPath('css/[name].[contenthash].css')), /* 构建要输出的 index.html 文件， HtmlWebpackPlugin 可以生成一个 html 并且在其中插入你构建生成的资源 */ new HtmlWebpackPlugin(&#123; filename: config.build.index, // 生成的 html 文件名 template: 'index.html', // 使用的模板 inject: true, // 是否注入 html (有多重注入方式，可以选择注入的位置) minify: &#123; // 压缩的方式 removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true // 更多参数可查看 https://github.com/kangax/html-minifier#options-quick-reference &#125;, chunksSortMode: 'dependency' &#125;), // 此处增加 @OYsun 童鞋补充 // CommonsChunkPlugin用于生成在入口点之间共享的公共模块（比如jquery，vue）的块并将它们分成独立的包。而为什么要new两次这个插件，这是一个很经典的bug的解决方案，在webpack的一个issues有过深入的讨论webpack/webpack#1315 .----为了将项目中的第三方依赖代码抽离出来，官方文档上推荐使用这个插件，当我们在项目里实际使用之后，发现一旦更改了 app.js 内的代码，vendor.js 的 hash 也会改变，那么下次上线时，用户仍然需要重新下载 vendor.js 与 app.js new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module, count) &#123; // 依赖的 node_modules 文件会被提取到 vendor 中 return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor'] &#125;) ]&#125;)/* 开启 gzip 的情况下使用下方的配置 */if (config.build.productionGzip) &#123; /* 加载 compression-webpack-plugin 插件 */ var CompressionWebpackPlugin = require('compression-webpack-plugin') /* 向webpackconfig.plugins中加入下方的插件 */ webpackConfig.plugins.push( /* 使用 compression-webpack-plugin 插件进行压缩 */ new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;module.exports = webpackConfig 总结至此 ～ 我们的 vue-cli#2.0 webpack 配置分析文件就讲解完毕 ～ 对于一些插件的详细 options 我们没有进行讲解，感兴趣的同学可以去 npm 商店搜索对应插件查看 options ~ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p><strong>前言</strong></p>\n<blockquote>\n<p>作为 Vue 的使用者我们对于 vue-cli 都很熟悉，但是对它的 webpack 配置我们可能关注甚少，今天我们为大家带来 vue-cli#2.0 的 webpack 配置分析</p>\n</blockquote>\n<p>vue-cli 的简介、安装我们不在这里赘述，对它还不熟悉的同学可以直接访问 vue-cli 查看</p>\n<p>目录结构<br><a id=\"more\"></a></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">.</div><div class=\"line\">├── README.md</div><div class=\"line\">├── build</div><div class=\"line\">│   ├── build.js</div><div class=\"line\">│   ├── check-versions.js</div><div class=\"line\">│   ├── dev-client.js</div><div class=\"line\">│   ├── dev-server.js</div><div class=\"line\">│   ├── utils.js</div><div class=\"line\">│   ├── webpack.base.conf.js</div><div class=\"line\">│   ├── webpack.dev.conf.js</div><div class=\"line\">│   └── webpack.prod.conf.js</div><div class=\"line\">├── config</div><div class=\"line\">│   ├── dev.env.js</div><div class=\"line\">│   ├── index.js</div><div class=\"line\">│   └── prod.env.js</div><div class=\"line\">├── index.html</div><div class=\"line\">├── package.json</div><div class=\"line\">├── src</div><div class=\"line\">│   ├── App.vue</div><div class=\"line\">│   ├── assets</div><div class=\"line\">│   │   └── logo.png</div><div class=\"line\">│   ├── components</div><div class=\"line\">│   │   └── Hello.vue</div><div class=\"line\">│   └── main.js</div><div class=\"line\">└── static</div></pre></td></tr></table></figure>\n<p>本篇文章的主要关注点在</p>\n<p>build - 编译任务的代码</p>\n<p>config - webpack 的配置文件</p>\n<p>package.json - 项目的基本信息</p>\n<p>入口</p>\n<p>从 package.json 中我们可以看到</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">\"scripts\": &#123;</div><div class=\"line\">    \"dev\": \"node build/dev-server.js\",</div><div class=\"line\">    \"build\": \"node build/build.js\",</div><div class=\"line\">    \"lint\": \"eslint --ext .js,.vue src\"</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js</p>\n<h3 id=\"dev-server-js\"><a href=\"#dev-server-js\" class=\"headerlink\" title=\"dev-server.js\"></a><strong>dev-server.js</strong></h3><p>让我们先从 build/dev-server.js 入手</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./check-versions'</span>)() <span class=\"comment\">// 检查 Node 和 npm 版本</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>) <span class=\"comment\">// 获取 config/index.js 的默认配置</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\">** 如果 Node 的环境无法判断当前是 dev / product 环境</div><div class=\"line\">** 使用 config.dev.env.NODE_ENV 作为当前的环境</div><div class=\"line\">*/</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!process.env.NODE_ENV) process.env.NODE_ENV = <span class=\"built_in\">JSON</span>.parse(config.dev.env.NODE_ENV)</div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>) <span class=\"comment\">// 使用 NodeJS 自带的文件路径工具</span></div><div class=\"line\"><span class=\"keyword\">var</span> express = <span class=\"built_in\">require</span>(<span class=\"string\">'express'</span>) <span class=\"comment\">// 使用 express</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>) <span class=\"comment\">// 使用 webpack</span></div><div class=\"line\"><span class=\"keyword\">var</span> opn = <span class=\"built_in\">require</span>(<span class=\"string\">'opn'</span>) <span class=\"comment\">// 一个可以强制打开浏览器并跳转到指定 url 的插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> proxyMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'http-proxy-middleware'</span>) <span class=\"comment\">// 使用 proxyTable</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.dev.conf'</span>) <span class=\"comment\">// 使用 dev 环境的 webpack 配置</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 如果没有指定运行端口，使用 config.dev.port 作为运行端口 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> port = process.env.PORT || config.dev.port</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 使用 config.dev.proxyTable 的配置作为 proxyTable 的代理配置 */</span></div><div class=\"line\"><span class=\"comment\">/* 项目参考 https://github.com/chimurai/http-proxy-middleware */</span></div><div class=\"line\"><span class=\"keyword\">var</span> proxyTable = config.dev.proxyTable</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 使用 express 启动一个服务 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> app = express()</div><div class=\"line\"><span class=\"keyword\">var</span> compiler = webpack(webpackConfig) <span class=\"comment\">// 启动 webpack 进行编译</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 启动 webpack-dev-middleware，将 编译后的文件暂存到内存中 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> devMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-dev-middleware'</span>)(compiler, &#123;</div><div class=\"line\">  <span class=\"attr\">publicPath</span>: webpackConfig.output.publicPath,</div><div class=\"line\">  <span class=\"attr\">stats</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">colors</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">chunks</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 启动 webpack-hot-middleware，也就是我们常说的 Hot-reload */</span></div><div class=\"line\"><span class=\"keyword\">var</span> hotMiddleware = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-hot-middleware'</span>)(compiler)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 当 html-webpack-plugin 模板更新的时候强制刷新页面 */</span></div><div class=\"line\">compiler.plugin(<span class=\"string\">'compilation'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">compilation</span>) </span>&#123;</div><div class=\"line\">  compilation.plugin(<span class=\"string\">'html-webpack-plugin-after-emit'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, cb</span>) </span>&#123;</div><div class=\"line\">    hotMiddleware.publish(&#123; <span class=\"attr\">action</span>: <span class=\"string\">'reload'</span> &#125;)</div><div class=\"line\">    cb()</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将 proxyTable 中的请求配置挂在到启动的 express 服务上</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(proxyTable).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> options = proxyTable[context]</div><div class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> options === <span class=\"string\">'string'</span>) &#123;</div><div class=\"line\">    options = &#123; <span class=\"attr\">target</span>: options &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  app.use(proxyMiddleware(context, options))</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 使用 connect-history-api-fallback 匹配资源，如果不匹配就可以重定向到指定地址</span></div><div class=\"line\">app.use(<span class=\"built_in\">require</span>(<span class=\"string\">'connect-history-api-fallback'</span>)())</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上</span></div><div class=\"line\">app.use(devMiddleware)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将 Hot-reload 挂在到 express 服务上并且输出相关的状态、错误</span></div><div class=\"line\">app.use(hotMiddleware)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 拼接 static 文件夹的静态资源路径</span></div><div class=\"line\"><span class=\"keyword\">var</span> staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)</div><div class=\"line\"><span class=\"comment\">// 为静态资源提供响应服务</span></div><div class=\"line\">app.use(staticPath, express.static(<span class=\"string\">'./static'</span>))</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 让我们这个 express 服务监听 port 的请求，并且将此服务作为 dev-server.js 的接口暴露</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = app.listen(port, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(err)</div><div class=\"line\">    <span class=\"keyword\">return</span></div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">var</span> uri = <span class=\"string\">'http://localhost:'</span> + port</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Listening at '</span> + uri + <span class=\"string\">'\\n'</span>)</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 如果不是测试环境，自动打开浏览器并跳到我们的开发地址</span></div><div class=\"line\">  <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'testing'</span>) &#123;</div><div class=\"line\">    opn(uri)</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"webpack-dev-conf-js\"><a href=\"#webpack-dev-conf-js\" class=\"headerlink\" title=\"webpack.dev.conf.js\"></a><strong>webpack.dev.conf.js</strong></h3><p>刚刚我们在 dev-server.js 中用到了 webpack.dev.conf.js 和 index.js，我们先来看一下 webpack.dev.conf.js</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>) <span class=\"comment\">// 同样的使用了 config/index.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>) <span class=\"comment\">// 使用 webpack</span></div><div class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>) <span class=\"comment\">// 使用 webpack 配置合并插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">'./utils'</span>) <span class=\"comment\">// 使用一些小工具</span></div><div class=\"line\"><span class=\"keyword\">var</span> baseWebpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base.conf'</span>) <span class=\"comment\">// 加载 webpack.base.conf</span></div><div class=\"line\"><span class=\"comment\">/* 使用 html-webpack-plugin 插件，这个插件可以帮我们自动生成 html 并且注入到 .html 文件中 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 将 Hol-reload 相对路径添加到 webpack.base.conf 的 对应 entry 前</span></div><div class=\"line\"><span class=\"built_in\">Object</span>.keys(baseWebpackConfig.entry).forEach(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">name</span>) </span>&#123;</div><div class=\"line\">  baseWebpackConfig.entry[name] = [<span class=\"string\">'./build/dev-client'</span>].concat(baseWebpackConfig.entry[name])</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 将我们 webpack.dev.conf.js 的配置和 webpack.base.conf.js 的配置合并 */</span></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = merge(baseWebpackConfig, &#123;</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 使用 styleLoaders</span></div><div class=\"line\">    loaders: utils.styleLoaders(&#123; <span class=\"attr\">sourceMap</span>: config.dev.cssSourceMap &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">// 使用 #eval-source-map 模式作为开发工具，此配置可参考 DDFE 往期文章详细了解</span></div><div class=\"line\">  devtool: <span class=\"string\">'#eval-source-map'</span>,</div><div class=\"line\">  <span class=\"attr\">plugins</span>: [</div><div class=\"line\">    <span class=\"comment\">/* definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</div><div class=\"line\">      <span class=\"string\">'process.env'</span>: config.dev.env</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"comment\">// 参考项目 https://github.com/glenjamin/webpack-hot-middleware#installation--usage</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.OccurenceOrderPlugin(),</div><div class=\"line\">    <span class=\"comment\">/* HotModule 插件在页面进行变更的时候只会重回对应的页面模块，不会重绘整个 html 文件 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.HotModuleReplacementPlugin(),</div><div class=\"line\">    <span class=\"comment\">/* 使用了 NoErrorsPlugin 后页面中的报错不会阻塞，但是会在编译结束后报错 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.NoErrorsPlugin(),</div><div class=\"line\">    <span class=\"comment\">// 参考项目 https://github.com/ampedandwired/html-webpack-plugin</span></div><div class=\"line\">    <span class=\"comment\">/* 将 index.html 作为入口，注入 html 代码后生成 index.html文件 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">filename</span>: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">      <span class=\"attr\">template</span>: <span class=\"string\">'index.html'</span>,</div><div class=\"line\">      <span class=\"attr\">inject</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"webpack-base-conf-js\"><a href=\"#webpack-base-conf-js\" class=\"headerlink\" title=\"webpack.base.conf.js\"></a><strong>webpack.base.conf.js</strong></h3><p>我们看到在 webpack.dev.conf.js 中又引入了 webpack.base.conf.js， 它看起来很重要的样子，所以我们只能在下一章来看看 config/index.js 了 （摊手）</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>) <span class=\"comment\">// 使用 NodeJS 自带的文件路径插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>) <span class=\"comment\">// 引入 config/index.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">'./utils'</span>) <span class=\"comment\">// 引入一些小工具</span></div><div class=\"line\"><span class=\"keyword\">var</span> projectRoot = path.resolve(__dirname, <span class=\"string\">'../'</span>) <span class=\"comment\">// 拼接我们的工作区路径为一个绝对路径</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 将 NodeJS 环境作为我们的编译环境 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> env = process.env.NODE_ENV</div><div class=\"line\"><span class=\"comment\">/* 是否在 dev 环境下开启 cssSourceMap ，在 config/index.js 中可配置 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> cssSourceMapDev = (env === <span class=\"string\">'development'</span> &amp;&amp; config.dev.cssSourceMap)</div><div class=\"line\"><span class=\"comment\">/* 是否在 production 环境下开启 cssSourceMap ，在 config/index.js 中可配置 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> cssSourceMapProd = (env === <span class=\"string\">'production'</span> &amp;&amp; config.build.productionSourceMap)</div><div class=\"line\"><span class=\"comment\">/* 最终是否使用 cssSourceMap */</span></div><div class=\"line\"><span class=\"keyword\">var</span> useCssSourceMap = cssSourceMapDev || cssSourceMapProd</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">entry</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">app</span>: <span class=\"string\">'./src/main.js'</span> <span class=\"comment\">// 编译文件入口</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">path</span>: config.build.assetsRoot, <span class=\"comment\">// 编译输出的静态资源根路径</span></div><div class=\"line\">    publicPath: process.env.NODE_ENV === <span class=\"string\">'production'</span> ? config.build.assetsPublicPath : config.dev.assetsPublicPath, <span class=\"comment\">// 正式发布环境下编译输出的上线路径的根路径</span></div><div class=\"line\">    filename: <span class=\"string\">'[name].js'</span> <span class=\"comment\">// 编译输出的文件名</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">resolve</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// 自动补全的扩展名</span></div><div class=\"line\">    extensions: [<span class=\"string\">''</span>, <span class=\"string\">'.js'</span>, <span class=\"string\">'.vue'</span>],</div><div class=\"line\">    <span class=\"comment\">// 不进行自动补全或处理的文件或者文件夹</span></div><div class=\"line\">    fallback: [path.join(__dirname, <span class=\"string\">'../node_modules'</span>)],</div><div class=\"line\">    <span class=\"attr\">alias</span>: &#123;</div><div class=\"line\">\t  <span class=\"comment\">// 默认路径代理，例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找</span></div><div class=\"line\">      <span class=\"string\">'vue$'</span>: <span class=\"string\">'vue/dist/vue.common.js'</span>,</div><div class=\"line\">      <span class=\"string\">'src'</span>: path.resolve(__dirname, <span class=\"string\">'../src'</span>),</div><div class=\"line\">      <span class=\"string\">'assets'</span>: path.resolve(__dirname, <span class=\"string\">'../src/assets'</span>),</div><div class=\"line\">      <span class=\"string\">'components'</span>: path.resolve(__dirname, <span class=\"string\">'../src/components'</span>)</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">resolveLoader</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">fallback</span>: [path.join(__dirname, <span class=\"string\">'../node_modules'</span>)]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"attr\">preLoaders</span>: [</div><div class=\"line\">      <span class=\"comment\">// 预处理的文件及使用的 loader</span></div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.vue$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'eslint'</span>,</div><div class=\"line\">        <span class=\"attr\">include</span>: projectRoot,</div><div class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'eslint'</span>,</div><div class=\"line\">        <span class=\"attr\">include</span>: projectRoot,</div><div class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"attr\">loaders</span>: [</div><div class=\"line\">      <span class=\"comment\">// 需要处理的文件及使用的 loader</span></div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.vue$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'vue'</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.js$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'babel'</span>,</div><div class=\"line\">        <span class=\"attr\">include</span>: projectRoot,</div><div class=\"line\">        <span class=\"attr\">exclude</span>: <span class=\"regexp\">/node_modules/</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.json$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'json'</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(png|jpe?g|gif|svg)(\\?.*)?$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'url'</span>,</div><div class=\"line\">        <span class=\"attr\">query</span>: &#123;</div><div class=\"line\">          <span class=\"attr\">limit</span>: <span class=\"number\">10000</span>,</div><div class=\"line\">          <span class=\"attr\">name</span>: utils.assetsPath(<span class=\"string\">'img/[name].[hash:7].[ext]'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;,</div><div class=\"line\">      &#123;</div><div class=\"line\">        <span class=\"attr\">test</span>: <span class=\"regexp\">/\\.(woff2?|eot|ttf|otf)(\\?.*)?$/</span>,</div><div class=\"line\">        <span class=\"attr\">loader</span>: <span class=\"string\">'url'</span>,</div><div class=\"line\">        <span class=\"attr\">query</span>: &#123;</div><div class=\"line\">          <span class=\"attr\">limit</span>: <span class=\"number\">10000</span>,</div><div class=\"line\">          <span class=\"attr\">name</span>: utils.assetsPath(<span class=\"string\">'fonts/[name].[hash:7].[ext]'</span>)</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">eslint</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// eslint 代码检查配置工具</span></div><div class=\"line\">    formatter: <span class=\"built_in\">require</span>(<span class=\"string\">'eslint-friendly-formatter'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">vue</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">// .vue 文件配置 loader 及工具 (autoprefixer)</span></div><div class=\"line\">    loaders: utils.cssLoaders(&#123; <span class=\"attr\">sourceMap</span>: useCssSourceMap &#125;),</div><div class=\"line\">    <span class=\"attr\">postcss</span>: [</div><div class=\"line\">      <span class=\"built_in\">require</span>(<span class=\"string\">'autoprefixer'</span>)(&#123;</div><div class=\"line\">        <span class=\"attr\">browsers</span>: [<span class=\"string\">'last 2 versions'</span>]</div><div class=\"line\">      &#125;)</div><div class=\"line\">    ]</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"config-index-js\"><a href=\"#config-index-js\" class=\"headerlink\" title=\"config/index.js\"></a>config/index.js</h3><p>终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.js</p>\n<p>index.js 中有 dev 和 production 两种环境的配置</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</div><div class=\"line\">  <span class=\"attr\">build</span>: &#123; <span class=\"comment\">// production 环境</span></div><div class=\"line\">    env: <span class=\"built_in\">require</span>(<span class=\"string\">'./prod.env'</span>), <span class=\"comment\">// 使用 config/prod.env.js 中定义的编译环境</span></div><div class=\"line\">    index: path.resolve(__dirname, <span class=\"string\">'../dist/index.html'</span>), <span class=\"comment\">// 编译输入的 index.html 文件</span></div><div class=\"line\">    assetsRoot: path.resolve(__dirname, <span class=\"string\">'../dist'</span>), <span class=\"comment\">// 编译输出的静态资源路径</span></div><div class=\"line\">    assetsSubDirectory: <span class=\"string\">'static'</span>, <span class=\"comment\">// 编译输出的二级目录</span></div><div class=\"line\">    assetsPublicPath: <span class=\"string\">'/'</span>, <span class=\"comment\">// 编译发布的根目录，可配置为资源服务器域名或 CDN 域名</span></div><div class=\"line\">    productionSourceMap: <span class=\"literal\">true</span>, <span class=\"comment\">// 是否开启 cssSourceMap</span></div><div class=\"line\">    <span class=\"comment\">// Gzip off by default as many popular static hosts such as</span></div><div class=\"line\">    <span class=\"comment\">// Surge or Netlify already gzip all static assets for you.</span></div><div class=\"line\">    <span class=\"comment\">// Before setting to `true`, make sure to:</span></div><div class=\"line\">    <span class=\"comment\">// npm install --save-dev compression-webpack-plugin</span></div><div class=\"line\">    productionGzip: <span class=\"literal\">false</span>, <span class=\"comment\">// 是否开启 gzip</span></div><div class=\"line\">    productionGzipExtensions: [<span class=\"string\">'js'</span>, <span class=\"string\">'css'</span>] <span class=\"comment\">// 需要使用 gzip 压缩的文件扩展名</span></div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">dev</span>: &#123; <span class=\"comment\">// dev 环境</span></div><div class=\"line\">    env: <span class=\"built_in\">require</span>(<span class=\"string\">'./dev.env'</span>), <span class=\"comment\">// 使用 config/dev.env.js 中定义的编译环境</span></div><div class=\"line\">    port: <span class=\"number\">8080</span>, <span class=\"comment\">// 运行测试页面的端口</span></div><div class=\"line\">    assetsSubDirectory: <span class=\"string\">'static'</span>, <span class=\"comment\">// 编译输出的二级目录</span></div><div class=\"line\">    assetsPublicPath: <span class=\"string\">'/'</span>, <span class=\"comment\">// 编译发布的根目录，可配置为资源服务器域名或 CDN 域名</span></div><div class=\"line\">    proxyTable: &#123;&#125;, <span class=\"comment\">// 需要 proxyTable 代理的接口（可跨域）</span></div><div class=\"line\">    cssSourceMap: <span class=\"literal\">false</span> <span class=\"comment\">// 是否开启 cssSourceMap(因为一些 bug 此选项默认关闭，详情可参考 https://github.com/webpack/css-loader#sourcemaps)</span></div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>至此，我们的 npm run dev 命令就讲解完毕，下面让我们来看一看执行 npm run build 命令时发生了什么 ～</p>\n<h3 id=\"build-js\"><a href=\"#build-js\" class=\"headerlink\" title=\"build.js\"></a><strong>build.js</strong></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'./check-versions'</span>)() <span class=\"comment\">// 检查 Node 和 npm 版本</span></div><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'shelljs/global'</span>) <span class=\"comment\">// 使用了 shelljs 插件，可以让我们在 node 环境的 js 中使用 shell</span></div><div class=\"line\">env.NODE_ENV = <span class=\"string\">'production'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>) <span class=\"comment\">// 不再赘述</span></div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>) <span class=\"comment\">// 加载 config.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> ora = <span class=\"built_in\">require</span>(<span class=\"string\">'ora'</span>) <span class=\"comment\">// 一个很好看的 loading 插件</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>) <span class=\"comment\">// 加载 webpack</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.prod.conf'</span>) <span class=\"comment\">// 加载 webpack.prod.conf</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"comment\">//  输出提示信息 ～ 提示用户请在 http 服务下查看本页面，否则为空白页</span></div><div class=\"line\">  <span class=\"string\">'  Tip:\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'  Built files are meant to be served over an HTTP server.\\n'</span> +</div><div class=\"line\">  <span class=\"string\">'  Opening index.html over file:// won\\'t work.\\n'</span></div><div class=\"line\">)</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> spinner = ora(<span class=\"string\">'building for production...'</span>) <span class=\"comment\">// 使用 ora 打印出 loading + log</span></div><div class=\"line\">spinner.start() <span class=\"comment\">// 开始 loading 动画</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 拼接编译输出文件路径 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> assetsPath = path.join(config.build.assetsRoot, config.build.assetsSubDirectory)</div><div class=\"line\"><span class=\"comment\">/* 删除这个文件夹 （递归删除） */</span></div><div class=\"line\">rm(<span class=\"string\">'-rf'</span>, assetsPath)</div><div class=\"line\"><span class=\"comment\">/* 创建此文件夹 */</span></div><div class=\"line\">mkdir(<span class=\"string\">'-p'</span>, assetsPath)</div><div class=\"line\"><span class=\"comment\">/* 复制 static 文件夹到我们的编译输出目录 */</span></div><div class=\"line\">cp(<span class=\"string\">'-R'</span>, <span class=\"string\">'static/*'</span>, assetsPath)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//  开始 webpack 的编译</span></div><div class=\"line\">webpack(webpackConfig, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err, stats</span>) </span>&#123;</div><div class=\"line\">  <span class=\"comment\">// 编译成功的回调函数</span></div><div class=\"line\">  spinner.stop()</div><div class=\"line\">  <span class=\"keyword\">if</span> (err) <span class=\"keyword\">throw</span> err</div><div class=\"line\">  process.stdout.write(stats.toString(&#123;</div><div class=\"line\">    <span class=\"attr\">colors</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">    <span class=\"attr\">modules</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">children</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">chunks</span>: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"attr\">chunkModules</span>: <span class=\"literal\">false</span></div><div class=\"line\">  &#125;) + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">  &#125;) + <span class=\"string\">'\\n'</span>)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"webpack-prod-conf-js\"><a href=\"#webpack-prod-conf-js\" class=\"headerlink\" title=\"webpack.prod.conf.js\"></a><strong>webpack.prod.conf.js</strong></h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">'path'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> config = <span class=\"built_in\">require</span>(<span class=\"string\">'../config'</span>) <span class=\"comment\">// 加载 confi.index.js</span></div><div class=\"line\"><span class=\"keyword\">var</span> utils = <span class=\"built_in\">require</span>(<span class=\"string\">'./utils'</span>) <span class=\"comment\">// 使用一些小工具</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>) <span class=\"comment\">// 加载 webpack</span></div><div class=\"line\"><span class=\"keyword\">var</span> merge = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack-merge'</span>) <span class=\"comment\">// 加载 webpack 配置合并工具</span></div><div class=\"line\"><span class=\"keyword\">var</span> baseWebpackConfig = <span class=\"built_in\">require</span>(<span class=\"string\">'./webpack.base.conf'</span>) <span class=\"comment\">// 加载 webpack.base.conf.js</span></div><div class=\"line\"><span class=\"comment\">/* 一个 webpack 扩展，可以提取一些代码并且将它们和文件分离开 */</span></div><div class=\"line\"><span class=\"comment\">/* 如果我们想将 webpack 打包成一个文件 css js 分离开，那我们需要这个插件 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> ExtractTextPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'extract-text-webpack-plugin'</span>)</div><div class=\"line\"><span class=\"comment\">/* 一个可以插入 html 并且创建新的 .html 文件的插件 */</span></div><div class=\"line\"><span class=\"keyword\">var</span> HtmlWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'html-webpack-plugin'</span>)</div><div class=\"line\"><span class=\"keyword\">var</span> env = config.build.env</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 合并 webpack.base.conf.js */</span></div><div class=\"line\"><span class=\"keyword\">var</span> webpackConfig = merge(baseWebpackConfig, &#123;</div><div class=\"line\">  <span class=\"attr\">module</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">/* 使用的 loader */</span></div><div class=\"line\">    loaders: utils.styleLoaders(&#123; <span class=\"attr\">sourceMap</span>: config.build.productionSourceMap, <span class=\"attr\">extract</span>: <span class=\"literal\">true</span> &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"comment\">/* 是否使用 #source-map 开发工具，更多信息可以查看 DDFE 往期文章 */</span></div><div class=\"line\">  devtool: config.build.productionSourceMap ? <span class=\"string\">'#source-map'</span> : <span class=\"literal\">false</span>,</div><div class=\"line\">  <span class=\"attr\">output</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">/* 编译输出目录 */</span></div><div class=\"line\">    path: config.build.assetsRoot,</div><div class=\"line\">    <span class=\"comment\">/* 编译输出文件名 */</span></div><div class=\"line\">    filename: utils.assetsPath(<span class=\"string\">'js/[name].[chunkhash].js'</span>), <span class=\"comment\">// 我们可以在 hash 后加 :6 决定使用几位 hash 值</span></div><div class=\"line\">    <span class=\"comment\">// 没有指定输出名的文件输出的文件名</span></div><div class=\"line\">    chunkFilename: utils.assetsPath(<span class=\"string\">'js/[id].[chunkhash].js'</span>)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">vue</span>: &#123;</div><div class=\"line\">    <span class=\"comment\">/* 编译 .vue 文件时使用的 loader */</span></div><div class=\"line\">    loaders: utils.cssLoaders(&#123;</div><div class=\"line\">      <span class=\"attr\">sourceMap</span>: config.build.productionSourceMap,</div><div class=\"line\">      <span class=\"attr\">extract</span>: <span class=\"literal\">true</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"attr\">plugins</span>: [</div><div class=\"line\">    <span class=\"comment\">/* 使用的插件 */</span></div><div class=\"line\">    <span class=\"comment\">/* definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.DefinePlugin(&#123;</div><div class=\"line\">      <span class=\"string\">'process.env'</span>: env</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"comment\">/* 压缩 js (同样可以压缩 css) */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">compress</span>: &#123;</div><div class=\"line\">        <span class=\"attr\">warnings</span>: <span class=\"literal\">false</span></div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.OccurrenceOrderPlugin(),</div><div class=\"line\">    <span class=\"comment\">/* 将 css 文件分离出来 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> ExtractTextPlugin(utils.assetsPath(<span class=\"string\">'css/[name].[contenthash].css'</span>)),</div><div class=\"line\">    <span class=\"comment\">/* 构建要输出的 index.html 文件， HtmlWebpackPlugin 可以生成一个 html 并且在其中插入你构建生成的资源 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> HtmlWebpackPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">filename</span>: config.build.index, <span class=\"comment\">// 生成的 html 文件名</span></div><div class=\"line\">      template: <span class=\"string\">'index.html'</span>, <span class=\"comment\">// 使用的模板</span></div><div class=\"line\">      inject: <span class=\"literal\">true</span>, <span class=\"comment\">// 是否注入 html (有多重注入方式，可以选择注入的位置)</span></div><div class=\"line\">      minify: &#123; <span class=\"comment\">// 压缩的方式</span></div><div class=\"line\">        removeComments: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"attr\">collapseWhitespace</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">        <span class=\"attr\">removeAttributeQuotes</span>: <span class=\"literal\">true</span></div><div class=\"line\">        <span class=\"comment\">// 更多参数可查看 https://github.com/kangax/html-minifier#options-quick-reference</span></div><div class=\"line\">      &#125;,</div><div class=\"line\">      <span class=\"attr\">chunksSortMode</span>: <span class=\"string\">'dependency'</span></div><div class=\"line\">    &#125;),</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 此处增加 @OYsun 童鞋补充</span></div><div class=\"line\">    <span class=\"comment\">// CommonsChunkPlugin用于生成在入口点之间共享的公共模块（比如jquery，vue）的块并将它们分成独立的包。而为什么要new两次这个插件，这是一个很经典的bug的解决方案，在webpack的一个issues有过深入的讨论webpack/webpack#1315 .----为了将项目中的第三方依赖代码抽离出来，官方文档上推荐使用这个插件，当我们在项目里实际使用之后，发现一旦更改了 app.js 内的代码，vendor.js 的 hash 也会改变，那么下次上线时，用户仍然需要重新下载 vendor.js 与 app.js</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">'vendor'</span>,</div><div class=\"line\">      <span class=\"attr\">minChunks</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">module, count</span>) </span>&#123;</div><div class=\"line\">        <span class=\"comment\">// 依赖的 node_modules 文件会被提取到 vendor 中</span></div><div class=\"line\">        <span class=\"keyword\">return</span> (</div><div class=\"line\">          <span class=\"built_in\">module</span>.resource &amp;&amp;</div><div class=\"line\">          <span class=\"regexp\">/\\.js$/</span>.test(<span class=\"built_in\">module</span>.resource) &amp;&amp;</div><div class=\"line\">          <span class=\"built_in\">module</span>.resource.indexOf(</div><div class=\"line\">            path.join(__dirname, <span class=\"string\">'../node_modules'</span>)</div><div class=\"line\">          ) === <span class=\"number\">0</span></div><div class=\"line\">        )</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;),</div><div class=\"line\">    <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">name</span>: <span class=\"string\">'manifest'</span>,</div><div class=\"line\">      <span class=\"attr\">chunks</span>: [<span class=\"string\">'vendor'</span>]</div><div class=\"line\">    &#125;)</div><div class=\"line\"></div><div class=\"line\">  ]</div><div class=\"line\">&#125;)</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/* 开启 gzip 的情况下使用下方的配置 */</span></div><div class=\"line\"><span class=\"keyword\">if</span> (config.build.productionGzip) &#123;</div><div class=\"line\">  <span class=\"comment\">/* 加载 compression-webpack-plugin 插件 */</span></div><div class=\"line\">  <span class=\"keyword\">var</span> CompressionWebpackPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'compression-webpack-plugin'</span>)</div><div class=\"line\">  <span class=\"comment\">/* 向webpackconfig.plugins中加入下方的插件 */</span></div><div class=\"line\">  webpackConfig.plugins.push(</div><div class=\"line\">    <span class=\"comment\">/* 使用 compression-webpack-plugin 插件进行压缩 */</span></div><div class=\"line\">    <span class=\"keyword\">new</span> CompressionWebpackPlugin(&#123;</div><div class=\"line\">      <span class=\"attr\">asset</span>: <span class=\"string\">'[path].gz[query]'</span>,</div><div class=\"line\">      <span class=\"attr\">algorithm</span>: <span class=\"string\">'gzip'</span>,</div><div class=\"line\">      <span class=\"attr\">test</span>: <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(</div><div class=\"line\">        <span class=\"string\">'\\\\.('</span> +</div><div class=\"line\">        config.build.productionGzipExtensions.join(<span class=\"string\">'|'</span>) +</div><div class=\"line\">        <span class=\"string\">')$'</span></div><div class=\"line\">      ),</div><div class=\"line\">      <span class=\"attr\">threshold</span>: <span class=\"number\">10240</span>,</div><div class=\"line\">      <span class=\"attr\">minRatio</span>: <span class=\"number\">0.8</span></div><div class=\"line\">    &#125;)</div><div class=\"line\">  )</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">module</span>.exports = webpackConfig</div></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>至此 ～ 我们的 vue-cli#2.0 webpack 配置分析文件就讲解完毕 ～</p>\n<p>对于一些插件的详细 options 我们没有进行讲解，感兴趣的同学可以去 npm 商店搜索对应插件查看 options ~</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n","excerpt":"前言 作为 Vue 的使用者我们对于 vue-cli 都很熟悉，但是对它的 webpack 配置我们可能关注甚少，今天我们为大家带来 vue-cli#2.0 的 webpack 配置分析 vue-cli 的简介、安装我们不在这里赘述，对它还不熟悉的同学可以直接访问 vue-cli 查看 目录结构","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.pengmengshan.cn/blog/tags/js/"}]},{"title":"javascript设计模式 ① 正确使用面向对象编程的姿势!!!","date":"2017-04-26T01:52:08.000Z","path":"2017/04/26/it-20170426js/","text":"javascript是一门弱语言，他有着分同一般的灵活性使它迅速的成为几乎人人必会的一门语言，but，你们使用的姿势真的正确吗？ 在以前的开发过程当中，老板：给我加个验证用户邮箱、验证用户短信…功能！ 123function checkMessage()&#123;...&#125;function checkEmail()&#123;...&#125;function ... //茫茫多的函数 这样写好了之后 function 是全局的变量，那么是全局的就难免会对项目javascript环境造成污染，可能会对其他同事造成影响，我们首先要考虑会不会影响别人，如果别人重名对你的checkMessage覆盖，那么这样的BUG是很难发现的。为了不造成太多的全局污染，我们可以这样写： 12345var checkObject = &#123; checkMessage:function()&#123;&#125;, checkEmail:function()&#123;&#125;, ...&#125; 首先说明，并不是这样写就不会造成污染了，checkObject依旧是全局变量，那么好处在哪里呢？想一下如果Jquery的$被覆盖了，那么我们页面的 1$.each | $.extends | $(#id) | $... 都失效了，那么我们很容易定位问题: Jquery出问题了！checkObject也是一样,当checkObject出问题了，我们很容易定位错误。 1调用：checkObject.checkMessage() 即可 那么问题又来了：如果有同事用我的checkObject搞一些事情呢？它可以直接用我的方法么？当然可以，问题是，你买了一本书你愿意别人乱写乱画么？我们可以改造一下： 1234567var checkObject = function()&#123; return &#123; checkMessage:function()&#123;&#125;, checkEmail:function()&#123;&#125;, ... &#125;&#125; 我们把方法通过function的调用返回，这样别人可以这样用 ： 12var check = checkObject();check.checkEmail(); 我们可以再完善一下，把checkObject看成java的类，checkMessage,checkEmail看成java的public 公有方法,既然看成类了，我们可以把checkObject写成大写CheckObject 12345var CheckObject = function()&#123; this.checkMessage = function()&#123;&#125;, this.checkEmail = function()&#123;&#125;, ...&#125; 别人调用: 12var check = new CheckObject(); //既然是一个类了，就要 new 来实例化了check.checkEmail(); 每一次通过new创建新对象的时候，新创建的对象都会对类this上的属性进行复制，你定义了两个那么就复制两次，那么再更多呢？是不是感觉有些奢侈呢，考虑我们可以运用javascript的原型prototype来创建它： 123456var CheckObject = function()&#123;&#125;CheckObject.prototype.checkMessage = function()&#123;&#125;,CheckObject.prototype.checkEmail = function()&#123;&#125;,... 你嫌麻烦？ 12345678var CheckObject = function()&#123;&#125;CheckObject.prototype&#123;checkMessage : function()&#123;&#125;,checkEmail : function()&#123;&#125;,...&#125; 这样我们的方法都复制到CheckObject的原型连上去了，创建出来的对象都是通过prototype依次寻找，都绑定在CheckObject的原型上proto 随便看一下Jquery的原型链，是不是很熟悉的方法呢？同志们是否好奇Jquery的方法是如何链式调用的呢？很简单，我来模拟一下 1234567891011var CheckObject = function()&#123;&#125;CheckObject.prototype&#123;checkMessage : function()&#123; ... return this &#125;,checkEmail : function()&#123; ... return this &#125;,...CheckObject check = new CheckObject();check.checkMessage().checkEmail(); 就这么简单，我们只需要将this指代的当前对象全部返回即可。 咳咳，言归正传，回到面向对象编程的课题上 java中有 private声明的私有变量、 有通过public的getter setter方法进行通信，有static修饰的静态变量，静态方法，有构造器，那么javascript可以使用这样的设计模式么？可以，跟我往下看: 我们去商店买烟 12345678910111213141516171819202122232425262728293031323334353637383940414243var Smoke = function(id,name)&#123; //私有属性 var num = 0; //对象的公有属性 （需要new） this.id = id; //私有方法 function checkID()&#123; return true&#125;; //公有 setter getter 构造函数 this.setName = function(name)&#123; this.name = name; &#125; this.getName = function()&#123; return this.name; &#125; //对象的公有属性 （需要new） this.information = function()&#123; //只有在Smoke内部才能调用checkID() if(checkID()) return this.name+'香烟'+'订单号 :'+this.id &#125;&#125;Smock.prototype = &#123; money:'10元', //公有属性（不需要new） 直接Smoke.money[想没想到Array的length?] other:function()&#123;&#125;&#125;var smoke = new Smoke(994857,'煊赫门');smoke.information(); //\"undefined香烟订单号 :994857\" ps:因为我们没对Smoke的name属性赋值smoke.setName('煊赫门'); //我们赋值smoke.information(); //\"煊赫门香烟订单号 :994857\"smoke.num; //undefined ps:很明显他是私有属性smoke.checkID();//error is not function ps:很明显私有方法如果我们没有newvar smoke = Smoke(994857,'煊赫门');smoke.information(); //Uncaught TypeError: Cannot read property 'information' of undefined纳尼报错了？smoke //undefindsmoke.money; //10元 (好像明白了什么......) 别急让我们看下window 1window.information(); // \"undefined香烟订单号 :994857\" 恍然大悟，因为new是可以对当前对象（Smoke)的this不停地赋值【上面讲过】，而上面的没有new相当于全局执行了Smoke() 所以是他的this 指向到 window去了！怎么避免这种无操作呢？我们在Smoke内部进行类型检查： 12345678910111213141516171819202122var Smoke = function(id,name)&#123; var num = 0; function checkID()&#123; return true&#125;; //判断this在执行过程中是不是属于Smoke，如果是说明是new过的 0.0 if(this instanceof Smoke)&#123; this.id = id; this.setName = function(name)&#123; this.name = name; &#125; this.getName = function()&#123; return this.name; &#125; //对象的公有属性 （需要new） this.information = function()&#123; //只有在Smoke内部才能调用checkID() if(checkID()) return this.name+'香烟'+'订单号 :'+this.id &#125; &#125;else&#123; return new Smoke(id,name);//内部重新new一个 0.0 &#125;&#125; 看完了么，感觉爽不，是不是感觉就是在写java呢，其实javascript就是灵活在这里，这只是javascript一种常用的面向对象设计模式，后面我会将更多的设计模式，这些设计模式都是经过前人无数心血总结出来给我们的，我们为什么不用呢？ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>javascript是一门弱语言，他有着分同一般的灵活性使它迅速的成为几乎人人必会的一门语言，but，你们使用的姿势真的正确吗？</p>\n<p>在以前的开发过程当中，老板：给我加个验证用户邮箱、验证用户短信…功能！</p>\n<a id=\"more\"></a>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkMessage</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkEmail</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> ... //茫茫多的函数</span></div></pre></td></tr></table></figure>\n<p>这样写好了之后 function 是全局的变量，那么是全局的就难免会对项目javascript环境造成污染，可能会对其他同事造成影响，我们首先要考虑会不会影响别人，如果别人重名对你的checkMessage覆盖，那么这样的BUG是很难发现的。为了不造成太多的全局污染，我们可以这样写：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> checkObject = &#123;</div><div class=\"line\">    <span class=\"attr\">checkMessage</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">    <span class=\"attr\">checkEmail</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>首先说明，并不是这样写就不会造成污染了，checkObject依旧是全局变量，那么好处在哪里呢？想一下如果Jquery的$被覆盖了，那么我们页面的</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$.each | $.extends | $(#id) | $...</div></pre></td></tr></table></figure>\n<p>都失效了，那么我们很容易定位问题: Jquery出问题了！checkObject也是一样,当checkObject出问题了，我们很容易定位错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">调用：checkObject.checkMessage() 即可</div></pre></td></tr></table></figure>\n<p>那么问题又来了：如果有同事用我的checkObject搞一些事情呢？它可以直接用我的方法么？当然可以，问题是，你买了一本书你愿意别人乱写乱画么？我们可以改造一下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> checkObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">        <span class=\"attr\">checkMessage</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">        <span class=\"attr\">checkEmail</span>:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">        ...</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们把方法通过function的调用返回，这样别人可以这样用 ：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> check = checkObject();</div><div class=\"line\">check.checkEmail();</div></pre></td></tr></table></figure>\n<p>我们可以再完善一下，把checkObject看成java的类，checkMessage,checkEmail看成java的public 公有方法,既然看成类了，我们可以把checkObject写成大写CheckObject</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.checkMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">    <span class=\"keyword\">this</span>.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>别人调用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> check = <span class=\"keyword\">new</span> CheckObject(); <span class=\"comment\">//既然是一个类了，就要 new 来实例化了</span></div><div class=\"line\">check.checkEmail();</div></pre></td></tr></table></figure>\n<p>每一次通过new创建新对象的时候，新创建的对象都会对类this上的属性进行复制，你定义了两个那么就复制两次，那么再更多呢？是不是感觉有些奢侈呢，考虑我们可以运用javascript的原型prototype来创建它：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">CheckObject.prototype.checkMessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">CheckObject.prototype.checkEmail = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>你嫌麻烦？</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">CheckObject.prototype&#123;</div><div class=\"line\"><span class=\"attr\">checkMessage</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\"><span class=\"attr\">checkEmail</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;,</div><div class=\"line\">...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这样我们的方法都复制到CheckObject的原型连上去了，创建出来的对象都是通过prototype依次寻找，都绑定在CheckObject的原型上<strong>proto</strong></p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/3adc2b183e7a22203dc2\" alt=\"\"></p>\n<p>随便看一下Jquery的原型链，是不是很熟悉的方法呢？<br>同志们是否好奇Jquery的方法是如何链式调用的呢？很简单，我来模拟一下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> CheckObject = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\">CheckObject.prototype&#123;</div><div class=\"line\"><span class=\"attr\">checkMessage</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; ... return <span class=\"keyword\">this</span> &#125;,</div><div class=\"line\"><span class=\"attr\">checkEmail</span> : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; ... return <span class=\"keyword\">this</span> &#125;,</div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">CheckObject check = <span class=\"keyword\">new</span> CheckObject();</div><div class=\"line\">check.checkMessage().checkEmail();</div></pre></td></tr></table></figure>\n<p>就这么简单，我们只需要将this指代的当前对象全部返回即可。</p>\n<p>咳咳，言归正传，回到面向对象编程的课题上</p>\n<p>java中有 private声明的私有变量、 有通过public的getter setter方法进行通信，有static修饰的静态变量，静态方法，有构造器，那么javascript可以使用这样的设计模式么？可以，跟我往下看:</p>\n<p>我们去商店买烟</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Smoke = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id,name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"comment\">//私有属性</span></div><div class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//对象的公有属性  （需要new）</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.id = id;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//私有方法</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>&#125;;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//公有 setter getter 构造函数</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//对象的公有属性  （需要new）</span></div><div class=\"line\">    <span class=\"keyword\">this</span>.information = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">        <span class=\"comment\">//只有在Smoke内部才能调用checkID()</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(checkID()) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name+<span class=\"string\">'香烟'</span>+<span class=\"string\">'订单号 :'</span>+<span class=\"keyword\">this</span>.id</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Smock.prototype = &#123;</div><div class=\"line\">    <span class=\"attr\">money</span>:<span class=\"string\">'10元'</span>,  <span class=\"comment\">//公有属性（不需要new） 直接Smoke.money[想没想到Array的length?]</span></div><div class=\"line\">    other:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> smoke = <span class=\"keyword\">new</span> Smoke(<span class=\"number\">994857</span>,<span class=\"string\">'煊赫门'</span>);</div><div class=\"line\">smoke.information(); <span class=\"comment\">//\"undefined香烟订单号 :994857\" ps:因为我们没对Smoke的name属性赋值</span></div><div class=\"line\">smoke.setName(<span class=\"string\">'煊赫门'</span>); <span class=\"comment\">//我们赋值</span></div><div class=\"line\">smoke.information(); <span class=\"comment\">//\"煊赫门香烟订单号 :994857\"</span></div><div class=\"line\">smoke.num; <span class=\"comment\">//undefined ps:很明显他是私有属性</span></div><div class=\"line\">smoke.checkID();<span class=\"comment\">//error is not function ps:很明显私有方法</span></div><div class=\"line\">如果我们没有<span class=\"keyword\">new</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> smoke = Smoke(<span class=\"number\">994857</span>,<span class=\"string\">'煊赫门'</span>);</div><div class=\"line\">smoke.information(); <span class=\"comment\">//Uncaught TypeError: Cannot read property 'information' of undefined</span></div><div class=\"line\">纳尼报错了？</div><div class=\"line\"></div><div class=\"line\">smoke <span class=\"comment\">//undefind</span></div><div class=\"line\">smoke.money; <span class=\"comment\">//10元 (好像明白了什么......)</span></div></pre></td></tr></table></figure>\n<p>别急让我们看下window</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">window</span>.information(); <span class=\"comment\">// \"undefined香烟订单号 :994857\"</span></div></pre></td></tr></table></figure>\n<p>恍然大悟，因为new是可以对当前对象（Smoke)的this不停地赋值【上面讲过】，而上面的没有new相当于全局执行了Smoke() 所以是他的this 指向到 window去了！<br>怎么避免这种无操作呢？我们在Smoke内部进行类型检查：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Smoke = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">id,name</span>)</span>&#123;</div><div class=\"line\">    <span class=\"keyword\">var</span> num = <span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkID</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"literal\">true</span>&#125;;</div><div class=\"line\">    <span class=\"comment\">//判断this在执行过程中是不是属于Smoke，如果是说明是new过的  0.0</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span> <span class=\"keyword\">instanceof</span> Smoke)&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.id = id;</div><div class=\"line\">        <span class=\"keyword\">this</span>.setName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>)</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.name = name;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">this</span>.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//对象的公有属性  （需要new）</span></div><div class=\"line\">        <span class=\"keyword\">this</span>.information = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">            <span class=\"comment\">//只有在Smoke内部才能调用checkID()</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(checkID()) <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name+<span class=\"string\">'香烟'</span>+<span class=\"string\">'订单号 :'</span>+<span class=\"keyword\">this</span>.id</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Smoke(id,name);<span class=\"comment\">//内部重新new一个  0.0</span></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>看完了么，感觉爽不，是不是感觉就是在写java呢，其实javascript就是灵活在这里，这只是javascript一种常用的面向对象设计模式，后面我会将更多的设计模式，这些设计模式都是经过前人无数心血总结出来给我们的，我们为什么不用呢？</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"javascript是一门弱语言，他有着分同一般的灵活性使它迅速的成为几乎人人必会的一门语言，but，你们使用的姿势真的正确吗？ 在以前的开发过程当中，老板：给我加个验证用户邮箱、验证用户短信…功能！","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.pengmengshan.cn/blog/tags/js/"}]},{"title":"Mock 平台 - Easy Mock 在线数据模拟平台","date":"2017-04-26T01:28:15.000Z","path":"2017/04/26/mock/","text":"活儿好又性感的在线 Mock 平台 - Easy Mock介绍 什么是 Easy Mock Easy Mock 是一个极其简单、高效、\b可视化、并且能快速生成模拟数据的在线 mock 服务。以项目管理的方式组织 Mock List，能帮助我们更好的管理 Mock 数据，不怕丢失。你问我为什么要用它？请听我一一道来它的过人之处。 网站地址：https://www.easy-mock.com 欢迎注册体验。 目前 easy-mock 在大搜车已经支持了200个项目，4000条mock数据的量级，并且完全独立部署，请大家放心使用。 前言今天我们要说一说 如何有效提高前端开发效率 ，这个话题似乎有些大了，更确切的说应该是 如何使用 Easy Mock 提高前端开发效率。在前后端分离的大浪潮下，如何有效保障我们在开发环节不被打断？（接口开发需要的时间往往比前端多） 数据伪造我相信大家都有各自的办法。比如说， 将 Mock 数据写在代码里 利用请求拦截 利用 Charles 等代理工具，将 URL Map 到本地文件 本地 Mock Server 上面这些方法虽然可以解决我们的问题，但同样伴随着一些问题。比如说， 脏代码 依赖特定的框架 增加切换成本 接口数据结构重构需要手动更新 效率低下 无法优雅的进行协同编辑 无法持久化 看到这些，它们真的能够提高我们的开发效率吗？答案就在你的心中。为此，Easy Mock 就这样诞生了。 支持 Swagger Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。 效率一直我们关注的问题，Easy Mock 支持基于 Swagger 生成 Mock List。并且，智能的更新操作只会对已经变动的接口做覆盖式更新。并且基于 Swagger 创建的接口是支持参数显示的，也就是说我们能看到这个接口的请求参数和响应数据结构。 再简单点讲，它的强大之处在于彻底解放我们的双手。只要后端用了 Swagger（并且按照规范生成 API 文档），生成 Mock 数据只是 1秒钟 的事情。 具体的使用方式见 Easy Mock 官网文档。 更简单的团队协作Easy Mock 提供了 2 种方式以实现团队协作编辑。 个人项目 下邀请小伙伴一起参与编辑 创建团队 或 加入团队 即可参与该团队下所有项目的编辑 响应数据如果能根据传入的参数动态返回数据该多好？Easy Mock 支持处理 Request 对象。也就是说我们可以通过 Request 对象的某些属性进行条件判断，从而实现 响应式数据。那么，Request 对象都有些什么属性呢？如下， header method url querystring host hostname query cookies这些只是一部分，更多属性和使用方式见 Easy Mock 官网文档 接口代理 有了接口代理可以做更多的事情。 代码调试 跨域请求 工作台如何在茫茫的项目列表中找到你想要进行编辑的项目？搜索虽然很方便，但有时候来回切换项目也需要时间成本，并且这是烦人的。为此我们可以通过将项目添加到工作台中，以提高我们的使用效率。 快捷键为了进一步提升效率，值得一提的小细节是 Easy Mock 支持快捷键操作。 创建项目 &amp; 创建接口 在 项目列表 或 接口列表 中，按下 ctrl + c 搜索 在 项目列表 或 接口列表 中，按下 ctrl + s 更多特性导出接口 有可能你需要在本地用到这些接口，正好 Easy Mock 支持导出数据。 复制 这对于接口版本升级是很有用的。试想一下，一个项目超过 200 个接口，如果后面接口版本升级，同时以前的接口不变。再一次创建 200 个接口是什么感觉？ Restful 如果后端提供 /restful/:id/list 或者 /restful/{id}/list 这样的接口地址。别慌，Easy Mock 是支持的 扩展移动端调试 步骤如下： 利用 Charles Fiddler 等代理工具，抓取客户端中包含页面入口的接口在 Easy Mock 上创建一个接口将刚刚抓取的接口数据复制到 数据模型 中，修改页面入口为本地的入口然后保存。要用本地 ip 哦，localhost 在手机上是无效的点击 预览，复制接口地址回到代理工具。点击最开始抓取的接口，将其代理成刚刚复制的地址即可这个方式可以为调试带来极大的帮助。 联系方式反馈问题请加QQ群：595325417 原文链接 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p><img src=\"https://dn-mhke0kuv.qbox.me/693e427d03dabb5957ee.png\" alt=\"\"></p>\n<h2 id=\"活儿好又性感的在线-Mock-平台-Easy-Mock\"><a href=\"#活儿好又性感的在线-Mock-平台-Easy-Mock\" class=\"headerlink\" title=\"活儿好又性感的在线 Mock 平台 - Easy Mock\"></a>活儿好又性感的在线 Mock 平台 - Easy Mock</h2><p>介绍</p>\n<p>什么是 Easy Mock</p>\n<a id=\"more\"></a>\n<p>Easy Mock 是一个极其简单、高效、\b可视化、并且能快速生成模拟数据的在线 mock 服务。<br>以项目管理的方式组织 Mock List，能帮助我们更好的管理 Mock 数据，不怕丢失。<br>你问我为什么要用它？请听我一一道来它的过人之处。</p>\n<p>网站地址：<a href=\"https://www.easy-mock.com\" target=\"_blank\" rel=\"external\">https://www.easy-mock.com</a> 欢迎注册体验。</p>\n<p>目前 easy-mock 在大搜车已经支持了200个项目，4000条mock数据的量级，并且完全独立部署，请大家放心使用。</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>今天我们要说一说 如何有效提高前端开发效率 ，这个话题似乎有些大了，<br>更确切的说应该是 如何使用 Easy Mock 提高前端开发效率。在前后端分离的大浪潮下，如何有效保障我们在开发环节不被打断？（接口开发需要的时间往往比前端多）</p>\n<h3 id=\"数据伪造\"><a href=\"#数据伪造\" class=\"headerlink\" title=\"数据伪造\"></a>数据伪造</h3><p>我相信大家都有各自的办法。比如说，</p>\n<ul>\n<li>将 Mock 数据写在代码里</li>\n<li>利用请求拦截</li>\n<li>利用 Charles 等代理工具，将 URL Map 到本地文件</li>\n<li>本地 Mock Server</li>\n</ul>\n<p>上面这些方法虽然可以解决我们的问题，但同样伴随着一些问题。比如说，</p>\n<ul>\n<li>脏代码</li>\n<li>依赖特定的框架</li>\n<li>增加切换成本</li>\n<li>接口数据结构重构需要手动更新</li>\n<li>效率低下</li>\n<li>无法优雅的进行协同编辑</li>\n<li>无法持久化</li>\n</ul>\n<p>看到这些，它们真的能够提高我们的开发效率吗？答案就在你的心中。<br>为此，Easy Mock 就这样诞生了。</p>\n<p>支持 Swagger</p>\n<blockquote>\n<p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。</p>\n</blockquote>\n<p>效率一直我们关注的问题，Easy Mock 支持基于 Swagger 生成 Mock List。并且，智能的更新操作只会对已经变动的接口做覆盖式更新。<br>并且基于 Swagger 创建的接口是支持参数显示的，也就是说我们能看到这个接口的请求参数和响应数据结构。</p>\n<p>再简单点讲，它的强大之处在于彻底解放我们的双手。只要后端用了 Swagger（并且按照规范生成 API 文档），生成 Mock 数据只是 1秒钟 的事情。</p>\n<p>具体的使用方式见 Easy Mock 官网文档。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/73691fc806ff70250d52.png\" alt=\"\"></p>\n<h3 id=\"更简单的团队协作\"><a href=\"#更简单的团队协作\" class=\"headerlink\" title=\"更简单的团队协作\"></a>更简单的团队协作</h3><p>Easy Mock 提供了 2 种方式以实现团队协作编辑。</p>\n<ul>\n<li>个人项目 下邀请小伙伴一起参与编辑</li>\n<li>创建团队 或 加入团队 即可参与该团队下所有项目的编辑</li>\n</ul>\n<h3 id=\"响应数据\"><a href=\"#响应数据\" class=\"headerlink\" title=\"响应数据\"></a>响应数据</h3><p>如果能根据传入的参数动态返回数据该多好？Easy Mock 支持处理 Request 对象。<br>也就是说我们可以通过 Request 对象的某些属性进行条件判断，从而实现 响应式数据。<br>那么，Request 对象都有些什么属性呢？如下，</p>\n<ul>\n<li>header</li>\n<li>method</li>\n<li>url</li>\n<li>querystring</li>\n<li>host</li>\n<li>hostname</li>\n<li>query</li>\n<li>cookies<br>这些只是一部分，更多属性和使用方式见 Easy Mock 官网文档</li>\n</ul>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/3908b21d67664b7cd706.png\" alt=\"\"></p>\n<h3 id=\"接口代理\"><a href=\"#接口代理\" class=\"headerlink\" title=\"接口代理\"></a>接口代理</h3><blockquote>\n<p>有了接口代理可以做更多的事情。</p>\n</blockquote>\n<ul>\n<li>代码调试</li>\n<li>跨域请求</li>\n</ul>\n<h3 id=\"工作台\"><a href=\"#工作台\" class=\"headerlink\" title=\"工作台\"></a>工作台</h3><p>如何在茫茫的项目列表中找到你想要进行编辑的项目？<br>搜索虽然很方便，但有时候来回切换项目也需要时间成本，并且这是烦人的。<br>为此我们可以通过将项目添加到工作台中，以提高我们的使用效率。</p>\n<p><img src=\"https://dn-mhke0kuv.qbox.me/28ac33f30c0b201f873d.png\" alt=\"\"></p>\n<h3 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h3><p>为了进一步提升效率，值得一提的小细节是 Easy Mock 支持快捷键操作。</p>\n<p><strong>创建项目 &amp; 创建接口</strong></p>\n<p>在 项目列表 或 接口列表 中，按下 ctrl + c</p>\n<p><strong>搜索</strong></p>\n<p>在 项目列表 或 接口列表 中，按下 ctrl + s</p>\n<h3 id=\"更多特性\"><a href=\"#更多特性\" class=\"headerlink\" title=\"更多特性\"></a>更多特性</h3><p><strong>导出接口</strong></p>\n<p>有可能你需要在本地用到这些接口，正好 Easy Mock 支持导出数据。</p>\n<p><strong>复制</strong></p>\n<p>这对于接口版本升级是很有用的。试想一下，一个项目超过 200 个接口，如果后面接口版本升级，同时以前的接口不变。再一次创建 200 个接口是什么感觉？</p>\n<p><strong>Restful</strong></p>\n<p>如果后端提供 /restful/:id/list 或者 /restful/{id}/list 这样的接口地址。别慌，Easy Mock 是支持的</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p><strong>移动端调试</strong></p>\n<p>步骤如下：</p>\n<p>利用 Charles Fiddler 等代理工具，抓取客户端中包含页面入口的接口<br>在 Easy Mock 上创建一个接口<br>将刚刚抓取的接口数据复制到 数据模型 中，修改页面入口为本地的入口然后保存。要用本地 ip 哦，localhost 在手机上是无效的<br>点击 预览，复制接口地址<br>回到代理工具。点击最开始抓取的接口，将其代理成刚刚复制的地址即可<br>这个方式可以为调试带来极大的帮助。</p>\n<h3 id=\"联系方式\"><a href=\"#联系方式\" class=\"headerlink\" title=\"联系方式\"></a>联系方式</h3><p>反馈问题请加QQ群：595325417</p>\n<p><a href=\"https://juejin.im/post/58ff1fae61ff4b0066792f6e\" target=\"_blank\" rel=\"external\">原文链接</a></p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"活儿好又性感的在线 Mock 平台 - Easy Mock介绍 什么是 Easy Mock","categories":[],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"http://www.pengmengshan.cn/blog/tags/小技巧/"}]},{"title":"JavaScript 巧学巧用","date":"2017-04-25T09:12:47.000Z","path":"2017/04/25/it-20170425js/","text":"前言 由于工作和生活上的一些变化，最近写文章的频率有点下降了，实在不好意思，不过相信不久就会慢慢恢复过来，感谢大家一直以来的关注和支持。 本文主要给大家分享一下在编写JavaScript代码的时候存在的一些方法和技巧，虽然有时候条条大路都通向罗马，但是也许总会有那么一条最短的路径可走。希望通过以下几点JavaScript技巧让大家的代码“化繁为简，化简为精”。巧学巧用 1. new Set()可能有人知道ES6中提供了新的数据结构 Set，但是能够灵活运用的人或许不多。利用Set数据结构我们能够轻松的去重一个数组，比如： 12345let arr = [1, 2, 2, 3];let set = new Set(arr);let newArr = Array.from(set); // Array.from方法可以将 Set 结构转为数组。console.log(newArr); // [1, 2, 3] 2. Object.assign()Object.assign()也是ES6中提供的对象的扩展方法，其可以用于对象的合并拷贝，比如： 12345let obj1 = &#123;a: 1&#125;;let obj2 = &#123;b: 2&#125;;let obj3 = Object.assign(&#123;&#125;, obj1, obj2);console.log(obj3); // &#123;a: 1, b: 2&#125; 3. map()map方法用于遍历数组，有返回值，可以对数组的每一项进行操作并生成一个新的数组，有些时候可以代替for和forEach循环，简化代码，比如： 12345let arr3 = [1, 2, 3, 4, 5];let newArr3 = arr3.map((e, i) =&gt; e * 10); // 给数组每一项乘以10console.log(newArr3); // [10, 20, 30, 40, 50] 4. filter()filter方法同样用于遍历数组，顾名思义，就是过滤数组，在每一项元素后面触发一个回调函数，通过判断，保留或移除当前项，最后返回一个新的数组，比如： 12345let arr4 = [1, 2, 3, 4, 5];let newArr4 = arr4.filter((e, i) =&gt; e % 2 === 0); // 取模，过滤余数不为0的数console.log(newArr4); // [2，4] 5. some()some方法用于遍历数组，在每一项元素后面触发一个回调函数，只要一个满足条件就返回true，否则返回false，类似于 || 比较，比如： 12345let arr5 = [&#123;result: true&#125;, &#123;result: false&#125;];let newArr5 = arr5.some((e, i) =&gt; e.result); // 只要一个为true，即为trueconsole.log(newArr5); // true 6.every()every方法用于遍历数组，在每一项元素后面触发一个回调函数，只要一个不满足条件就返回false，否则返回true，类似于 &amp;&amp; 比较，比如： 12345let arr6 = [&#123;result: true&#125;, &#123;result: false&#125;];let newArr6 = arr6.every((e, i) =&gt; e.result); // 只要一个为false，即为falseconsole.log(newArr6); // false 7. ~~运算符~符号用在JavaScript中有按位取反的作用，~~即是取反两次，而位运算的操作值要求是整数，其结果也是整数，所以经过位运算的都会自动变成整数，可以巧妙的去掉小数部分，类似于parseInt，比如： 12345let a = 1.23;let b = -1.23;console.log(~~a); // 1console.log(~~b); // -1 8. ||运算符巧妙的使用 || 运算符我们可以给变量设置默认值，比如： 1234let c = 1;let d = c || 2; // 如果c的值为true则取存在的值，否则为2console.log(d); // 1 9. …运算符…运算符是ES6中用于解构数组的方法，可以用于快速获取数组的参数，比如： 1234let [num1, ...nums] = [1, 2, 3];console.log(num1); // 1console.log(nums); // [2, 3] 10. 三元运算符该运算符应该大家都比较熟悉，在默写情况下可以简化if else的写法，比如： 1234567891011let e = true, f = '';if (e) &#123; f = 'man';&#125; else &#123; f = 'woman';&#125;// 等同于e ? f = 'man' : f = 'woman'; 结语 本文只列出了JavaScript语法中比较常见的10点提升编码效率的方法进行了简单地阐述，当然每一个知识点都可以进行相应的展开与探究，希望大家在巧学的同时达到巧用的效果。 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>前言</p>\n<p>由于工作和生活上的一些变化，最近写文章的频率有点下降了，实在不好意思，不过相信不久就会慢慢恢复过来，感谢大家一直以来的关注和支持。</p>\n<p>本文主要给大家分享一下在编写JavaScript代码的时候存在的一些方法和技巧，虽然有时候条条大路都通向罗马，但是也许总会有那么一条最短的路径可走。希望通过以下几点JavaScript技巧让大家的代码“化繁为简，化简为精”。<br><a id=\"more\"></a><br><strong>巧学巧用</strong></p>\n<h3 id=\"1-new-Set\"><a href=\"#1-new-Set\" class=\"headerlink\" title=\"1. new Set()\"></a>1. new Set()</h3><p>可能有人知道ES6中提供了新的数据结构 Set，但是能够灵活运用的人或许不多。利用Set数据结构我们能够轻松的去重一个数组，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"><span class=\"keyword\">let</span> set = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>(arr);</div><div class=\"line\"><span class=\"keyword\">let</span> newArr = <span class=\"built_in\">Array</span>.from(set); <span class=\"comment\">// Array.from方法可以将 Set 结构转为数组。</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(newArr); <span class=\"comment\">// [1, 2, 3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"2-Object-assign\"><a href=\"#2-Object-assign\" class=\"headerlink\" title=\"2. Object.assign()\"></a>2. Object.assign()</h3><p>Object.assign()也是ES6中提供的对象的扩展方法，其可以用于对象的合并拷贝，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> obj1 = &#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> obj2 = &#123;<span class=\"attr\">b</span>: <span class=\"number\">2</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">let</span> obj3 = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, obj1, obj2);</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj3); <span class=\"comment\">// &#123;a: 1, b: 2&#125;</span></div></pre></td></tr></table></figure>\n<h3 id=\"3-map\"><a href=\"#3-map\" class=\"headerlink\" title=\"3. map()\"></a>3. map()</h3><p>map方法用于遍历数组，有返回值，可以对数组的每一项进行操作并生成一个新的数组，有些时候可以代替for和forEach循环，简化代码，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr3 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> newArr3 = arr3.map(<span class=\"function\">(<span class=\"params\">e, i</span>) =&gt;</span> e * <span class=\"number\">10</span>); <span class=\"comment\">// 给数组每一项乘以10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(newArr3); <span class=\"comment\">// [10, 20, 30, 40, 50]</span></div></pre></td></tr></table></figure>\n<h3 id=\"4-filter\"><a href=\"#4-filter\" class=\"headerlink\" title=\"4. filter()\"></a>4. filter()</h3><p>filter方法同样用于遍历数组，顾名思义，就是过滤数组，在每一项元素后面触发一个回调函数，通过判断，保留或移除当前项，最后返回一个新的数组，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr4 = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> newArr4 = arr4.filter(<span class=\"function\">(<span class=\"params\">e, i</span>) =&gt;</span> e % <span class=\"number\">2</span> === <span class=\"number\">0</span>); <span class=\"comment\">// 取模，过滤余数不为0的数</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(newArr4); <span class=\"comment\">// [2，4]</span></div></pre></td></tr></table></figure>\n<h3 id=\"5-some\"><a href=\"#5-some\" class=\"headerlink\" title=\"5. some()\"></a>5. some()</h3><p>some方法用于遍历数组，在每一项元素后面触发一个回调函数，只要一个满足条件就返回true，否则返回false，类似于 || 比较，比如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr5 = [&#123;<span class=\"attr\">result</span>: <span class=\"literal\">true</span>&#125;, &#123;<span class=\"attr\">result</span>: <span class=\"literal\">false</span>&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> newArr5 = arr5.some(<span class=\"function\">(<span class=\"params\">e, i</span>) =&gt;</span> e.result); <span class=\"comment\">// 只要一个为true，即为true</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(newArr5); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<h3 id=\"6-every\"><a href=\"#6-every\" class=\"headerlink\" title=\"6.every()\"></a>6.every()</h3><p>every方法用于遍历数组，在每一项元素后面触发一个回调函数，只要一个不满足条件就返回false，否则返回true，类似于 &amp;&amp; 比较，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> arr6 = [&#123;<span class=\"attr\">result</span>: <span class=\"literal\">true</span>&#125;, &#123;<span class=\"attr\">result</span>: <span class=\"literal\">false</span>&#125;];</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">let</span> newArr6 = arr6.every(<span class=\"function\">(<span class=\"params\">e, i</span>) =&gt;</span> e.result); <span class=\"comment\">// 只要一个为false，即为false</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(newArr6); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<h3 id=\"7-运算符\"><a href=\"#7-运算符\" class=\"headerlink\" title=\"7. ~~运算符\"></a>7. ~~运算符</h3><p>~符号用在JavaScript中有按位取反的作用，~~即是取反两次，而位运算的操作值要求是整数，其结果也是整数，所以经过位运算的都会自动变成整数，可以巧妙的去掉小数部分，类似于parseInt，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1.23</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"number\">-1.23</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(~~a); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(~~b); <span class=\"comment\">// -1</span></div></pre></td></tr></table></figure>\n<h3 id=\"8-运算符\"><a href=\"#8-运算符\" class=\"headerlink\" title=\"8. ||运算符\"></a>8. ||运算符</h3><p>巧妙的使用 || 运算符我们可以给变量设置默认值，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> c = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">let</span> d = c || <span class=\"number\">2</span>; <span class=\"comment\">// 如果c的值为true则取存在的值，否则为2</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(d); <span class=\"comment\">// 1</span></div></pre></td></tr></table></figure>\n<h3 id=\"9-…运算符\"><a href=\"#9-…运算符\" class=\"headerlink\" title=\"9. …运算符\"></a>9. …运算符</h3><p>…运算符是ES6中用于解构数组的方法，可以用于快速获取数组的参数，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> [num1, ...nums] = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(num1); <span class=\"comment\">// 1</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(nums); <span class=\"comment\">// [2, 3]</span></div></pre></td></tr></table></figure>\n<h3 id=\"10-三元运算符\"><a href=\"#10-三元运算符\" class=\"headerlink\" title=\"10. 三元运算符\"></a>10. 三元运算符</h3><p>该运算符应该大家都比较熟悉，在默写情况下可以简化if else的写法，比如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">let</span> e = <span class=\"literal\">true</span>,</div><div class=\"line\">    f = <span class=\"string\">''</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (e) &#123;</div><div class=\"line\">    f = <span class=\"string\">'man'</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    f = <span class=\"string\">'woman'</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 等同于</span></div><div class=\"line\">e ? f = <span class=\"string\">'man'</span> : f = <span class=\"string\">'woman'</span>;</div></pre></td></tr></table></figure>\n<p>结语</p>\n<p>本文只列出了JavaScript语法中比较常见的10点提升编码效率的方法进行了简单地阐述，当然每一个知识点都可以进行相应的展开与探究，希望大家在巧学的同时达到巧用的效果。</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"前言 由于工作和生活上的一些变化，最近写文章的频率有点下降了，实在不好意思，不过相信不久就会慢慢恢复过来，感谢大家一直以来的关注和支持。 本文主要给大家分享一下在编写JavaScript代码的时候存在的一些方法和技巧，虽然有时候条条大路都通向罗马，但是也许总会有那么一条最短的路径可走。希望通过以下几点JavaScript技巧让大家的代码“化繁为简，化简为精”。","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.pengmengshan.cn/blog/tags/javascript/"}]},{"title":"西塘游随笔","date":"2017-04-17T01:42:35.000Z","path":"2017/04/17/20170417/","text":"周末放假出去上海周边的西塘古镇玩了玩，哈哈有句话说得好 听别人说的再好不如自己去尝试 ~ 先来张图片镇楼 从上海南站做的大巴车票价36元 差不多一个小时到西塘的车站 ，大巴车站到景区一公里多点 直接走路过去的 车站旁边也有很多人力三轮 哈哈 价格就不知道了 。 古镇不大，邮电东路是古镇最热闹的一条路 贯穿古镇,镇上有家电影院 周六在哪家电影院看的速度与激情8价格还是蛮便宜的 ，到了西塘先去事先定好的酒店 一路走过来 路边都是名宿 客栈 饭馆 发展的很成熟 游客也很多 其实我是不太喜欢到 发展太成熟的地方~ 看完电影去景区逛了下 门票100 真么特贵，也就那个样子和七宝老街差不多 向来对古镇无感 逛了逛也没怎么拍照 但是 妹子很多啊 哈哈哈 这种地方还是妹子去的多 ~ 沉迷了一个星期的王者荣耀今天戒了，发现不玩游戏时间多出来好多 在过两个星期又到五一了 时间飞逝 这几天上海好热都二十来度 一夜入夏 路上行人都已经穿上夏装 就说这么多了 开始搬砖了~ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=202373&auto=0&height=66\"></iframe>\n\n<p>周末放假出去上海周边的西塘古镇玩了玩，哈哈有句话说得好 听别人说的再好不如自己去尝试 ~  先来张图片镇楼</p>\n<p><img src=\"http://oo0pbw6u4.bkt.clouddn.com/IMG_1872.jpg\" alt=\"\"></p>\n<p>从上海南站做的大巴车票价36元 差不多一个小时到西塘的车站 ，大巴车站到景区一公里多点 直接走路过去的 车站旁边也有很多人力三轮 哈哈 价格就不知道了 。</p>\n<a id=\"more\"></a>\n<p>古镇不大，邮电东路是古镇最热闹的一条路 贯穿古镇,镇上有家电影院 周六在哪家电影院看的速度与激情8价格还是蛮便宜的 ，到了西塘先去事先定好的酒店 一路走过来 路边都是名宿 客栈 饭馆 发展的很成熟 游客也很多 其实我是不太喜欢到 发展太成熟的地方~</p>\n<p>看完电影去景区逛了下 门票100 真么特贵，也就那个样子和七宝老街差不多 向来对古镇无感 逛了逛也没怎么拍照 但是 妹子很多啊 哈哈哈 这种地方还是妹子去的多 ~</p>\n<p>沉迷了一个星期的王者荣耀今天戒了，发现不玩游戏时间多出来好多 在过两个星期又到五一了 时间飞逝 这几天上海好热都二十来度 一夜入夏 路上行人都已经穿上夏装 就说这么多了 开始搬砖了~</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"周末放假出去上海周边的西塘古镇玩了玩，哈哈有句话说得好 听别人说的再好不如自己去尝试 ~ 先来张图片镇楼 从上海南站做的大巴车票价36元 差不多一个小时到西塘的车站 ，大巴车站到景区一公里多点 直接走路过去的 车站旁边也有很多人力三轮 哈哈 价格就不知道了 。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.pengmengshan.cn/blog/tags/随笔/"},{"name":"游记","slug":"游记","permalink":"http://www.pengmengshan.cn/blog/tags/游记/"}]},{"title":"mac上最好用的svn客户端Cornerstone","date":"2017-04-13T08:37:52.000Z","path":"2017/04/13/it-macsvn/","text":"点击我下载Cornerstone破解版 使用标签：前面几篇文章我介绍SVN服务器的安装，配置，实战。当然其中也加入了一些客户端测试的命令，使用命令当然是一个非常好的选择，但是对我们人类来说还是喜欢图形化界面的操作的。因此本文将介绍我喜欢的一款SVN客户端工具的使用。想要安装的Cornerstone的朋友，我有个坏消息是，如果你想使用它的正版软件，你是需要花费几十美金的，当然这里我带给您的永远都是有价值的好的信息，那就是在我们天朝使用软件还花钱真的是极品，我就奉献一下我在网上找到的一个比较好的破解版：http://pan.baidu.com/s/1o6F31zG这个破解版本的Cornerstone软件安装方法我就不做介绍了，因为太容易。本文重点介绍一下它的使用方法。当你打开软件时候会看到如下图所示界面： 现在是空空如也，因此我们应该做点什么，让它发挥作用。界面还是非常的直观和有引导性的，我直接按灰色区域的“Add repository”完成点击之后会弹出配置界面，一般我们会使用第四个选项卡”SVN Server”.如图图中我对SVN服务器做了访问的svn服务器配置,配置介绍如下：tunnel：访问通道，默认不用修改Server：我的svn服务器在本地，所以Server填写了localhostPort:设置端口号，我在服务器上没有配置访问端口号，所以port留空Repository Path:这个是服务器仓库的目录位置，我这里填写了company，这是因为我在SVN服务的根路径下添加了company仓库。Nickname:显示名。这个可以随便填写，建议为仓库和用户名的组合。如果您的配置正确应该会添加成功的，如果错误，请检查服务器是否开启和你配置是否正确等。 下图是我们添加仓库成功后的效果图：从图中可以看到我昨天写的《SVN服务器配置实战》中的目录结构了。现在我们来试试CorenerStone是如何代替我们的命令行的.下图介绍各个功能模块的作用：四、使用简介1.上传项目到repository可以直接拖动到repository的子文件夹中，或是选择软件上方的Import按钮上传，会弹出选项填写所在位置及名称，然后选择Import即可2.下载项目下载分为两种：Export和Check Out，区别在于，Export后的项目不会与repository中的源文件相关联，是一个独立的版本，而Check Out下来的文件会创建一个working copy，参见步骤三的第一幅图，此文件与库中源文件相关联，当有新版本（他人修改）或是本地修改（自己修改）时，working copy会显示修改数量，白色数量为他人修改数量，灰色数量为本人修改数量所以如果你是项目中的开发人员，可以选择check out，如果只是下载查看，不希望自己的修改影响到整个项目，最好是选择Export3.版本管理每一次提交会创建一个新版本，在repository中会保存所有历史版本，如下图（可通过修改人及提交信息进行检索版本），所以用svn开发可以很好的控制项目出现不可解决及未知bug时代码的修复问题：svn方便了多人开发同一项目的代码合并问题，但是也有一些事项需要注意：①先更新后提交在看到有新版本（即同伴已经提交代码时），先更新代码，直至working copy不再显示白色圈，然后运行代码确定可运行且功能无误之后再commit自己的代码，否则，会造成项目中出现多处冲突或bug，且很难排查原因②完成独立功能后再提交，且务必填写提交信息每完成一个独立的功能，或解决一个bug之后再提交代码，不要连续多次重复提交，造成版本过多过杂，且提交时务必填写提交信息，交代本次完成了什么功能，方便上图中可以进行message的搜索来查看历史版本③冲突文件原则上同一组开发人员最好不要在同一文件中进行操作，但有时候必须去其他文件中进行操作，或者是误操作，如果同时多人在同一文件的同一位置修改代码，后提交的人会出现版本冲突文件，一般会有三个同样名称不同后缀的文件.mine文件：本人所做修改两个.r0XX文件：XX为数字，数字较小的为更改前的文件，较大的为更改后的文件，在文件中会有&lt;&lt;&lt;&lt; mine .r0XX &gt;&gt;&gt;&gt;&gt;等字样包含起来的代码，即冲突的地方，此时请和组内同事讨论或自己删除某部分修改文件后进行调试，修复文件针对ios项目：出现某个工程或文件打不开的情况，如果为.project文件无法打开，则选择显示包内容-&gt;用文稿打开project.pbxproj文件-&gt;搜索.mine，将.mine部分前后&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;包含起来的代码删除，工程就可以打开了，如果build时出现某个xib文件打不开的错误，则选中，用文稿打开，跟上文同样操作即可解决无法build的问题④新添加文件提交时新增加的文件显示为问号状态的，请选中右击后 选择Add to Working Copy之后再commit 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p><a href=\"http://xclient.info/s/cornerstone.html\" target=\"_blank\" rel=\"external\">点击我下载Cornerstone破解版</a></p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>标签：<br>前面几篇文章我介绍SVN服务器的安装，配置，实战。当然其中也加入了一些客户端测试的命令，使用命令当然是一个非常好的选择，但是对我们人类来说还是喜欢图形化界面的操作的。因此本文将介绍我喜欢的一款SVN客户端工具的使用。<br><a id=\"more\"></a><br>想要安装的Cornerstone的朋友，我有个坏消息是，如果你想使用它的正版软件，你是需要花费几十美金的，当然这里我带给您的永远都是有价值的好的信息，那就是在我们天朝使用软件还花钱真的是极品，我就奉献一下我在网上找到的一个比较好的破解版：<a href=\"http://pan.baidu.com/s/1o6F31zG\" target=\"_blank\" rel=\"external\">http://pan.baidu.com/s/1o6F31zG</a><br>这个破解版本的Cornerstone软件安装方法我就不做介绍了，因为太容易。本文重点介绍一下它的使用方法。<br>当你打开软件时候会看到如下图所示界面：</p>\n<p><img src=\"https://ss0.baidu.com/6LVYsjip0QIZ8Aqbn9fN2DC/timg?pa&amp;quality=100&amp;size=w4096&amp;sec=1492056426&amp;di=0294f63bef43eef6328b8d99e4af51d4&amp;ref=http%3A%2F%2Fwww%2Emamicode%2Ecom%2Finfo%2Ddetail%2D1123118%2Ehtml&amp;src=http%3A%2F%2Fimages2015%2Ecnblogs%2Ecom%2Fblog%2F119556%2F201511%2F119556%2D20151121002400374%2D2081596969%2Epng\" alt=\"\"><br>现在是空空如也，因此我们应该做点什么，让它发挥作用。界面还是非常的直观和有引导性的，我直接按灰色区域的“Add repository”<br><img src=\"https://ss0.baidu.com/6LVYsjip0QIZ8Aqbn9fN2DC/timg?pa&amp;quality=100&amp;size=w4096&amp;sec=1492056426&amp;di=58381f52b11ca4eb47d1caaf11bd3414&amp;ref=http%3A%2F%2Fwww%2Emamicode%2Ecom%2Finfo%2Ddetail%2D1123118%2Ehtml&amp;src=http%3A%2F%2Fimages2015%2Ecnblogs%2Ecom%2Fblog%2F119556%2F201511%2F119556%2D20151121002418765%2D1837537103%2Epng\" alt=\"\"><br>完成点击之后会弹出配置界面，一般我们会使用第四个选项卡”SVN Server”.如图<br>图中我对SVN服务器做了访问的svn服务器配置,配置介绍如下：<br><img src=\"https://ss0.baidu.com/6LVYsjip0QIZ8Aqbn9fN2DC/timg?pa&amp;quality=100&amp;size=w4096&amp;sec=1492056426&amp;di=1b68139cf0ebf06c72eca967a63557fb&amp;ref=http%3A%2F%2Fwww%2Emamicode%2Ecom%2Finfo%2Ddetail%2D1123118%2Ehtml&amp;src=http%3A%2F%2Fimages2015%2Ecnblogs%2Ecom%2Fblog%2F119556%2F201511%2F119556%2D20151121002453108%2D1013518228%2Epng\" alt=\"\"><br>tunnel：访问通道，默认不用修改<br>Server：我的svn服务器在本地，所以Server填写了localhost<br>Port:设置端口号，我在服务器上没有配置访问端口号，所以port留空<br>Repository Path:这个是服务器仓库的目录位置，我这里填写了company，这是因为我在SVN服务的根路径下添加了company仓库。<br>Nickname:显示名。这个可以随便填写，建议为仓库和用户名的组合。<br>如果您的配置正确应该会添加成功的，如果错误，请检查服务器是否开启和你配置是否正确等。 下图是我们添加仓库成功后的效果图：<br><img src=\"https://ss0.baidu.com/6LVYsjip0QIZ8Aqbn9fN2DC/timg?pa&amp;quality=100&amp;size=w4096&amp;sec=1492056426&amp;di=38cbd86f4e745649763ed6590ca5f83a&amp;ref=http%3A%2F%2Fwww%2Emamicode%2Ecom%2Finfo%2Ddetail%2D1123118%2Ehtml&amp;src=http%3A%2F%2Fimages2015%2Ecnblogs%2Ecom%2Fblog%2F119556%2F201511%2F119556%2D20151121002744733%2D689360189%2Epng\" alt=\"\"><br>从图中可以看到我昨天写的《SVN服务器配置实战》中的目录结构了。<br>现在我们来试试CorenerStone是如何代替我们的命令行的.下图介绍各个功能模块的作用：<br><img src=\"https://ss0.baidu.com/6LVYsjip0QIZ8Aqbn9fN2DC/timg?pa&amp;quality=100&amp;size=w4096&amp;sec=1492056426&amp;di=aa7daa9418300b710518f01477a49b6e&amp;ref=http%3A%2F%2Fwww%2Emamicode%2Ecom%2Finfo%2Ddetail%2D1123118%2Ehtml&amp;src=http%3A%2F%2Fimages2015%2Ecnblogs%2Ecom%2Fblog%2F119556%2F201511%2F119556%2D20151121002820874%2D871984781%2Epng\" alt=\"\"><br>四、使用简介<br>1.上传项目到repository<br>可以直接拖动到repository的子文件夹中，或是选择软件上方的Import按钮上传，会弹出选项填写所在位置及名称，然后选择Import即可<br>2.下载项目<br>下载分为两种：Export和Check Out，区别在于，Export后的项目不会与repository中的源文件相关联，是一个独立的版本，而Check Out下来的文件会创建一个working copy，参见步骤三的第一幅图，此文件与库中源文件相关联，当有新版本（他人修改）或是本地修改（自己修改）时，working copy会显示修改数量，白色数量为他人修改数量，灰色数量为本人修改数量<br>所以如果你是项目中的开发人员，可以选择check out，如果只是下载查看，不希望自己的修改影响到整个项目，最好是选择Export<br>3.版本管理<br>每一次提交会创建一个新版本，在repository中会保存所有历史版本，如下图（可通过修改人及提交信息进行检索版本），所以用svn开发可以很好的控制项目出现不可解决及未知bug时代码的修复问题：<br>svn方便了多人开发同一项目的代码合并问题，但是也有一些事项需要注意：<br>①先更新后提交<br>在看到有新版本（即同伴已经提交代码时），先更新代码，直至working copy不再显示白色圈，然后运行代码确定可运行且功能无误之后再commit自己的代码，否则，会造成项目中出现多处冲突或bug，且很难排查原因<br>②完成独立功能后再提交，且务必填写提交信息<br>每完成一个独立的功能，或解决一个bug之后再提交代码，不要连续多次重复提交，造成版本过多过杂，且提交时务必填写提交信息，交代本次完成了什么功能，方便上图中可以进行message的搜索来查看历史版本<br>③冲突文件<br>原则上同一组开发人员最好不要在同一文件中进行操作，但有时候必须去其他文件中进行操作，或者是误操作，如果同时多人在同一文件的同一位置修改代码，后提交的人会出现版本冲突文件，一般会有三个同样名称不同后缀的文件<br>.mine文件：本人所做修改<br>两个.r0XX文件：XX为数字，数字较小的为更改前的文件，较大的为更改后的文件，在文件中会有&lt;&lt;&lt;&lt; mine .r0XX  &gt;&gt;&gt;&gt;&gt;等字样包含起来的代码，即冲突的地方，此时请和组内同事讨论或自己删除某部分修改文件后进行调试，修复文件<br>针对ios项目：出现某个工程或文件打不开的情况，如果为.project文件无法打开，则选择显示包内容-&gt;用文稿打开project.pbxproj文件-&gt;搜索.mine，将.mine部分前后&lt;&lt;&lt;&lt; &gt;&gt;&gt;&gt;包含起来的代码删除，工程就可以打开了，如果build时出现某个xib文件打不开的错误，则选中，用文稿打开，跟上文同样操作即可解决无法build的问题<br>④新添加文件<br>提交时新增加的文件显示为问号状态的，请选中右击后 选择Add to Working Copy之后再commit</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"点击我下载Cornerstone破解版 使用标签：前面几篇文章我介绍SVN服务器的安装，配置，实战。当然其中也加入了一些客户端测试的命令，使用命令当然是一个非常好的选择，但是对我们人类来说还是喜欢图形化界面的操作的。因此本文将介绍我喜欢的一款SVN客户端工具的使用。","categories":[],"tags":[{"name":"mac","slug":"mac","permalink":"http://www.pengmengshan.cn/blog/tags/mac/"}]},{"title":"2017前端归类","date":"2017-04-12T02:18:13.000Z","path":"2017/04/12/it-2017conclusion/","text":"了解前端实时动态 2016 年崛起的 JS 项目 史上最全的前端资源大汇总 最流行的webpack打包工具 webpack2中文文档 如何使用webpack 请用心练完这16个webpack小例子 node相关 nrm切换npm源 packge.json字段详解 学习 javascript基础到进阶 工作中常用的插件 es6官网 正则表达式 移动端小技巧 全面理解git 兴趣历史谈资小说 javascript promise小红书 es6实战 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<ol>\n<li><p><strong>了解前端实时动态</strong></p>\n<ol>\n<li><a href=\"https://juejin.im/post/58c5e39c8ac24707200a6cff\" target=\"_blank\" rel=\"external\">2016 年崛起的 JS 项目</a></li>\n<li><a href=\"http://www.jianshu.com/p/6cb49271cd2a#\" target=\"_blank\" rel=\"external\">史上最全的前端资源大汇总</a></li>\n</ol>\n</li>\n</ol>\n<a id=\"more\"></a>\n<ol>\n<li><p><strong>最流行的webpack打包工具</strong></p>\n<ul>\n<li><a href=\"http://www.css88.com/doc/webpack2/\" target=\"_blank\" rel=\"external\">webpack2中文文档</a></li>\n<li><a href=\"https://qiutc.me/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8webpack%E2%80%94webpack-howto.html\" target=\"_blank\" rel=\"external\">如何使用webpack</a></li>\n<li><a href=\"https://juejin.im/post/58edcbda44d904005774cfb1\" target=\"_blank\" rel=\"external\">请用心练完这16个webpack小例子</a></li>\n</ul>\n</li>\n</ol>\n<ol>\n<li><p><strong>node相关</strong></p>\n<ul>\n<li><a href=\"https://cnodejs.org/topic/5326e78c434e04172c006826\" target=\"_blank\" rel=\"external\">nrm切换npm源</a></li>\n<li><a href=\"http://www.cnblogs.com/tzyy/p/5193811.html\" target=\"_blank\" rel=\"external\">packge.json字段详解</a></li>\n</ul>\n</li>\n<li><p><strong>学习</strong></p>\n<ul>\n<li><a href=\"http://www.jianshu.com/u/10ae59f49b13\" target=\"_blank\" rel=\"external\">javascript基础到进阶</a></li>\n<li><a href=\"https://github.com/jawil/blog/issues/10\" target=\"_blank\" rel=\"external\">工作中常用的插件</a></li>\n<li><a href=\"http://es6.ruanyifeng.com/\" target=\"_blank\" rel=\"external\">es6官网</a></li>\n<li><a href=\"http://louiszhai.github.io/2016/06/13/regexp/\" target=\"_blank\" rel=\"external\">正则表达式</a></li>\n<li><a href=\"http://liujinkai.com/2015/06/06/mobile-web-skill/\" target=\"_blank\" rel=\"external\">移动端小技巧</a></li>\n<li><a href=\"https://juejin.im/post/582bd0b4da2f600063d4f89e\" target=\"_blank\" rel=\"external\">全面理解git</a></li>\n<li><a href=\"http://www.360doc.com/userhome.aspx?userid=18314967\" target=\"_blank\" rel=\"external\">兴趣历史谈资小说</a></li>\n<li><a href=\"http://liubin.org/promises-book/#ch2-promise-all\" target=\"_blank\" rel=\"external\">javascript promise小红书</a></li>\n<li><a href=\"http://gank.io/post/564151c1f1df1210001c9161\" target=\"_blank\" rel=\"external\">es6实战</a></li>\n</ul>\n</li>\n</ol>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"了解前端实时动态 2016 年崛起的 JS 项目 史上最全的前端资源大汇总","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://www.pengmengshan.cn/blog/tags/js/"},{"name":"学习","slug":"学习","permalink":"http://www.pengmengshan.cn/blog/tags/学习/"}]},{"title":"node-sass的正确安装姿势","date":"2017-04-11T01:26:38.000Z","path":"2017/04/11/it-node-sass/","text":"安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit） 方法一：使用淘宝镜像直接运行下面的命令即可： 1SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass 我们可能更希望能直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件： sass_binary_site=https://npm.taobao.org/mirrors/node-sass/ phantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/ electron_mirror=https://npm.taobao.org/mirrors/electron/ registry=https://registry.npm.taobao.org 这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。 方法二：使用梯子假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com 加入 PAC 列表）： npm config set proxy http://127.0.0.1:1080 npm i node-sass 下载完成后删除 http 代理npm config delete proxy 原文链接 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<blockquote>\n<p>安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。<br>首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit）</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"方法一：使用淘宝镜像\"><a href=\"#方法一：使用淘宝镜像\" class=\"headerlink\" title=\"方法一：使用淘宝镜像\"></a>方法一：使用淘宝镜像</h3><p>直接运行下面的命令即可：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">SASS_BINARY_SITE=https://npm.taobao.org/mirrors/node-sass/ npm install node-sass</div></pre></td></tr></table></figure>\n<p>我们可能更希望能直接使用 npm install 安装所有依赖，所以我的做法是在项目内添加一个 .npmrc 文件：</p>\n<pre><code>sass_binary_site=https://npm.taobao.org/mirrors/node-sass/\nphantomjs_cdnurl=https://npm.taobao.org/mirrors/phantomjs/\nelectron_mirror=https://npm.taobao.org/mirrors/electron/\nregistry=https://registry.npm.taobao.org\n</code></pre><p>这样使用 npm install 安装 node-sass、electron 和 phantomjs 时都能自动从淘宝源上下载，但是在使用 npm publish 的时候要把 registry 这一行给注释掉，否则就会发布到淘宝源上去了。</p>\n<h3 id=\"方法二：使用梯子\"><a href=\"#方法二：使用梯子\" class=\"headerlink\" title=\"方法二：使用梯子\"></a>方法二：使用梯子</h3><p>假设你的梯子在你本地机器上开启了一个第三方服务器 127.0.0.1:1080，那么只需按照下面的方法配置一下就能正常安装 node-sass 了（如果你开启的是 PAC 模式而不是全局模式，那还需要将 s3.amazonaws.com 加入 PAC 列表）：</p>\n<pre><code>npm config set proxy http://127.0.0.1:1080\nnpm i node-sass\n</code></pre><h3 id=\"下载完成后删除-http-代理\"><a href=\"#下载完成后删除-http-代理\" class=\"headerlink\" title=\"下载完成后删除 http 代理\"></a>下载完成后删除 http 代理</h3><pre><code>npm config delete proxy\n</code></pre><p><a href=\"https://github.com/lmk123/blog/issues/28\" target=\"_blank\" rel=\"external\">原文链接</a></p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n","excerpt":"安装 node-sass 的时候总是会各种不成功，今天我琢磨了一会儿总算知道要怎么解决了。首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。（顺带一提，你可以看看这个好玩的 commit）","categories":[],"tags":[{"name":"环境","slug":"环境","permalink":"http://www.pengmengshan.cn/blog/tags/环境/"}]},{"title":"javascript this学习之路","date":"2017-04-10T08:26:00.000Z","path":"2017/04/10/it-this/","text":"this是javascript的核心之一，this的指向之前都是一知半解不是很了解，今天看了简书上看了篇文章对js中this讲的很清楚，后面我简单的分享下我的学习笔记 javascript this的指向是面试中必问的问题，之前在百度上看this相关的文章都是写的很高深莫测，看完和没看一样 。今天的笔记参考这篇文章-&gt;全方位解读this 感觉本文作者让我对this有个新的认识 案例1 1234567891011var a = 10;var obj = &#123; a: 20&#125;function fn () &#123; console.log(this.a); // fn() == window.fn() 这里this指向window&#125;fn(); // 10fn.call(obj); // 20 call 可以改变this指向 这里this指向obj 在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 案例2 1234567891011var a = 20;var obj = &#123; a: 10, c: this.a + 20, fn: function () &#123; return this.a; &#125;&#125;console.log(obj.c); // 40 obj.c 不是一个函数 这里的this指向windowconsole.log(obj.fn()); // 10 fn被obj拥有 this指向obj 当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。可运行下面的例子查看区别。 多来几个案列熟练下 1234567891011var a = 20;var foo = &#123; a: 10, getA: function () &#123; return this.a; &#125;&#125;console.log(foo.getA()); // 10var test = foo.getA;console.log(test()); // 20 foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。 下面两个案列看看 123456789var a = 20;function getA() &#123; return this.a;&#125;var foo = &#123; a: 10, getA: getA&#125;console.log(foo.getA()); // 10 123456789101112131415function foo() &#123; console.log(this.a)&#125;function active(fn) &#123; fn(); // 真实调用者，为独立调用&#125;var a = 20;var obj = &#123; a: 10, getA: foo&#125;active(obj.getA); //20 这里this没有被拥有 this指向window 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<blockquote>\n<p>this是javascript的核心之一，this的指向之前都是一知半解不是很了解，今天看了简书上看了篇文章对js中this讲的很清楚，后面我简单的分享下我的学习笔记</p>\n</blockquote>\n<p>javascript this的指向是面试中必问的问题，之前在百度上看this相关的文章都是写的很高深莫测，看完和没看一样 。今天的笔记参考这篇文章-&gt;<a href=\"http://www.jianshu.com/p/d647aa6d1ae6\" target=\"_blank\" rel=\"external\">全方位解读this</a> 感觉本文作者让我对this有个新的认识</p>\n<a id=\"more\"></a>\n<p>案例1</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">10</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">20</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a); <span class=\"comment\">// fn() == window.fn() 这里this指向window</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">fn(); <span class=\"comment\">// 10</span></div><div class=\"line\">fn.call(obj); <span class=\"comment\">// 20  call 可以改变this指向 这里this指向obj</span></div></pre></td></tr></table></figure>\n<p><strong>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。</strong></p>\n<p>案例2</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">10</span>,</div><div class=\"line\">    <span class=\"attr\">c</span>: <span class=\"keyword\">this</span>.a + <span class=\"number\">20</span>,</div><div class=\"line\">    <span class=\"attr\">fn</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.c);  <span class=\"comment\">// 40 obj.c 不是一个函数 这里的this指向window</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(obj.fn()); <span class=\"comment\">// 10 fn被obj拥有 this指向obj</span></div></pre></td></tr></table></figure>\n<p><strong>当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。可运行下面的例子查看区别。</strong></p>\n<p>多来几个案列熟练下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">10</span>,</div><div class=\"line\">    <span class=\"attr\">getA</span>: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.getA()); <span class=\"comment\">// 10</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> test = foo.getA;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(test());  <span class=\"comment\">// 20</span></div></pre></td></tr></table></figure>\n<p><code>foo.getA()</code>中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而<code>test()</code>作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。</p>\n<p>下面两个案列看看</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getA</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">10</span>,</div><div class=\"line\">    <span class=\"attr\">getA</span>: getA</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(foo.getA());  <span class=\"comment\">// 10</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">active</span>(<span class=\"params\">fn</span>) </span>&#123;</div><div class=\"line\">    fn(); <span class=\"comment\">// 真实调用者，为独立调用</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">20</span>;</div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">a</span>: <span class=\"number\">10</span>,</div><div class=\"line\">    <span class=\"attr\">getA</span>: foo</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">active(obj.getA); <span class=\"comment\">//20 这里this没有被拥有 this指向window</span></div></pre></td></tr></table></figure>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n\n","excerpt":"this是javascript的核心之一，this的指向之前都是一知半解不是很了解，今天看了简书上看了篇文章对js中this讲的很清楚，后面我简单的分享下我的学习笔记 javascript this的指向是面试中必问的问题，之前在百度上看this相关的文章都是写的很高深莫测，看完和没看一样 。今天的笔记参考这篇文章-&gt;全方位解读this 感觉本文作者让我对this有个新的认识","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://www.pengmengshan.cn/blog/tags/javascript/"}]},{"title":"在这个节奏飞快的时代我该如何学习？","date":"2017-04-10T02:37:29.000Z","path":"2017/04/10/learnchannel/","text":"心理学家罗洛梅说：“焦虑是人类面对威胁，希望创造自我的正常状态。在这样一个高速发展的时代，焦虑的人才是真的健康、感觉到时代脉搏的人。” 互联网时代的职场加剧了两极分化，少部分人获得巨大影响力和资源而迅速崛起；更多的人会被服务得越来越懒，成为平庸的跟随者。也就是说，个人崛起的时代，是一部分“超级个体”崛起，和一大群普通个体追随的时代。 在我们程序员的行业里，大家都知道，想要不被淘汰，就必须让自己处于一个持续学习的阶段。老的知识与技术，会很快的被新的淹没在历史的尘埃里。和其他行业不同，程序员是能够在短期内直观感受到行业变化的。 我是一个半路出家的前端工程师，工作了两三年工作碰到瓶颈，如何去提升自己，在这个技术高速发展的时代，生活每天都充满了焦虑，不学习就会落后，落后机会挨打 so 我们要不断学习不让自己活在舒适区域 ~ 1 语言表达能力太差，每天写篇博客提升自己的词汇量和提升自己的写作能力2 每天浏览技术社区的博客看看人家怎么学习 有哪些问题自己碰到过没有解决的 学习方法 80%时间学习 专业技能 专业技能是我们生活的保障 10%时间学习 哲理 哲理能给我们带来信仰 5% 社会热点 让自己与时俱进时刻了社会上最新的热点头条 5% 其他类 学习渠道 掘金 简书 知乎 cnode 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<blockquote>\n<p>心理学家罗洛梅说：“焦虑是人类面对威胁，希望创造自我的正常状态。在这样一个高速发展的时代，焦虑的人才是真的健康、感觉到时代脉搏的人。”</p>\n<p>互联网时代的职场加剧了两极分化，少部分人获得巨大影响力和资源而迅速崛起；更多的人会被服务得越来越懒，成为平庸的跟随者。也就是说，个人崛起的时代，是一部分“超级个体”崛起，和一大群普通个体追随的时代。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>在我们程序员的行业里，大家都知道，想要不被淘汰，就必须让自己处于一个持续学习的阶段。老的知识与技术，会很快的被新的淹没在历史的尘埃里。和其他行业不同，程序员是能够在短期内直观感受到行业变化的。</p>\n<p>我是一个半路出家的前端工程师，工作了两三年工作碰到瓶颈，如何去提升自己，在这个技术高速发展的时代，生活每天都充满了焦虑，不学习就会落后，落后机会挨打 so 我们要不断学习不让自己活在舒适区域 ~</p>\n<p>1 语言表达能力太差，每天写篇博客提升自己的词汇量和提升自己的写作能力<br>2 每天浏览技术社区的博客看看人家怎么学习 有哪些问题自己碰到过没有解决的</p>\n<h4 id=\"学习方法\"><a href=\"#学习方法\" class=\"headerlink\" title=\"学习方法\"></a>学习方法</h4><ul>\n<li>80%时间学习 专业技能 专业技能是我们生活的保障</li>\n<li>10%时间学习 哲理 哲理能给我们带来信仰</li>\n<li>5% 社会热点 让自己与时俱进时刻了社会上最新的热点头条</li>\n<li>5% 其他类</li>\n</ul>\n<h4 id=\"学习渠道\"><a href=\"#学习渠道\" class=\"headerlink\" title=\"学习渠道\"></a>学习渠道</h4><ul>\n<li><a href=\"https://juejin.im/timeline\" target=\"_blank\" rel=\"external\">掘金</a></li>\n<li><a href=\"http://www.jianshu.com/\" target=\"_blank\" rel=\"external\">简书</a></li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"external\">知乎</a></li>\n<li><a href=\"https://cnodejs.org/\" target=\"_blank\" rel=\"external\">cnode</a></li>\n</ul>\n<!-- >当我决定成为一名程序员的时候，我对自己是没有多少自信的。\n虽然我的专业是和计算机相关，但是作为一名学渣，眼睁睁的看着大神都是自己的同学，自己那点微薄的基础真的给不了我多少底气。毕业之前我也没有想过自己会走上程序员的道路并且以此为生。\n作为一个学渣，有一个特点就是，很难一瞬间就决定自己未来的路是什么样的，并且坚定不移的走下去，中间总会遇到各种各样的变故，让自己的未来摇摆不定。\n最开始的时候我不知道自己要成为哪个方向上的程序员。\n学过c语言，不过也仅仅只是能够写一点简单的练习题，能够应付期末考试，并没有任何想法会在工作中使用。\nc++也学过，我依稀记得当初上课的时候，心想这老师讲的真好，居然连我这个不听课的人也能略懂一二，但是因为太难理解，死在了面向对象上。\n再后来还学过c#，当时的老师给我们讲c#被很多人不看好，但是他用他的个人魅力成功忽悠了一群学霸到他的实验室，学些c#。\n甚至差点学Object-c。Object-c的老师，是一个胖胖的老师，第一节课就给我讲了一个做苹果开发人才难求的故事。说他的学生，只懂Object-c的基本语法，被某企业以8000员的高薪聘请，并且寄予他学习机会。当时已经对毕业的薪资有了一点粗浅的认识，因此我的第一反应是这老师在吹牛逼，甚至不削一顾，也以为这样，后来都逃课了。直到毕业之后，班上出现几个搞苹果开发的高富帅，我才知道，这老师并没有吹牛。\n快要大四的时候，我才幡然醒悟，这样玩下去不行，工作都找不到了。了解了很多，听说java很流行，工作很好找，于是找了很多资源，下载了李兴华老师的java视频教程，开始学习。可是每段视频至少有40分钟，光是基础就有100多集，到最后还有3大流氓框架的几十集，然后才是web实战开发，我一下子就被吓到了，我的天，要毕业了，来不及了。抱着诚惶诚恐的心态，学习了50多集，坚持不下去了。\n后来有个人跑来跟我说，php简单，上手快。经过多方资源分析，最后锁定了php100的网站，上面有免费的视频教程。可是，前三集将开发环境配置，我就直接受不了了，因为听不懂。\n没错，学渣就是这么容易半途而废，一事无成。\n机缘巧合之下，乱点点到了miaov课堂的官方网站，那个时候的网站还是老版本，可是炫酷的动画有点吸引人，再看了看免费视频，卧槽，这老师讲的可以，我还听得懂，经过长期的心理挣扎之后，下定决心要学点东西，就花光所有积蓄，买了他们的视频光碟。[坑爹的是，现在只需要100块钱就能成为会员，那个时候从牙缝里面挤出来的钱，吃了多少个月的泡面我都记不清了，我那个气啊]。\n视频很好，讲的是html，css，和js，卧槽，这东西可以，不需要学习无穷无尽的基础知识就能在网页上搞出一些东西来，不用配置我翻来覆去搞不明白的环境配置。看着这个视频列表，我甚至自信在看完这段视频之后，就立马化身前端大神，无所不能。带着这样的幻想，开始走向了立志成为前端工程师的道路。\n但是故事到这里，你认为我会顺理成章的努力，然后成为一名合格的程序员，那你就对学渣太不了解了。\n事情并未有什么顺利可言。作为一名学渣，有太多的性格弱点。爱幻想。我幻想有一个莫名其妙的神奇的机会，让我从此化身高富帅，迎娶白富美，出任CEO，走向人生巅峰。好高骛远。这个知识点还没有掌握，已经迫不及待的想去学习另外一个知识点。自控力弱，难以合理管理自己的时间等等。虽然后来找到了一份工作，我甚至认为我不需要在继续学习了。因此工作了一年，依然是一个学渣，虽然能够处理工作的内容，但是却少有进步。\n有的时候，醒悟总是需要一些契机的。当我还在埋头lol的时候，周围同学的薪水已经陆续破万，那些远走北京的同学，更是让我望尘莫及。后来听了很多故事，加上人也不是读书时候那么肆无忌惮的浪费时间，开始疯狂学习很多东西。可是学渣本质上很多东西是难以改变的，比如好高骛远。学习并不是那么顺利。甚至被很多从未听说过的东西吓到了。bootstrap，angularjs，requirejs, gulp,seajs, gruntjs，sass, less, 什么性能检测，单元检测，什么模块化，什么mvvm，什么nodejs，git。就连编辑器都那么陌生那么高大上，什么Sublime，什么vim，一大堆从来没有听说过的东西。我就想疯狂的学习这些东西，可是一个东西也没有掌握好。\n在朋友的介绍下，在北京找到了一份工作。很多新奇的东西，我也第一次意识到英语是那么的重要，可是一个学渣英语又能好到哪里去呢？单词量还没有初中的时候高呢。\n我学了很多东西，也忘了很多东西，最后可以说是什么也没有学到，我收藏了大量的文章，学习网址，然而并没有什么用。虽然来了北京，可是这边的大神太多了，我的同学作为一个大神被人尊敬，而我却任然是一个学渣连自己都觉得自己抬不起头来。后来组长找我谈话，他说希望我能主动点，多多练习，让那些似懂非懂的东西能够熟练起来。不要步子迈太大。\n我内心是痛苦的，当一个学渣混迹在大神堆里，感觉哪里都不适应。后来认真想了很多，也跟同学聊了很多，该怎么学习。我找到了2个关键词。\n  ● 基础\n  ● 慢下来\n我开始去认真阅读《Javascript高级编程》，对于我这个长期通过视频教程吸收知识的人来说，通过读书来吸收知识无疑是痛苦的。我甚至诧异原来以前的自己连javascript由哪三大部分组成都不知道，原来自己连基本数据类型和引用数据类型都没有搞清楚，更别说什么作用域链，原型链这些东西了。\n我开始尝试记笔记，我把学到的东西都及时的整理成笔记，保存在github中，我现在甚至认为，只有自己最后记了笔记的东西，才是真正的被我掌握的知识。\n我开始尝试写博文，把自己的笔记，整理出来，写成一篇文章，当然这会花掉我很多时间，但是却能够让我更加透彻的掌握知识点。\n当然，我还必须做大量的练习，并不是别人的文章我看懂了就算学到了，大量的练习必不可少。我也慢慢的感受到了练习带来的好处，那种得心应手的感觉，是以前没有过的。\n我希望以后的自己能够一步一步脚踏实地的学习，外面有大量的知识我没有掌握，就连我几年前买的miaov视频如今都已经出了好多好多的视频，我的电脑都已经装不下，我也没有那么多时间去学习那么多的东西。\n我希望自己以后能够掌握一门后台语言，然后自己写一个自己的网站。\n总之，毕业3年之后的今天，我希望自己能够从0开始，脚踏实地慢慢来，一切都还来得及。\n -->\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n","excerpt":"心理学家罗洛梅说：“焦虑是人类面对威胁，希望创造自我的正常状态。在这样一个高速发展的时代，焦虑的人才是真的健康、感觉到时代脉搏的人。” 互联网时代的职场加剧了两极分化，少部分人获得巨大影响力和资源而迅速崛起；更多的人会被服务得越来越懒，成为平庸的跟随者。也就是说，个人崛起的时代，是一部分“超级个体”崛起，和一大群普通个体追随的时代。","categories":[],"tags":[{"name":"学习","slug":"学习","permalink":"http://www.pengmengshan.cn/blog/tags/学习/"}]},{"title":"Mac iterm2常用快捷键","date":"2017-04-08T07:50:37.000Z","path":"2017/04/08/it-itemr2key/","text":"不会命令行的程序员不会好程序员不是好前端码代码的时候听音乐更有激情哟 早上上班的时候看到地铁站 速度与激情的广告电影中最爱的一个系列 满满的情怀 来首 see you again 回顾下两年前的速7 mac下的命令行工具首推itemr2 为什么推荐itemr2可以看这片文章 快来戳我 下面是itemr2常用的快捷键，会了快捷键妈妈再也不用担心我不会装逼了 标签 新建标签：command + t 关闭标签：command + w 切换标签：command + 数字 command + 左右方向键 切换全屏：command + enter 查找：command + f 分屏 垂直分屏：command + d 水平分屏：command + shift + d 切换屏幕：command + option + 方向键 command + [ 或 command + ] 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 其他 清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 前进后退：ctrl + f/b (相当于左右方向键) 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 清屏1：command + r 清屏2：ctrl + l 自带有哪些很实用的功能/快捷键 ⌘ + 数字在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ctrl + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + shift + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 我常用的一些快捷键 ⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 ⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了 设置方法如下 当然除了这些可以自定义的也不能忘了 Linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 选择喜欢的配色方案。 在Preferences-&gt;Profiles-&gt;Colors的load presets可以选择某个配色方案。也可以自己下载。在网站http://iterm2colorschemes.com/ ，几乎可以找到所有可用的配色方案。 选中即复制iterm2有2种好用的选中即复制模式。 一种是用鼠标，在iterm2中，选中某个路径或者某个词汇，那么，iterm2就自动复制了。 另一种是无鼠标模式，command+f,弹出iterm2的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入tab，查找窗口将自动变化内容，并将其复制。如果输入的是shift+tab，则自动将查找内容的左边选中并复制。 路径重复 在新Tab中自动使用前一Tab路径，如此设置： 系统热键 如下图，设置好系统热线之后，将在正常的浏览器或者编辑器等窗口的上面，以半透明窗口形式直接调出iterm2 shell。 自动完成 输入打头几个字母，然后输入command+; iterm2将自动列出之前输入过的类似命令。 剪切历史 输入command+shift+h，iterm2将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在Preferences &gt; General &gt; Save copy/paste history to disk.中设置。 全屏切换 command+enter进入与返回全屏模式 Exposé所有Tab command+option+e,并且可以搜索 保存当前快照 Window &gt; Save Window Arrangement. 同样，恢复快照： Window &gt; Restore Window Arrangement 可以在Preferences &gt; General &gt; Open saved window arrangement.设置自动恢复快照 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<blockquote>\n<p>不会命令行的程序员不会好程序员不是好前端<br>码代码的时候听音乐更有激情哟</p>\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=33937655&auto=0&height=66\"></iframe>\n\n</blockquote>\n<p>早上上班的时候看到地铁站 速度与激情的广告<br>电影中最爱的一个系列 满满的情怀 来首 see you again 回顾下两年前的速7<br><img src=\"http://oo0pbw6u4.bkt.clouddn.com/IMG_1732.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<p>mac下的命令行工具首推itemr2</p>\n<p>为什么推荐itemr2可以看这片文章 <a href=\"https://www.zhihu.com/question/27447370\" target=\"_blank\" rel=\"external\">快来戳我</a></p>\n<p>下面是itemr2常用的快捷键，会了快捷键妈妈再也不用担心我不会装逼了</p>\n<h3 id=\"标签\"><a href=\"#标签\" class=\"headerlink\" title=\"标签\"></a>标签</h3><ul>\n<li><p>新建标签：command + t</p>\n</li>\n<li><p>关闭标签：command + w</p>\n</li>\n<li><p>切换标签：command + 数字 command + 左右方向键</p>\n</li>\n<li><p>切换全屏：command + enter</p>\n</li>\n<li><p>查找：command + f</p>\n</li>\n</ul>\n<h3 id=\"分屏\"><a href=\"#分屏\" class=\"headerlink\" title=\"分屏\"></a>分屏</h3><ul>\n<li><p>垂直分屏：command + d</p>\n</li>\n<li><p>水平分屏：command + shift + d</p>\n</li>\n<li><p>切换屏幕：command + option + 方向键 command + [ 或 command + ]</p>\n</li>\n<li><p>查看历史命令：command + ;</p>\n</li>\n<li><p>查看剪贴板历史：command + shift + h</p>\n</li>\n</ul>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><ul>\n<li><p>清除当前行：ctrl + u</p>\n</li>\n<li><p>到行首：ctrl + a</p>\n</li>\n<li><p>到行尾：ctrl + e</p>\n</li>\n<li><p>前进后退：ctrl + f/b (相当于左右方向键)</p>\n</li>\n<li><p>上一条命令：ctrl + p</p>\n</li>\n<li><p>搜索命令历史：ctrl + r</p>\n</li>\n<li><p>删除当前光标的字符：ctrl + d</p>\n</li>\n<li><p>删除光标之前的字符：ctrl + h</p>\n</li>\n<li><p>删除光标之前的单词：ctrl + w</p>\n</li>\n<li><p>删除到文本末尾：ctrl + k</p>\n</li>\n<li><p>交换光标处文本：ctrl + t</p>\n</li>\n<li><p>清屏1：command + r</p>\n</li>\n<li><p>清屏2：ctrl + l</p>\n</li>\n</ul>\n<h3 id=\"自带有哪些很实用的功能-快捷键\"><a href=\"#自带有哪些很实用的功能-快捷键\" class=\"headerlink\" title=\"自带有哪些很实用的功能/快捷键\"></a>自带有哪些很实用的功能/快捷键</h3><ul>\n<li><p>⌘ + 数字在各 tab 标签直接来回切换</p>\n</li>\n<li><p>选择即复制 + 鼠标中键粘贴，这个很实用</p>\n</li>\n<li><p>⌘ + f 所查找的内容会被自动复制</p>\n</li>\n<li><p>⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏</p>\n</li>\n<li><p>⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏</p>\n</li>\n<li><p>ctrl + u 清空当前行，无论光标在什么位置</p>\n</li>\n<li><p>输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令</p>\n</li>\n<li><p>⌘ + shift + h 会列出剪切板历史</p>\n</li>\n<li><p>可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现</p>\n</li>\n</ul>\n<h3 id=\"我常用的一些快捷键\"><a href=\"#我常用的一些快捷键\" class=\"headerlink\" title=\"我常用的一些快捷键\"></a>我常用的一些快捷键</h3><ul>\n<li><p>⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了</p>\n</li>\n<li><p>⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e</p>\n</li>\n<li><p>⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了</p>\n</li>\n</ul>\n<h3 id=\"设置方法如下\"><a href=\"#设置方法如下\" class=\"headerlink\" title=\"设置方法如下\"></a>设置方法如下</h3><ul>\n<li><p>当然除了这些可以自定义的也不能忘了 Linux 下那些好用的组合</p>\n</li>\n<li><p>C+a / C+e 这个几乎在哪都可以使用</p>\n</li>\n<li><p>C+p / !! 上一条命令</p>\n</li>\n<li><p>C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行)</p>\n</li>\n<li><p>C+w A+d 从光标处删至字首/尾</p>\n</li>\n<li><p>C+h C+d 删掉光标前后的自负</p>\n</li>\n<li><p>C+y 粘贴至光标后</p>\n</li>\n<li><p>C+r 搜索命令历史，这个较常用</p>\n</li>\n</ul>\n<h3 id=\"选择喜欢的配色方案。\"><a href=\"#选择喜欢的配色方案。\" class=\"headerlink\" title=\"选择喜欢的配色方案。\"></a>选择喜欢的配色方案。</h3><ul>\n<li>在Preferences-&gt;Profiles-&gt;Colors的load presets可以选择某个配色方案。也可以自己下载。在网站<a href=\"http://iterm2colorschemes.com/\" target=\"_blank\" rel=\"external\">http://iterm2colorschemes.com/</a> ，几乎可以找到所有可用的配色方案。</li>\n</ul>\n<h3 id=\"选中即复制\"><a href=\"#选中即复制\" class=\"headerlink\" title=\"选中即复制\"></a>选中即复制</h3><p>iterm2有2种好用的选中即复制模式。</p>\n<ul>\n<li><p>一种是用鼠标，在iterm2中，选中某个路径或者某个词汇，那么，iterm2就自动复制了。</p>\n</li>\n<li><p>另一种是无鼠标模式，command+f,弹出iterm2的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入tab，查找窗口将自动变化内容，并将其复制。如果输入的是shift+tab，则自动将查找内容的左边选中并复制。</p>\n</li>\n</ul>\n<h3 id=\"路径重复\"><a href=\"#路径重复\" class=\"headerlink\" title=\"路径重复\"></a>路径重复</h3><ul>\n<li>在新Tab中自动使用前一Tab路径，如此设置：<br><img src=\"http://img.blog.csdn.net/20160527095312397\" alt=\"\"></li>\n</ul>\n<h3 id=\"系统热键\"><a href=\"#系统热键\" class=\"headerlink\" title=\"系统热键\"></a>系统热键</h3><ul>\n<li>如下图，设置好系统热线之后，将在正常的浏览器或者编辑器等窗口的上面，以半透明窗口形式直接调出iterm2 shell。<br><img src=\"http://img.blog.csdn.net/20160527095435726\" alt=\"\"></li>\n</ul>\n<h3 id=\"自动完成\"><a href=\"#自动完成\" class=\"headerlink\" title=\"自动完成\"></a>自动完成</h3><ul>\n<li>输入打头几个字母，然后输入command+; iterm2将自动列出之前输入过的类似命令。<br><img src=\"http://img.blog.csdn.net/20160527095603804\" alt=\"\"></li>\n</ul>\n<h3 id=\"剪切历史\"><a href=\"#剪切历史\" class=\"headerlink\" title=\"剪切历史\"></a>剪切历史</h3><ul>\n<li>输入command+shift+h，iterm2将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在Preferences &gt; General &gt; Save copy/paste history to disk.中设置。<br><img src=\"http://img.blog.csdn.net/20160527095628398\" alt=\"\"></li>\n</ul>\n<h3 id=\"全屏切换\"><a href=\"#全屏切换\" class=\"headerlink\" title=\"全屏切换\"></a>全屏切换</h3><ul>\n<li>command+enter进入与返回全屏模式</li>\n</ul>\n<h3 id=\"Expose所有Tab\"><a href=\"#Expose所有Tab\" class=\"headerlink\" title=\"Exposé所有Tab\"></a>Exposé所有Tab</h3><ul>\n<li><p>command+option+e,并且可以搜索</p>\n<h3 id=\"保存当前快照\"><a href=\"#保存当前快照\" class=\"headerlink\" title=\"保存当前快照\"></a>保存当前快照</h3></li>\n<li><p>Window &gt; Save Window Arrangement.</p>\n<h3 id=\"同样，恢复快照：\"><a href=\"#同样，恢复快照：\" class=\"headerlink\" title=\"同样，恢复快照：\"></a>同样，恢复快照：</h3></li>\n<li><p>Window &gt; Restore Window Arrangement</p>\n<ul>\n<li>可以在Preferences &gt; General &gt; Open saved window arrangement.设置自动恢复快照</li>\n</ul>\n</li>\n</ul>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n","excerpt":"不会命令行的程序员不会好程序员不是好前端码代码的时候听音乐更有激情哟 早上上班的时候看到地铁站 速度与激情的广告电影中最爱的一个系列 满满的情怀 来首 see you again 回顾下两年前的速7","categories":[],"tags":[{"name":"itemr2","slug":"itemr2","permalink":"http://www.pengmengshan.cn/blog/tags/itemr2/"},{"name":"mac","slug":"mac","permalink":"http://www.pengmengshan.cn/blog/tags/mac/"}]},{"title":"随处可玩的暖场小游戏","date":"2017-04-07T02:50:10.000Z","path":"2017/04/07/outdoor_game/","text":"带团中有时需要搞下气氛,跟客人多做些互动,把客人逗乐了,那么你后面的工作也就得心应手一些喽! 1、一下就是我曾经用过的一个比较好用的小游戏，每人讲一句。第一个人讲:动物园里看动物，第二个人可以讲以下三种中的其中一种: 没有腿的 两条腿的 四条腿的 第二个人讲完后,第三个人就要马上反映出相应的动物依次轮流下去看似简单,却又不是很简单,要有超快的反映能力,还要看你平时对动物世界的关注度.游戏中,会有很多出乎意料的笑点讲错的人就可以让他表演个小节目了 2、游戏规则：把自己名字的最后一个字和（人）字组合在一起 例如：（燕晶）那么就是用名字最后面的（晶）字 和（人）组合在一起 组合在一起就叫（晶人） HO HO ！！（惊人）？呵呵！我名字组合的不错！ 看看大家都成什么（人）了 例子： 高枫（疯人）这属于精神型！ 铭人（名人） 这属于臭美型！ 邓宇（愚人）这属于憨厚型！ 赵梦（蒙人）这属于欺骗型 3、真心话大冒险（可以在车上做的游戏） 如第一个人说你喜欢吃苹果吗？第二人回答喜欢，然后发问你喜欢旅游吗？第三个人回答喜欢，然后再发问你晚上有约会吗？（三不问原则：一不问年龄、二不问收入、三不问晚上吃什么） 4、1-99数字，间隔最小单位10个数，到最后10位时可一个一个数字来，逮到的出节目。让客人参与当中也可做主持人； 5、四个动作-放屁的事情； 6、成语接龙游戏； 7、吃鸡（或吃猪）：每位游客吃鸡的一个部位，大家吃的不能重复，如果吃了别人吃过了的，也可以上台表演个节目啊。。。 8、“吃牛（或猪）”：用“我最喜欢吃牛的xx（身体的某一部分）……”让客人轮番上，把牛身上能吃的都说遍，谁重复了就表演个节目，这个很耗时，也很好玩。吃得没有了，可能会出现吃牛毛，牛便便……如果是40多人的大团，就算了哈！特别要注意一点，遇到团上有少数民族的，像回民不吃猪肉的，肯定不能让客人玩吃猪的游戏哈！ 9、“对歌或讲笑话”：让客人讲笑话或唱歌，可能常会遇到客人不配合，造成冷场。这时可以带动客人来鼓掌（鼓掌的方式有n种），可以让客人学狗叫猫叫啊，让他跟你跟学绕口令之类相对简单的都可以。当然，为了鼓励他们参与，也可以分成几派来做节目（像对歌大赛），派别就很好取名了噻：峨眉派、青城派、岷山派之类的都行。让没参与的人来评判，第一名的适当给点奖励！比如井冈山庐山的明信片啊都可以。 10、“你做我猜”：电视上有的节目，就是一个人比动作或用语言描述，另一个人来猜。可以猜车上的物品，可以猜景区，可以猜一种动作……导游就当裁判，给获胜的一方颁奖——牛肉干一包，或矿泉水一瓶。 11、“新婚之夜”：就是让每一位客人准备一个以数字开头的这种（数字包括一、二、三、百、千、万等，比如“万紫千红”、“一针见血”、“一夫当关，万夫莫开”等就很经典！），把它写在一个本子上，然后记下对应客人的名字，之后导游把本子收回，让对应的客人来读“新婚第一夜，xx（客人姓名）xx（四字的成语）”，这个游戏效果不错哦，现场笑话会有出奇的效果！！在回家的路上用这个，游客们会带笑容离开bus！类似的有“新婚之夜，我和爱人xxxx（aabb格式的词语）”，如果客人说了像重重叠叠、上上下下、前前进进之类的词，效果就更好了！当然，这个度要掌握好。比如团上有小孩子…… 12、“我的屁股”：让客人说词语，格式为aa或abb.例如“我的屁股香喷喷……”“我的屁股红彤彤”都不错，当然，要把话筒给客人，让他自己说。 13、“击鼓传花”：幼儿园小朋友都会玩的游戏，可以用可乐瓶、或导游旗代替手绢，导游在前面唱歌，歌一停，看哪个拿到瓶子（或导游旗）的——表演节目，获得“国宝熊猫玩具”“明信片”一类的奖品；扎气球猜灯谜、谜语——没有人回答时，只要点出活跃分子表演节目，奖品就归他（她）。 14、“车上跳舞”：这里所说的跳舞只是坐在车上。你伸左手，客人就得伸右手，无论你做什么动作，如果有客人和你一样，就输了，就罚唱歌噻！！！ 15、“明七暗七”：所谓明七就是：7、17、27之类的，暗七就是：7的倍数，有时玩的时候还把15也算上，这些都是不能说的数字，轮到了就得跳到下一个数字，15就用手做一个大月亮，如果说错了，就要罚他表演。 16、“青蛙陷阱”：一只青蛙一张嘴，两只眼睛四条腿；两只青蛙两张嘴，四只眼睛八条腿……以此类推，每人一句，量词或数词说错了就要挨罚。 17、“故事接龙”：如果遇到一些综合能力比较强的客人，还可以玩一种“故事接龙”的游戏。导游首先选好一个容易让人产生兴趣的故事情节，当你说出开头部分后，就由客人往下接（要把握好客人接故事的速度和分寸），遇到没有接上的，当然就该他表演节目，导游一定要在其中起到承上启下的作用才行。 18、“词语组合”：准备好纸和笔，发给客人3张白纸，第一张写上姓名，第二张写上地方，第三张写上最爱做事情（地方和事情越夸张越好），分别放进3个袋子里，再让客人抽，形成新组合，会有很多意想不到的有趣事。好处嘛——搞笑，消磨时间长，客人容易接受，如果有小礼品就更好啦，技巧自己掌握。 19、绕口令类：“走一走、扭一扭、见一颗柳树、搂一搂”，第二位就得说：走两走、扭两扭、见两颗柳树、搂两搂。数到十后返回从一开始。游戏规则是谁讲错罚谁出节目。由于是临时发挥，许多人都可能绕不过来，有的人把搂几搂先说了，有的人忘了数字接力，就准备听车内爆发出的阵阵笑声吧。其它的，比如让他们（客人）自己讲家乡，效果不错。当然前提是来自不同地方的散拼团。 20、杀人游戏：不是真的杀人哈，别误会了。这个游戏规则说起来有点长。（省略不详述了） 21、猜地名或人名：客人来自五湖四海，游过大江南北，很多是爱旅游的。那就让他们来猜：金银铜铁——无锡、四季温暖——长春、一路平安——旅顺、重男轻女——贵阳、风平浪静——宁波，赤壁之战——孙悦刘欢、降落伞——张飞、啥子都卖了，就是不卖被子——刘备。国外的也可以，比如“红色庄园”（丹麦）“蓝色的庄稼”（荷兰）。如果客人觉得难度太大，可以适当给点提示。当时，适当的小礼品还是要准备。 22、猜谜语：这个就很多了。比如：一片青草地——打一花名（梅花），来了一只羊——打一水果名（草莓），又来了一只狼——打一水果名（杨莓），又来了一群羊——打一小食品名（喜之郎） 23、脑筋急转弯：1、用左手食指指着车顶，问客人“这是什么？”客人一般会回答“1”，（答案应为“这是食指啦”）用右手做同样的动作再问客人，“这是几？”，客人多半要回答是食指，（答案应为“这是1”），要根据提问来找答案。2、芳芳在学校门口把学生证掉了，怎么办？（捡起来）3、一只饿猫看到老鼠，为什么拔腿就跑？（去追老鼠）。4、太平洋的中间是什么？（水、平）有油灯、暖炉、壁炉，应该先点哪样呢？（火柴） 团里经常会卧虎藏龙的，发现了活跃分子，也有利于推自费项目，操作就不多说了哈！另外，如果客人太散或者年龄差距较大，有时玩游戏就不好操作了。这时，导游的讲解会比较重要，因为客人出来除了游玩，他们特别注重导游对当地文化的讲解，他们更想知道的是有关知识…… 导游在车上进行的游戏问三个问题，第一个问题是：说出你最喜欢乘坐的交通工具，第二个问题：说出你最喜欢的动物。第三个问题是：说出你最爱说的口头禅……说了一圈后，你再说：“我们接下来做一个连环游戏。大家记得自己刚才说的话吗？现在我们将自己刚才说的答案连成一句话。这句话的格式是这样的：我乘做着……（最喜欢的那个交通工具），遇见了……（最爱的那个动物），我对他说：……我爱你。那个动物说：……（你的那个口头禅）笑倒一大片。 大家有都这么聪明，那不如来说个绕口令！我在带汽车团的时候，会和客人说绕口令！比如：“走一步，扭一扭，见到一棵柳树搂一搂”，“走两步，扭两扭，见到两棵柳树搂两楼”……，以此类推，如果客人多的话，到十六步时返回从一开始。要求是客人必须用普通话讲，前面一个人说完，后面的人要紧跟着讲，并且不允许停顿，导游也要参加，谁说不下来，就要表演一个节目！这个游戏看客人的表现！！导游一定要在气氛比较活跃的时候做，效果才会好。比如讲完一个笑话之后。 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<blockquote>\n<p>带团中有时需要搞下气氛,跟客人多做些互动,把客人逗乐了,那么你后面的工作也就得心应手一些喽!</p>\n</blockquote>\n<p>1、一下就是我曾经用过的一个比较好用的小游戏，每人讲一句。第一个人讲:动物园里看动物，第二个人可以讲以下三种中的其中一种:</p>\n<ul>\n<li>没有腿的</li>\n<li>两条腿的</li>\n<li>四条腿的</li>\n</ul>\n<a id=\"more\"></a>\n<p>第二个人讲完后,第三个人就要马上反映出相应的动物<br>依次轮流下去看似简单,却又不是很简单,要有超快的反映能力,还要看你平时对动物世界的关注度.游戏中,会有很多出乎意料的笑点讲错的人就可以让他表演个小节目了</p>\n<p>2、游戏规则：把自己名字的最后一个字和（人）字组合在一起 例如：（燕晶）那么就是用名字最后面的（晶）字 和（人）组合在一起 组合在一起就叫（晶人） HO HO ！！（惊人）？呵呵！我名字组合的不错！ 看看大家都成什么（人）了 例子： 高枫（疯人）这属于精神型！ 铭人（名人） 这属于臭美型！ 邓宇（愚人）这属于憨厚型！ 赵梦（蒙人）这属于欺骗型</p>\n<p>3、真心话大冒险（可以在车上做的游戏）</p>\n<p>如第一个人说你喜欢吃苹果吗？第二人回答喜欢，然后发问你喜欢旅游吗？第三个人回答喜欢，然后再发问你晚上有约会吗？（三不问原则：一不问年龄、二不问收入、三不问晚上吃什么）</p>\n<p>4、1-99数字，间隔最小单位10个数，到最后10位时可一个一个数字来，逮到的出节目。让客人参与当中也可做主持人；</p>\n<p>5、四个动作-放屁的事情；</p>\n<p>6、成语接龙游戏；</p>\n<p>7、吃鸡（或吃猪）：每位游客吃鸡的一个部位，大家吃的不能重复，如果吃了别人吃过了的，也可以上台表演个节目啊。。。</p>\n<p>　　8、“吃牛（或猪）”：用“我最喜欢吃牛的xx（身体的某一部分）……”让客人轮番上，把牛身上能吃的都说遍，谁重复了就表演个节目，这个很耗时，也很好玩。吃得没有了，可能会出现吃牛毛，牛便便……如果是40多人的大团，就算了哈！特别要注意一点，遇到团上有少数民族的，像回民不吃猪肉的，肯定不能让客人玩吃猪的游戏哈！</p>\n<p>　　9、“对歌或讲笑话”：让客人讲笑话或唱歌，可能常会遇到客人不配合，造成冷场。这时可以带动客人来鼓掌（鼓掌的方式有n种），可以让客人学狗叫猫叫啊，让他跟你跟学绕口令之类相对简单的都可以。当然，为了鼓励他们参与，也可以分成几派来做节目（像对歌大赛），派别就很好取名了噻：峨眉派、青城派、岷山派之类的都行。让没参与的人来评判，第一名的适当给点奖励！比如井冈山庐山的明信片啊都可以。</p>\n<p>　　10、“你做我猜”：电视上有的节目，就是一个人比动作或用语言描述，另一个人来猜。可以猜车上的物品，可以猜景区，可以猜一种动作……导游就当裁判，给获胜的一方颁奖——牛肉干一包，或矿泉水一瓶。</p>\n<p>　　11、“新婚之夜”：就是让每一位客人准备一个以数字开头的这种（数字包括一、二、三、百、千、万等，比如“万紫千红”、“一针见血”、“一夫当关，万夫莫开”等就很经典！），把它写在一个本子上，然后记下对应客人的名字，之后导游把本子收回，让对应的客人来读“新婚第一夜，xx（客人姓名）xx（四字的成语）”，这个游戏效果不错哦，现场笑话会有出奇的效果！！在回家的路上用这个，游客们会带笑容离开bus！类似的有“新婚之夜，我和爱人xxxx（aabb格式的词语）”，如果客人说了像重重叠叠、上上下下、前前进进之类的词，效果就更好了！当然，这个度要掌握好。比如团上有小孩子……</p>\n<p>　　12、“我的屁股”：让客人说词语，格式为aa或abb.例如“我的屁股香喷喷……”“我的屁股红彤彤”都不错，当然，要把话筒给客人，让他自己说。</p>\n<p>　　13、“击鼓传花”：幼儿园小朋友都会玩的游戏，可以用可乐瓶、或导游旗代替手绢，导游在前面唱歌，歌一停，看哪个拿到瓶子（或导游旗）的——表演节目，获得“国宝熊猫玩具”“明信片”一类的奖品；扎气球猜灯谜、谜语——没有人回答时，只要点出活跃分子表演节目，奖品就归他（她）。</p>\n<p>　　14、“车上跳舞”：这里所说的跳舞只是坐在车上。你伸左手，客人就得伸右手，无论你做什么动作，如果有客人和你一样，就输了，就罚唱歌噻！！！</p>\n<p>　　15、“明七暗七”：所谓明七就是：7、17、27之类的，暗七就是：7的倍数，有时玩的时候还把15也算上，这些都是不能说的数字，轮到了就得跳到下一个数字，15就用手做一个大月亮，如果说错了，就要罚他表演。</p>\n<p>　　16、“青蛙陷阱”：一只青蛙一张嘴，两只眼睛四条腿；两只青蛙两张嘴，四只眼睛八条腿……以此类推，每人一句，量词或数词说错了就要挨罚。</p>\n<p>17、“故事接龙”：如果遇到一些综合能力比较强的客人，还可以玩一种“故事接龙”的游戏。导游首先选好一个容易让人产生兴趣的故事情节，当你说出开头部分后，就由客人往下接（要把握好客人接故事的速度和分寸），遇到没有接上的，当然就该他表演节目，导游一定要在其中起到承上启下的作用才行。</p>\n<p>　　18、“词语组合”：准备好纸和笔，发给客人3张白纸，第一张写上姓名，第二张写上地方，第三张写上最爱做事情（地方和事情越夸张越好），分别放进3个袋子里，再让客人抽，形成新组合，会有很多意想不到的有趣事。好处嘛——搞笑，消磨时间长，客人容易接受，如果有小礼品就更好啦，技巧自己掌握。</p>\n<p>　　19、绕口令类：“走一走、扭一扭、见一颗柳树、搂一搂”，第二位就得说：走两走、扭两扭、见两颗柳树、搂两搂。数到十后返回从一开始。游戏规则是谁讲错罚谁出节目。由于是临时发挥，许多人都可能绕不过来，有的人把搂几搂先说了，有的人忘了数字接力，就准备听车内爆发出的阵阵笑声吧。其它的，比如让他们（客人）自己讲家乡，效果不错。当然前提是来自不同地方的散拼团。</p>\n<p>　　20、杀人游戏：不是真的杀人哈，别误会了。这个游戏规则说起来有点长。（省略不详述了）</p>\n<p>　　21、猜地名或人名：客人来自五湖四海，游过大江南北，很多是爱旅游的。那就让他们来猜：金银铜铁——无锡、四季温暖——长春、一路平安——旅顺、重男轻女——贵阳、风平浪静——宁波，赤壁之战——孙悦刘欢、降落伞——张飞、啥子都卖了，就是不卖被子——刘备。国外的也可以，比如“红色庄园”（丹麦）“蓝色的庄稼”（荷兰）。如果客人觉得难度太大，可以适当给点提示。当时，适当的小礼品还是要准备。</p>\n<p>　　22、猜谜语：这个就很多了。比如：一片青草地——打一花名（梅花），来了一只羊——打一水果名（草莓），又来了一只狼——打一水果名（杨莓），又来了一群羊——打一小食品名（喜之郎）</p>\n<p>　　23、脑筋急转弯：1、用左手食指指着车顶，问客人“这是什么？”客人一般会回答“1”，（答案应为“这是食指啦”）用右手做同样的动作再问客人，“这是几？”，客人多半要回答是食指，（答案应为“这是1”），要根据提问来找答案。2、芳芳在学校门口把学生证掉了，怎么办？（捡起来）3、一只饿猫看到老鼠，为什么拔腿就跑？（去追老鼠）。4、太平洋的中间是什么？（水、平）有油灯、暖炉、壁炉，应该先点哪样呢？（火柴）</p>\n<p>　　团里经常会卧虎藏龙的，发现了活跃分子，也有利于推自费项目，操作就不多说了哈！另外，如果客人太散或者年龄差距较大，有时玩游戏就不好操作了。这时，导游的讲解会比较重要，因为客人出来除了游玩，他们特别注重导游对当地文化的讲解，他们更想知道的是有关知识……</p>\n<p>　　导游在车上进行的游戏问三个问题，第一个问题是：说出你最喜欢乘坐的交通工具，第二个问题：说出你最喜欢的动物。第三个问题是：说出你最爱说的口头禅……说了一圈后，你再说：“我们接下来做一个连环游戏。大家记得自己刚才说的话吗？现在我们将自己刚才说的答案连成一句话。这句话的格式是这样的：我乘做着……（最喜欢的那个交通工具），遇见了……（最爱的那个动物），我对他说：……我爱你。那个动物说：……（你的那个口头禅）笑倒一大片。</p>\n<p>　　大家有都这么聪明，那不如来说个绕口令！我在带汽车团的时候，会和客人说绕口令！比如：“走一步，扭一扭，见到一棵柳树搂一搂”，“走两步，扭两扭，见到两棵柳树搂两楼”……，以此类推，如果客人多的话，到十六步时返回从一开始。要求是客人必须用普通话讲，前面一个人说完，后面的人要紧跟着讲，并且不允许停顿，导游也要参加，谁说不下来，就要表演一个节目！这个游戏看客人的表现！！导游一定要在气氛比较活跃的时候做，效果才会好。比如讲完一个笑话之后。</p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n\n","excerpt":"带团中有时需要搞下气氛,跟客人多做些互动,把客人逗乐了,那么你后面的工作也就得心应手一些喽! 1、一下就是我曾经用过的一个比较好用的小游戏，每人讲一句。第一个人讲:动物园里看动物，第二个人可以讲以下三种中的其中一种: 没有腿的 两条腿的 四条腿的","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.pengmengshan.cn/blog/tags/随笔/"}]},{"title":"鸡汤还是要喝的","date":"2017-04-01T09:51:11.000Z","path":"2017/04/01/essays_renge/","text":"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD d91bb7c23220559e6b55c0770726c7cf20effc06 爱情有时候是这样，你懂的越多，就会被伤的越深。而你被伤的越深，就会懂的更多。到最后你会发现，其实真正能陪你到老的那个人，是什么都不需要你懂的那一个。让你活的没心没肺，才是最好的那个人。有些事情，只有经历了，才有穿透心扉的体验；曾经的人，只有从心底放下了，心灵才会真正地解脱。没有哪件事，能够一直捆住你的手脚；没有哪个人，能够成为你的永远。所以，想做的事，只要有能力做，那就不要等，不要害怕失败；想付出的爱，只要觉得可以，那就大胆些，不要留下遗憾。 不管是今天的穷人，或明天的富人，抑或永远的穷人，我的价值取向是：做一个真诚的人，有一颗善良的心，活出人的尊严。 一颗高贵的灵魂，总会超越于现实之外，于精神的世界里去寻求一种更高贵的存在。——《有尊严的活着》 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" align=\"center\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=29947420&auto=0&height=66\"></iframe></h1><p><iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=\"330\" align=\"center\" height=\"86\" src=\"//music.163.com/outchain/player?type=2&id=29947420&auto=1&height=66\"></iframe></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>d91bb7c23220559e6b55c0770726c7cf20effc06</p>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>爱情有时候是这样，你懂的越多，就会被伤的越深。而你被伤的越深，就会懂的更多。到最后你会发现，其实真正能陪你到老的那个人，是什么都不需要你懂的那一个。让你活的没心没肺，才是最好的那个人。<br><img src=\"http://www.59xihuan.cn/uploads/allimg/20130607/21061370594900-lp.jpg\" alt=\"\"><br><a id=\"more\"></a><br>有些事情，只有经历了，才有穿透心扉的体验；曾经的人，只有从心底放下了，心灵才会真正地解脱。没有哪件事，能够一直捆住你的手脚；没有哪个人，能够成为你的永远。所以，想做的事，只要有能力做，那就不要等，不要害怕失败；想付出的爱，只要觉得可以，那就大胆些，不要留下遗憾。<br><img src=\"http://www.59xihuan.cn/uploads/allimg/201309/40351379292618-lp.jpg\" alt=\"\"></p>\n<p>不管是今天的穷人，或明天的富人，抑或永远的穷人，我的价值取向是：做一个真诚的人，有一颗善良的心，活出人的尊严。 一颗高贵的灵魂，总会超越于现实之外，于精神的世界里去寻求一种更高贵的存在。——《有尊严的活着》<br><img src=\"http://www.59xihuan.cn/uploads/allimg/20130721/76131374384779-lp.jpg\" alt=\"\"></p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD d91bb7c23220559e6b55c0770726c7cf20effc06 爱情有时候是这样，你懂的越多，就会被伤的越深。而你被伤的越深，就会懂的更多。到最后你会发现，其实真正能陪你到老的那个人，是什么都不需要你懂的那一个。让你活的没心没肺，才是最好的那个人。","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://www.pengmengshan.cn/blog/tags/随笔/"}]},{"title":"模块化开发","date":"2016-10-20T10:54:14.000Z","path":"2016/10/20/it_seajs/","text":"概述什么是模块化开发 将软件产品看作为一系列功能模块的组合 通过特定的方式实现软件所需模块的划分、管理、加载 为什么使用模块化开发 https://github.com/seajs/seajs/issues/547 协同 代码复用 解决问题 大量的文件引入 命名冲突 文件依赖 存在 顺序 实现模块化的推演step-01 全局函数step-02 封装对象step-03 划分私有空间step-04 模块的扩展与维护step-05 第三方依赖管理在什么场景下使用模块化开发 业务复杂 重用逻辑非常多 扩展性要求较高 实现规范CommonJS规范AMD规范CMD规范 实现Seajs使用步骤 在页面中引入sea.js文件 定义一个主模块文件，比如：main.js 在主模块文件中通过define的方式定义一个模块，并导出公共成员 在页面的行内脚本中通过seajs.use(‘path’,fn)的方式使用模块 回调函数的参数传过来的就是模块中导出的成员对象 定义一个模块 define 12345define(function(require, exports, module) &#123; exports.add = function(a, b) &#123; return a + b; &#125;;&#125;); 使用一个模块 seajs.use 一般用于入口模块 一般只会使用一次 require 模块与模块之间 导出成员的方式 module.exports exports.xxx return 三种方式的优先级 异步加载模块 默认require的效果是同步的，会阻塞代码的执行，造成界面卡顿 require.async(); 123require.async('path',function(module) &#123;&#125;); 使用第三方依赖（jQuery） 由于CMD是国产货，jquery默认不支持 改造 12345678// 适配CMDif (typeof define === \"function\" &amp;&amp; !define.amd) &#123; // 当前有define函数，并且不是AMD的情况 // jquery在新版本中如果使用AMD或CMD方式，不会去往全局挂载jquery对象 define(function() &#123; return jQuery.noConflict(true); &#125;);&#125; Seajs配置 配置 seajs.config base alias 使用案例 Tab标签页 RequireJS 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"什么是模块化开发\"><a href=\"#什么是模块化开发\" class=\"headerlink\" title=\"什么是模块化开发\"></a>什么是模块化开发</h3><ul>\n<li>将软件产品看作为一系列功能模块的组合</li>\n<li>通过特定的方式实现软件所需模块的划分、管理、加载</li>\n</ul>\n<h3 id=\"为什么使用模块化开发\"><a href=\"#为什么使用模块化开发\" class=\"headerlink\" title=\"为什么使用模块化开发\"></a>为什么使用模块化开发</h3><a id=\"more\"></a>\n<ul>\n<li><a href=\"https://github.com/seajs/seajs/issues/547\" target=\"_blank\" rel=\"external\">https://github.com/seajs/seajs/issues/547</a></li>\n<li>协同</li>\n<li>代码复用</li>\n<li>解决问题<ul>\n<li>大量的文件引入</li>\n<li>命名冲突</li>\n<li>文件依赖<ul>\n<li>存在</li>\n<li>顺序</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"实现模块化的推演\"><a href=\"#实现模块化的推演\" class=\"headerlink\" title=\"实现模块化的推演\"></a>实现模块化的推演</h3><h4 id=\"step-01-全局函数\"><a href=\"#step-01-全局函数\" class=\"headerlink\" title=\"step-01 全局函数\"></a>step-01 全局函数</h4><h4 id=\"step-02-封装对象\"><a href=\"#step-02-封装对象\" class=\"headerlink\" title=\"step-02 封装对象\"></a>step-02 封装对象</h4><h4 id=\"step-03-划分私有空间\"><a href=\"#step-03-划分私有空间\" class=\"headerlink\" title=\"step-03 划分私有空间\"></a>step-03 划分私有空间</h4><h4 id=\"step-04-模块的扩展与维护\"><a href=\"#step-04-模块的扩展与维护\" class=\"headerlink\" title=\"step-04 模块的扩展与维护\"></a>step-04 模块的扩展与维护</h4><h4 id=\"step-05-第三方依赖管理\"><a href=\"#step-05-第三方依赖管理\" class=\"headerlink\" title=\"step-05 第三方依赖管理\"></a>step-05 第三方依赖管理</h4><p>在什么场景下使用模块化开发<br>  业务复杂<br>  重用逻辑非常多<br>  扩展性要求较高</p>\n<hr>\n<h2 id=\"实现规范\"><a href=\"#实现规范\" class=\"headerlink\" title=\"实现规范\"></a>实现规范</h2><h3 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a>CommonJS规范</h3><h3 id=\"AMD规范\"><a href=\"#AMD规范\" class=\"headerlink\" title=\"AMD规范\"></a>AMD规范</h3><h3 id=\"CMD规范\"><a href=\"#CMD规范\" class=\"headerlink\" title=\"CMD规范\"></a>CMD规范</h3><hr>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"Seajs\"><a href=\"#Seajs\" class=\"headerlink\" title=\"Seajs\"></a>Seajs</h3><h4 id=\"使用步骤\"><a href=\"#使用步骤\" class=\"headerlink\" title=\"使用步骤\"></a>使用步骤</h4><ol>\n<li>在页面中引入sea.js文件</li>\n<li>定义一个主模块文件，比如：main.js</li>\n<li>在主模块文件中通过define的方式定义一个模块，并导出公共成员</li>\n<li>在页面的行内脚本中通过seajs.use(‘path’,fn)的方式使用模块</li>\n<li>回调函数的参数传过来的就是模块中导出的成员对象</li>\n</ol>\n<h4 id=\"定义一个模块\"><a href=\"#定义一个模块\" class=\"headerlink\" title=\"定义一个模块\"></a>定义一个模块</h4><ul>\n<li>define</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;</div><div class=\"line\">  exports.add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> a + b;</div><div class=\"line\">  &#125;;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"使用一个模块\"><a href=\"#使用一个模块\" class=\"headerlink\" title=\"使用一个模块\"></a>使用一个模块</h4><ul>\n<li>seajs.use<ul>\n<li>一般用于入口模块</li>\n<li>一般只会使用一次</li>\n</ul>\n</li>\n<li>require<ul>\n<li>模块与模块之间</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"导出成员的方式\"><a href=\"#导出成员的方式\" class=\"headerlink\" title=\"导出成员的方式\"></a>导出成员的方式</h4><ul>\n<li>module.exports</li>\n<li>exports.xxx</li>\n<li>return</li>\n<li>三种方式的优先级</li>\n</ul>\n<h4 id=\"异步加载模块\"><a href=\"#异步加载模块\" class=\"headerlink\" title=\"异步加载模块\"></a>异步加载模块</h4><ul>\n<li>默认require的效果是同步的，会阻塞代码的执行，造成界面卡顿</li>\n<li>require.async();</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">require</span>.async(<span class=\"string\">'path'</span>,<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module</span>) </span>&#123;</div><div class=\"line\"></div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h4 id=\"使用第三方依赖（jQuery）\"><a href=\"#使用第三方依赖（jQuery）\" class=\"headerlink\" title=\"使用第三方依赖（jQuery）\"></a>使用第三方依赖（jQuery）</h4><ul>\n<li>由于CMD是国产货，jquery默认不支持</li>\n<li>改造</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 适配CMD</span></div><div class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> define === <span class=\"string\">\"function\"</span> &amp;&amp; !define.amd) &#123;</div><div class=\"line\">  <span class=\"comment\">// 当前有define函数，并且不是AMD的情况</span></div><div class=\"line\">  <span class=\"comment\">// jquery在新版本中如果使用AMD或CMD方式，不会去往全局挂载jquery对象</span></div><div class=\"line\">  define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> jQuery.noConflict(<span class=\"literal\">true</span>);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"Seajs配置\"><a href=\"#Seajs配置\" class=\"headerlink\" title=\"Seajs配置\"></a>Seajs配置</h4><ul>\n<li><a href=\"https://github.com/seajs/seajs/issues/262\" target=\"_blank\" rel=\"external\">配置</a></li>\n<li>seajs.config<ul>\n<li>base</li>\n<li>alias</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h4><ul>\n<li>Tab标签页</li>\n</ul>\n<h3 id=\"RequireJS\"><a href=\"#RequireJS\" class=\"headerlink\" title=\"RequireJS\"></a>RequireJS</h3><hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"概述什么是模块化开发 将软件产品看作为一系列功能模块的组合 通过特定的方式实现软件所需模块的划分、管理、加载 为什么使用模块化开发","categories":[{"name":"技术","slug":"技术","permalink":"http://www.pengmengshan.cn/blog/categories/技术/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.pengmengshan.cn/blog/tags/angular/"}]},{"title":"电影列表检索案例","date":"2016-10-19T10:54:14.000Z","path":"2016/10/19/it_ng-6/","text":"step-01 构建项目结构 克隆项目骨架 12$ git clone --depth=1 https://github.com/Micua/angular-boilerplate.git moviecat$ cd moviecat 安装项目依赖 1$ bower install bootstrap --save 12.editorconfig -- 统一不同开发者的不同开发工具的不同开发配置在Sublime中使用需要安装一个EditorConfig的插件 为NG做一个项目骨架的目的是为了快速开始一个新的项目 angular-seed npm 在 package.json中的script节点中可以定义脚本任务， API的概念：Application Programxxx Interface应用程序编程接口 有哪些常见的API WebAPI 通过WEB方式提供结构叫做 WEBAPI Math.random() – api? 所有有输入有输出的事物都可以是API都是函数 测试WebAPI的工具： POSTMAN step-02 抽象数据成员，以假数据的方式设计控制器和视图step-03 图片链接数据绑定BUGstep-04 豆瓣API介绍，加入$http服务对象完成AJAX请求数据step-05 加载提示，Loading状态设计step-06 修改字符数组的展示形式step-07 实现分页功能step-07 抽象公共的列表页step-08 搜索功能模块step-09 详细页模块设计展示 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<h2 id=\"step-01-构建项目结构\"><a href=\"#step-01-构建项目结构\" class=\"headerlink\" title=\"step-01 构建项目结构\"></a>step-01 构建项目结构</h2><ul>\n<li>克隆项目骨架</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> --depth=1 https://github.com/Micua/angular-boilerplate.git moviecat</div><div class=\"line\">$ <span class=\"built_in\">cd</span> moviecat</div></pre></td></tr></table></figure>\n<ul>\n<li>安装项目依赖</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower install bootstrap --save</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">.editorconfig -- 统一不同开发者的不同开发工具的不同开发配置</div><div class=\"line\">在Sublime中使用需要安装一个EditorConfig的插件</div></pre></td></tr></table></figure>\n<ul>\n<li>为NG做一个项目骨架的目的是为了快速开始一个新的项目</li>\n<li>angular-seed</li>\n</ul>\n<p>npm 在 package.json中的script节点中可以定义脚本任务，</p>\n<a id=\"more\"></a>\n<p>API的概念：<br>Application Programxxx Interface<br>应用程序编程接口</p>\n<p>有哪些常见的API</p>\n<p>WebAPI 通过WEB方式提供结构叫做 WEBAPI</p>\n<p>Math.random() – api?</p>\n<p>所有有输入有输出的事物都可以是API<br>都是函数</p>\n<p>测试WebAPI的工具： POSTMAN</p>\n<h2 id=\"step-02-抽象数据成员，以假数据的方式设计控制器和视图\"><a href=\"#step-02-抽象数据成员，以假数据的方式设计控制器和视图\" class=\"headerlink\" title=\"step-02 抽象数据成员，以假数据的方式设计控制器和视图\"></a>step-02 抽象数据成员，以假数据的方式设计控制器和视图</h2><h2 id=\"step-03-图片链接数据绑定BUG\"><a href=\"#step-03-图片链接数据绑定BUG\" class=\"headerlink\" title=\"step-03 图片链接数据绑定BUG\"></a>step-03 图片链接数据绑定BUG</h2><h2 id=\"step-04-豆瓣API介绍，加入-http服务对象完成AJAX请求数据\"><a href=\"#step-04-豆瓣API介绍，加入-http服务对象完成AJAX请求数据\" class=\"headerlink\" title=\"step-04 豆瓣API介绍，加入$http服务对象完成AJAX请求数据\"></a>step-04 豆瓣API介绍，加入$http服务对象完成AJAX请求数据</h2><h2 id=\"step-05-加载提示，Loading状态设计\"><a href=\"#step-05-加载提示，Loading状态设计\" class=\"headerlink\" title=\"step-05 加载提示，Loading状态设计\"></a>step-05 加载提示，Loading状态设计</h2><h2 id=\"step-06-修改字符数组的展示形式\"><a href=\"#step-06-修改字符数组的展示形式\" class=\"headerlink\" title=\"step-06 修改字符数组的展示形式\"></a>step-06 修改字符数组的展示形式</h2><h2 id=\"step-07-实现分页功能\"><a href=\"#step-07-实现分页功能\" class=\"headerlink\" title=\"step-07 实现分页功能\"></a>step-07 实现分页功能</h2><h2 id=\"step-07-抽象公共的列表页\"><a href=\"#step-07-抽象公共的列表页\" class=\"headerlink\" title=\"step-07 抽象公共的列表页\"></a>step-07 抽象公共的列表页</h2><h2 id=\"step-08-搜索功能模块\"><a href=\"#step-08-搜索功能模块\" class=\"headerlink\" title=\"step-08 搜索功能模块\"></a>step-08 搜索功能模块</h2><h2 id=\"step-09-详细页模块设计展示\"><a href=\"#step-09-详细页模块设计展示\" class=\"headerlink\" title=\"step-09 详细页模块设计展示\"></a>step-09 详细页模块设计展示</h2><hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"step-01 构建项目结构 克隆项目骨架 12$ git clone --depth=1 https://github.com/Micua/angular-boilerplate.git moviecat$ cd moviecat 安装项目依赖 1$ bower install bootstrap --save 12.editorconfig -- 统一不同开发者的不同开发工具的不同开发配置在Sublime中使用需要安装一个EditorConfig的插件 为NG做一个项目骨架的目的是为了快速开始一个新的项目 angular-seed npm 在 package.json中的script节点中可以定义脚本任务，","categories":[{"name":"技术","slug":"技术","permalink":"http://www.pengmengshan.cn/blog/categories/技术/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.pengmengshan.cn/blog/tags/angular/"}]},{"title":"AngularJS 过滤器、服务、路由","date":"2016-10-18T10:54:14.000Z","path":"2016/10/18/it_ng-5/","text":"TODOMVC案例 根据界面原型抽象数据成员（有哪些数据，每个数据的类型和结构） 设计模块，控制器 完成数据绑定 编写交互逻辑 过滤器data 过滤器 用于时间日期格式化 lowercase, uppercase 英文字符大小写转换 number 数字格式化，例如将10000 → 10,000.00 limitTo 过滤器 限制数量，限制字符串或者遍历长度 orderBy 按照特定字段排序，默认是正序，倒序则加上-号 filter 过滤器 检索特定内容，默认模糊匹配 如果传入对象则匹配特定属性，如传入{name:’张三’}，则匹配那么属性中包含张三 自定义比较 默认filter过滤器使用的是模糊匹配 需要自定义比较函数 filter的第三个参数 服务内置服务$log服务 打印控制台日志 启用或者关闭 $timeout自定义服务路由NG 中路由是单独提供的功能模块 ngRoute, 也是一个单独发型的文件 安装或者下载angular-route的包 引入这个包 在自己的模块中添加 ngRoute 依赖 路由配置（配置路由规则） 规则指的就是 什么样的请求 找什么控制器 [{url:’/sdf’,controller:’MainController’}] 编写对应的控制器和视图 /students/zhangsan /:role/:name {role:students,name:zhangsan} 如果连入第三方文件时不写协议的话：http://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js↓ 如果当前你的网站是HTTP的方式部署的话，请求http://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js如果是HTTPS的话，请求https://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<h2 id=\"TODOMVC案例\"><a href=\"#TODOMVC案例\" class=\"headerlink\" title=\"TODOMVC案例\"></a>TODOMVC案例</h2><ul>\n<li>根据界面原型抽象数据成员（有哪些数据，每个数据的类型和结构）</li>\n<li>设计模块，控制器</li>\n<li>完成数据绑定</li>\n<li>编写交互逻辑</li>\n</ul>\n<h2 id=\"过滤器\"><a href=\"#过滤器\" class=\"headerlink\" title=\"过滤器\"></a>过滤器</h2><h3 id=\"data-过滤器\"><a href=\"#data-过滤器\" class=\"headerlink\" title=\"data 过滤器\"></a>data 过滤器</h3><ul>\n<li>用于时间日期格式化</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"lowercase-uppercase\"><a href=\"#lowercase-uppercase\" class=\"headerlink\" title=\"lowercase, uppercase\"></a>lowercase, uppercase</h3><ul>\n<li>英文字符大小写转换</li>\n</ul>\n<h3 id=\"number\"><a href=\"#number\" class=\"headerlink\" title=\"number\"></a>number</h3><ul>\n<li>数字格式化，例如将10000 → 10,000.00</li>\n</ul>\n<h3 id=\"limitTo-过滤器\"><a href=\"#limitTo-过滤器\" class=\"headerlink\" title=\"limitTo 过滤器\"></a>limitTo 过滤器</h3><ul>\n<li>限制数量，限制字符串或者遍历长度</li>\n</ul>\n<h3 id=\"orderBy\"><a href=\"#orderBy\" class=\"headerlink\" title=\"orderBy\"></a>orderBy</h3><ul>\n<li>按照特定字段排序，默认是正序，倒序则加上-号</li>\n</ul>\n<h3 id=\"filter-过滤器\"><a href=\"#filter-过滤器\" class=\"headerlink\" title=\"filter 过滤器\"></a>filter 过滤器</h3><ul>\n<li>检索特定内容，默认模糊匹配</li>\n<li>如果传入对象则匹配特定属性，如传入{name:’张三’}，则匹配那么属性中包含张三</li>\n</ul>\n<h4 id=\"自定义比较\"><a href=\"#自定义比较\" class=\"headerlink\" title=\"自定义比较\"></a>自定义比较</h4><ul>\n<li>默认filter过滤器使用的是模糊匹配</li>\n<li>需要自定义比较函数</li>\n<li>filter的第三个参数</li>\n</ul>\n<h2 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h2><h3 id=\"内置服务\"><a href=\"#内置服务\" class=\"headerlink\" title=\"内置服务\"></a>内置服务</h3><h4 id=\"log服务\"><a href=\"#log服务\" class=\"headerlink\" title=\"$log服务\"></a>$log服务</h4><ul>\n<li>打印控制台日志</li>\n<li>启用或者关闭</li>\n</ul>\n<h4 id=\"timeout\"><a href=\"#timeout\" class=\"headerlink\" title=\"$timeout\"></a>$timeout</h4><h3 id=\"自定义服务\"><a href=\"#自定义服务\" class=\"headerlink\" title=\"自定义服务\"></a>自定义服务</h3><h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><h3 id=\"NG-中路由是单独提供的功能模块-ngRoute-也是一个单独发型的文件\"><a href=\"#NG-中路由是单独提供的功能模块-ngRoute-也是一个单独发型的文件\" class=\"headerlink\" title=\"NG 中路由是单独提供的功能模块 ngRoute, 也是一个单独发型的文件\"></a>NG 中路由是单独提供的功能模块 ngRoute, 也是一个单独发型的文件</h3><ul>\n<li>安装或者下载angular-route的包</li>\n<li>引入这个包</li>\n<li>在自己的模块中添加 ngRoute 依赖</li>\n<li>路由配置（配置路由规则）<ul>\n<li>规则指的就是 什么样的请求 找什么控制器</li>\n<li>[{url:’/sdf’,controller:’MainController’}]</li>\n</ul>\n</li>\n<li>编写对应的控制器和视图</li>\n</ul>\n<p>/students/zhangsan</p>\n<p>/:role/:name</p>\n<p>{role:students,name:zhangsan}</p>\n<h2 id=\"如果连入第三方文件时不写协议的话：\"><a href=\"#如果连入第三方文件时不写协议的话：\" class=\"headerlink\" title=\"如果连入第三方文件时不写协议的话：\"></a>如果连入第三方文件时不写协议的话：</h2><p><a href=\"http://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js\" target=\"_blank\" rel=\"external\">http://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js</a><br>↓</p>\n<p><script src=\"//apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js\"></script><br>如果当前你的网站是HTTP的方式部署的话，请求<br><a href=\"http://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js\" target=\"_blank\" rel=\"external\">http://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js</a><br>如果是HTTPS的话，请求<br><a href=\"https://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js\" target=\"_blank\" rel=\"external\">https://apps.bdimg.com/libs/angular.js/1.4.7/angular.min.js</a></p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>","excerpt":"TODOMVC案例 根据界面原型抽象数据成员（有哪些数据，每个数据的类型和结构） 设计模块，控制器 完成数据绑定 编写交互逻辑 过滤器data 过滤器 用于时间日期格式化","categories":[{"name":"技术","slug":"技术","permalink":"http://www.pengmengshan.cn/blog/categories/技术/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.pengmengshan.cn/blog/tags/angular/"}]},{"title":"Angular入门","date":"2016-10-16T16:00:00.000Z","path":"2016/10/17/it_ng-3/","text":"推荐工具 在线编辑器 http://codepen.io/ https://jsfiddle.net/ Angular 简介 什么是 AngularJS 一款非常优秀的前端高级 JS 框架 最早由 Misko Hevery 等人创建 2009 年被 Google 公式收购，用于其多款产品 目前有一个全职的开发团队继续开发和维护这个库 有了这一类框架就可以轻松构建 SPA 应用程序 轻松构建 SPA（单一页面应用程序） 单一页面应用程序： 只有一个页面（整个应用的一个载体） 内容全部是由AJAX方式呈现出啦的 其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。 为什么使用 AngularJS 更少的代码，实现更强劲的功能 将一些以前在后台开发中使用的思想带入前端开发 带领当前市面上的框架走向模式化或者架构化 AngularJS 的核心特性 MVC 模块化 自动化双向数据绑定 指令系统 相关链接 http://www.apjs.net/ http://www.angularjs.cn/ http://docs.angularjs.cn/api https://material.angularjs.org http://angular-ui.github.io/ Angular 上手安装 Angular 下载 Angular.js 的包 https://github.com/angular/angular.js/releases 使用 CDN 上的 Angular.js http://apps.bdimg.com/libs/angular.js/1.4.9/angular.min.js 使用 Bower 安装 1bower install angular 使用 NPM 安装 1npm install angular 每种方式安装包，本质都是将angular的库下载到当前文件夹中 简单示例12 angular中最重要的概念是指令（directive） ng-model 是双向数据绑定的指令，效果就是将当前元素的value属性和模型中的user.name建立绑定关系 JS: BOM DOM ES 分析 Angular 示例使用总结运行官方文档CDN的优势Content Dev 快 节省自己服务器的带宽压力和流量 Angular 基础概念MVC 思想什么是 MVC 思想 将应用程序的组成划分为三个部分：Model View Controller 控制器的作用就是初始化模型用的； 模型就是用于存储数据的 视图用于展现数据 登陆案例 模型 我们数据库中所有用户的信息 接受控制器传来的用户名和密码进行校验的业务逻辑并返回true/false 控制器 接受用户在界面上填写的用户名和密码 将用户名和密码交给模型 视图 给用户呈现一个表单 接受用户输入内容，并将其提交给控制器 根据控制器返回的数据，响应用户页面 模块（Module） 划分应用程序结构 我们可以通过angular.module创建一个模块 angular.module方法传递两个参数才是创建模块，一个参数是获取模块 控制器（Controller） 通过$scope和视图关联- 视图模型（$scope）表达式（Expression）单向数据绑定双向数据绑定Angular 指令系统 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<h2 id=\"推荐工具\"><a href=\"#推荐工具\" class=\"headerlink\" title=\"推荐工具\"></a>推荐工具</h2><ul>\n<li>在线编辑器<ul>\n<li><a href=\"http://codepen.io/\" target=\"_blank\" rel=\"external\">http://codepen.io/</a></li>\n<li><a href=\"https://jsfiddle.net/\" target=\"_blank\" rel=\"external\">https://jsfiddle.net/</a></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Angular-简介\"><a href=\"#Angular-简介\" class=\"headerlink\" title=\"Angular 简介\"></a>Angular 简介</h2><a id=\"more\"></a>\n<h3 id=\"什么是-AngularJS\"><a href=\"#什么是-AngularJS\" class=\"headerlink\" title=\"什么是 AngularJS\"></a>什么是 AngularJS</h3><ul>\n<li>一款非常优秀的前端高级 JS 框架</li>\n<li>最早由 Misko Hevery 等人创建</li>\n<li>2009 年被 Google 公式收购，用于其多款产品</li>\n<li>目前有一个全职的开发团队继续开发和维护这个库</li>\n<li>有了这一类框架就可以轻松构建 SPA 应用程序</li>\n<li>轻松构建 SPA（单一页面应用程序）</li>\n<li>单一页面应用程序：<ul>\n<li>只有一个页面（整个应用的一个载体）</li>\n<li>内容全部是由AJAX方式呈现出啦的</li>\n</ul>\n</li>\n<li>其核心就是通过指令扩展了 HTML，通过表达式绑定数据到 HTML。</li>\n</ul>\n<h3 id=\"为什么使用-AngularJS\"><a href=\"#为什么使用-AngularJS\" class=\"headerlink\" title=\"为什么使用 AngularJS\"></a>为什么使用 AngularJS</h3><ul>\n<li>更少的代码，实现更强劲的功能</li>\n<li>将一些以前在后台开发中使用的思想带入前端开发</li>\n<li>带领当前市面上的框架走向模式化或者架构化</li>\n</ul>\n<h3 id=\"AngularJS-的核心特性\"><a href=\"#AngularJS-的核心特性\" class=\"headerlink\" title=\"AngularJS 的核心特性\"></a>AngularJS 的核心特性</h3><ul>\n<li>MVC</li>\n<li>模块化</li>\n<li>自动化双向数据绑定</li>\n<li>指令系统</li>\n</ul>\n<h3 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h3><ul>\n<li><a href=\"http://www.apjs.net/\" target=\"_blank\" rel=\"external\">http://www.apjs.net/</a></li>\n<li><a href=\"http://www.angularjs.cn/\" target=\"_blank\" rel=\"external\">http://www.angularjs.cn/</a></li>\n<li><a href=\"http://docs.angularjs.cn/api\" target=\"_blank\" rel=\"external\">http://docs.angularjs.cn/api</a></li>\n<li><a href=\"https://material.angularjs.org\" target=\"_blank\" rel=\"external\">https://material.angularjs.org</a></li>\n<li><a href=\"http://angular-ui.github.io/\" target=\"_blank\" rel=\"external\">http://angular-ui.github.io/</a></li>\n</ul>\n<h2 id=\"Angular-上手\"><a href=\"#Angular-上手\" class=\"headerlink\" title=\"Angular 上手\"></a>Angular 上手</h2><h3 id=\"安装-Angular\"><a href=\"#安装-Angular\" class=\"headerlink\" title=\"安装 Angular\"></a>安装 Angular</h3><ul>\n<li>下载 Angular.js 的包<ul>\n<li><a href=\"https://github.com/angular/angular.js/releases\" target=\"_blank\" rel=\"external\">https://github.com/angular/angular.js/releases</a></li>\n</ul>\n</li>\n<li>使用 CDN 上的 Angular.js<ul>\n<li><a href=\"http://apps.bdimg.com/libs/angular.js/1.4.9/angular.min.js\" target=\"_blank\" rel=\"external\">http://apps.bdimg.com/libs/angular.js/1.4.9/angular.min.js</a></li>\n</ul>\n</li>\n<li><p>使用 Bower 安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bower install angular</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用 NPM 安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install angular</div></pre></td></tr></table></figure>\n</li>\n<li><p>每种方式安装包，本质都是将angular的库下载到当前文件夹中</p>\n</li>\n</ul>\n<h3 id=\"简单示例\"><a href=\"#简单示例\" class=\"headerlink\" title=\"简单示例\"></a>简单示例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n<ul>\n<li><p>angular中最重要的概念是指令（directive）</p>\n</li>\n<li><p>ng-model 是双向数据绑定的指令，效果就是将当前元素的value属性和模型中的user.name建立绑定关系</p>\n</li>\n<li><p>JS: BOM DOM ES</p>\n</li>\n</ul>\n<h3 id=\"分析-Angular-示例\"><a href=\"#分析-Angular-示例\" class=\"headerlink\" title=\"分析 Angular 示例\"></a>分析 Angular 示例</h3><h3 id=\"使用总结\"><a href=\"#使用总结\" class=\"headerlink\" title=\"使用总结\"></a>使用总结</h3><h3 id=\"运行官方文档\"><a href=\"#运行官方文档\" class=\"headerlink\" title=\"运行官方文档\"></a>运行官方文档</h3><h2 id=\"CDN的优势\"><a href=\"#CDN的优势\" class=\"headerlink\" title=\"CDN的优势\"></a>CDN的优势</h2><p>Content Dev</p>\n<ul>\n<li>快</li>\n<li>节省自己服务器的带宽压力和流量</li>\n</ul>\n<h2 id=\"Angular-基础概念\"><a href=\"#Angular-基础概念\" class=\"headerlink\" title=\"Angular 基础概念\"></a>Angular 基础概念</h2><h3 id=\"MVC-思想\"><a href=\"#MVC-思想\" class=\"headerlink\" title=\"MVC 思想\"></a>MVC 思想</h3><h4 id=\"什么是-MVC-思想\"><a href=\"#什么是-MVC-思想\" class=\"headerlink\" title=\"什么是 MVC 思想\"></a>什么是 MVC 思想</h4><ul>\n<li>将应用程序的组成划分为三个部分：Model View Controller</li>\n<li>控制器的作用就是初始化模型用的；</li>\n<li>模型就是用于存储数据的</li>\n<li>视图用于展现数据</li>\n</ul>\n<ul>\n<li>登陆案例</li>\n<li>模型<ul>\n<li>我们数据库中所有用户的信息</li>\n<li>接受控制器传来的用户名和密码进行校验的业务逻辑并返回true/false</li>\n</ul>\n</li>\n<li>控制器<ul>\n<li>接受用户在界面上填写的用户名和密码</li>\n<li>将用户名和密码交给模型</li>\n</ul>\n</li>\n<li>视图<ul>\n<li>给用户呈现一个表单</li>\n<li>接受用户输入内容，并将其提交给控制器</li>\n<li>根据控制器返回的数据，响应用户页面</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"模块（Module）\"><a href=\"#模块（Module）\" class=\"headerlink\" title=\"模块（Module）\"></a>模块（Module）</h3><ul>\n<li>划分应用程序结构</li>\n<li>我们可以通过angular.module创建一个模块</li>\n<li>angular.module方法传递两个参数才是创建模块，一个参数是获取模块</li>\n</ul>\n<h3 id=\"控制器（Controller）\"><a href=\"#控制器（Controller）\" class=\"headerlink\" title=\"控制器（Controller）\"></a>控制器（Controller）</h3><ul>\n<li>通过$scope和视图关联<br>-</li>\n</ul>\n<h3 id=\"视图模型（-scope）\"><a href=\"#视图模型（-scope）\" class=\"headerlink\" title=\"视图模型（$scope）\"></a>视图模型（$scope）</h3><h3 id=\"表达式（Expression）\"><a href=\"#表达式（Expression）\" class=\"headerlink\" title=\"表达式（Expression）\"></a>表达式（Expression）</h3><h3 id=\"单向数据绑定\"><a href=\"#单向数据绑定\" class=\"headerlink\" title=\"单向数据绑定\"></a>单向数据绑定</h3><h3 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h3><h2 id=\"Angular-指令系统\"><a href=\"#Angular-指令系统\" class=\"headerlink\" title=\"Angular 指令系统\"></a>Angular 指令系统</h2><hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n","excerpt":"推荐工具 在线编辑器 http://codepen.io/ https://jsfiddle.net/ Angular 简介","categories":[{"name":"技术","slug":"技术","permalink":"http://www.pengmengshan.cn/blog/categories/技术/"}],"tags":[{"name":"angular","slug":"angular","permalink":"http://www.pengmengshan.cn/blog/tags/angular/"}]},{"title":"构建前端自动化工作流环境","date":"2016-10-15T10:54:14.000Z","path":"2016/10/15/it_gulp/","text":"学习目标 了解什么是Node，什么是NPM；（Node.js） 掌握Bower的使用； 熟练使用Less/Sass； 搭建一个自己的自动化工作流环境； 自动编译 自动合并 自动刷新 自动部署 GIT 与 GITHUB master 托管源文件 gh-pages 托管部署文件 在github搭建自己的blog 为什么要有自动化的流程 在我们的开发过程中有大量的重复操作 DRY Don’t repeat yourself 开发人员的精力应放在哪？创造，新的一切 前端开发的编译操作 1.Node环境1.1.什么是Node Node.js 可能类似jquery.js 不是JS文件，也不是一个JS框架（） 而是Server side Javascript runtime, 服务端的一个JS运行时 我们可以在NODE运行JS代码 alert();ECMAScript JS- ES BOM DOM node中只能运行ECMAScript，无法使用 BOM 和 DOM 目前我们的JS是运行在浏览器内核中 PHP是什么？是一门脚本语言也是一个运行环境 为什么Node选中了JS， 说到底就是一个JS运行环境 目前有两个分支 Node.js 0.12.7 官方版本 要求尽善尽美 IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快 15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了 node 5.x == io.js node 4.0 == node 1.2.Node环境搭建1.2.1.Mac 安装包的方式 pkg NVM（Node Version Manager） 1234$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash$ echo '. ~/.nvm/nvm.sh' &gt;&gt; .bash_profile$ nvm install stable$ nvm alias default stable 1.2.2.Windows 安装包的方式 msi_x64 msi_x86 NVM（Node Version Manager） nvm(node version manager) 因为NODE版本比较多，开发人员可能依赖很多版本 通过NVM，可以轻松切换于不同的版本之间 12 NVM_HOME=C:\\Develop\\nvm NVM_SYMLINK=C:\\Develop\\nodejs NPM_HOME=C:\\Develop\\nvm\\npm PATH=%NVM_HOME%;%NVM_SYMLINK%;%NPM_HOME% 1.2.3.环境变量 环境变量就是操作系统提供的系统级别用于存储变量的地方 系统变量和用户变量 系统变量指的是所用当前系统用户共享的变量 自己的电脑一般只有一个用户 建议将自己配置的环境变量放在用户变量中，用户变量比较干净 环境变量的变量名是不区分大小写的 变量间运行相互引用 特殊值： PATH变量（不区分大小写） PATH 相当于一个路径的引用 只要添加到PATH变量中的路径，都可以在任何目录下搜索 命令行 可以用来执行当前目录下的文件 命令 cd :change directory Node.js是一个轻内核（本身没有什么功能）的东东，所有的功能都要功能包提供 node官方提供了一些最基础的包 1.3.Node用途REPL环境（控制台环境）1.3.1.开发Web应用程序 做动态网站 开发提供数据的服务端API 1.3.2.前端开发工具基础 Node.js给前端乃至整个开发行业带来一场工业革命 刀跟火种 1.4.Node开发Web应用Demo1.4.1.复习请求与响应客户端发送到服务端的东西称之为请求报文服务端返回给客户端的东西称之为响应报文 1.5.NPM1.5.1.什么是NPMhttps://www.npmjs.com/ Node Package Manager Node应用程序依赖包的管理工具 安装卸载更新之类的操作 1.5.2.为什么使用NPM 包很多 场景：我需要用一个A，A依赖B，B依赖C 常见的包管理工具都有循环依赖的功能 你只需记住你要什么东西 1.5.3.常见的NPM操作// 安装一个包，默认安装最新稳定版本npm install package_name// –save// 初始化操作，给项目添加一个配置文件npm init// –yes参数走默认配置 如果官方数据源太慢使用 https://npm.taobao.org/ 2.Bower2.1.什么是Bower 官网 web应用程序依赖项管理工具 2.2.为什么使用Bower 方便便捷的方式管理包，zhuangbi 2.3.Bower实践 npm install -g bower // -g:global 修改npm全局路径，就是在用户目录下添加.npmrc文件 3.Sass/LESS 4.Gulp4.1.Gulp简介 链接： 官网 中文网 就是用来机械化的完成重复性质的工作 gulp的机制就是将重复工作抽象成一个个的任务， 4.2.Gulp准备工作 安装Node.js 安装 gulp 命令行工具 npm install -g gulp 初始化 gulp 项目 创建任务 - gulpfile.js 4.3.基本使用4.4.常用插件 编译 Less：gulp-less 创建本地服务器：gulp-connect 合并文件：gulp-concat 最小化 js 文件：gulp-uglify 重命名文件：gulp-rename 最小化 css 文件：gulp-minify-css 压缩html文件 gulp-minify-html 最小化图像：gulp-imagemin 5.Git5.1.什么是GIT，什么是GITHUB GIT GITHUB 5.2.环境安装5.3.GIT常用命令 6.Markdownhttps://guides.github.com/features/mastering-markdown/https://help.github.com/articles/github-flavored-markdown/https://help.github.com/articles/markdown-basics/ 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<h2 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h2><ul>\n<li>了解什么是Node，什么是NPM；（Node.js）</li>\n<li>掌握Bower的使用；</li>\n<li>熟练使用Less/Sass；</li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>搭建一个自己的自动化工作流环境；<ul>\n<li>自动编译</li>\n<li>自动合并</li>\n<li>自动刷新</li>\n<li>自动部署</li>\n</ul>\n</li>\n<li>GIT 与 GITHUB<ul>\n<li>master 托管源文件</li>\n<li>gh-pages 托管部署文件</li>\n<li>在github搭建自己的blog</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"为什么要有自动化的流程\"><a href=\"#为什么要有自动化的流程\" class=\"headerlink\" title=\"为什么要有自动化的流程\"></a>为什么要有自动化的流程</h2><ul>\n<li>在我们的开发过程中有大量的重复操作</li>\n<li>DRY  Don’t repeat yourself</li>\n<li>开发人员的精力应放在哪？创造，新的一切</li>\n</ul>\n<ul>\n<li>前端开发的编译操作</li>\n</ul>\n<h2 id=\"1-Node环境\"><a href=\"#1-Node环境\" class=\"headerlink\" title=\"1.Node环境\"></a>1.Node环境</h2><h3 id=\"1-1-什么是Node\"><a href=\"#1-1-什么是Node\" class=\"headerlink\" title=\"1.1.什么是Node\"></a>1.1.什么是Node</h3><ul>\n<li>Node.js 可能类似jquery.js</li>\n<li>不是JS文件，也不是一个JS框架（）</li>\n<li>而是Server side Javascript runtime, 服务端的一个JS运行时</li>\n<li>我们可以在NODE运行JS代码</li>\n<li>alert();ECMAScript  JS- ES  BOM  DOM</li>\n<li>node中只能运行ECMAScript，无法使用 BOM 和 DOM</li>\n<li>目前我们的JS是运行在浏览器内核中</li>\n<li>PHP是什么？是一门脚本语言也是一个运行环境</li>\n<li><p>为什么Node选中了JS，</p>\n</li>\n<li><p>说到底就是一个JS运行环境</p>\n</li>\n<li><p>目前有两个分支</p>\n<ul>\n<li>Node.js 0.12.7 官方版本 要求尽善尽美</li>\n<li>IO.js 是社区的产物，不是官方的东西，io.js有很多新特性，迭代非常快，社区推进非常快</li>\n<li>15年两者合并，发布node第一个正式版 4.0， 迭代速度又慢了</li>\n<li>node 5.x == io.js</li>\n<li>node 4.0 == node</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"1-2-Node环境搭建\"><a href=\"#1-2-Node环境搭建\" class=\"headerlink\" title=\"1.2.Node环境搭建\"></a>1.2.Node环境搭建</h3><h4 id=\"1-2-1-Mac\"><a href=\"#1-2-1-Mac\" class=\"headerlink\" title=\"1.2.1.Mac\"></a>1.2.1.Mac</h4><ul>\n<li>安装包的方式<ul>\n<li><a href=\"https://nodejs.org/dist/v5.5.0/node-v5.5.0.pkg\" target=\"_blank\" rel=\"external\">pkg</a></li>\n</ul>\n</li>\n<li><p>NVM（Node Version Manager）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.30.2/install.sh | bash</div><div class=\"line\">$ <span class=\"built_in\">echo</span> <span class=\"string\">'. ~/.nvm/nvm.sh'</span> &gt;&gt; .bash_profile</div><div class=\"line\">$ nvm install stable</div><div class=\"line\">$ nvm <span class=\"built_in\">alias</span> default stable</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"1-2-2-Windows\"><a href=\"#1-2-2-Windows\" class=\"headerlink\" title=\"1.2.2.Windows\"></a>1.2.2.Windows</h4><ul>\n<li>安装包的方式<ul>\n<li><a href=\"https://nodejs.org/dist/v5.5.0/node-v5.5.0-x64.msi\" target=\"_blank\" rel=\"external\">msi_x64</a></li>\n<li><a href=\"https://nodejs.org/dist/v5.5.0/node-v5.5.0-x86.msi\" target=\"_blank\" rel=\"external\">msi_x86</a></li>\n</ul>\n</li>\n<li>NVM（Node Version Manager）</li>\n<li>nvm(node version manager)</li>\n<li>因为NODE版本比较多，开发人员可能依赖很多版本</li>\n<li><p>通过NVM，可以轻松切换于不同的版本之间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>NVM_HOME=C:\\Develop\\nvm</p>\n<p>NVM_SYMLINK=C:\\Develop\\nodejs</p>\n<p>NPM_HOME=C:\\Develop\\nvm\\npm</p>\n<p>PATH=%NVM_HOME%;%NVM_SYMLINK%;%NPM_HOME%</p>\n<h4 id=\"1-2-3-环境变量\"><a href=\"#1-2-3-环境变量\" class=\"headerlink\" title=\"1.2.3.环境变量\"></a>1.2.3.环境变量</h4><ul>\n<li><p>环境变量就是操作系统提供的系统级别用于存储变量的地方</p>\n</li>\n<li><p>系统变量和用户变量</p>\n</li>\n<li>系统变量指的是所用当前系统用户共享的变量</li>\n<li>自己的电脑一般只有一个用户</li>\n<li><p>建议将自己配置的环境变量放在用户变量中，用户变量比较干净</p>\n</li>\n<li><p>环境变量的变量名是不区分大小写的</p>\n</li>\n<li><p>变量间运行相互引用</p>\n</li>\n<li><p>特殊值：</p>\n</li>\n<li>PATH变量（不区分大小写）</li>\n<li>PATH 相当于一个路径的引用</li>\n<li><p>只要添加到PATH变量中的路径，都可以在任何目录下搜索</p>\n</li>\n<li><p>命令行</p>\n</li>\n<li>可以用来执行当前目录下的文件</li>\n<li>命令</li>\n</ul>\n<p>cd :change directory</p>\n<ul>\n<li>Node.js是一个轻内核（本身没有什么功能）的东东，所有的功能都要功能包提供</li>\n<li>node官方提供了一些最基础的包</li>\n</ul>\n<h3 id=\"1-3-Node用途\"><a href=\"#1-3-Node用途\" class=\"headerlink\" title=\"1.3.Node用途\"></a>1.3.Node用途</h3><h4 id=\"REPL环境（控制台环境）\"><a href=\"#REPL环境（控制台环境）\" class=\"headerlink\" title=\"REPL环境（控制台环境）\"></a>REPL环境（控制台环境）</h4><h4 id=\"1-3-1-开发Web应用程序\"><a href=\"#1-3-1-开发Web应用程序\" class=\"headerlink\" title=\"1.3.1.开发Web应用程序\"></a>1.3.1.开发Web应用程序</h4><ul>\n<li>做动态网站</li>\n<li>开发提供数据的服务端API</li>\n</ul>\n<h4 id=\"1-3-2-前端开发工具基础\"><a href=\"#1-3-2-前端开发工具基础\" class=\"headerlink\" title=\"1.3.2.前端开发工具基础\"></a>1.3.2.前端开发工具基础</h4><ul>\n<li>Node.js给前端乃至整个开发行业带来一场工业革命</li>\n<li>刀跟火种</li>\n</ul>\n<h3 id=\"1-4-Node开发Web应用Demo\"><a href=\"#1-4-Node开发Web应用Demo\" class=\"headerlink\" title=\"1.4.Node开发Web应用Demo\"></a>1.4.Node开发Web应用Demo</h3><h4 id=\"1-4-1-复习请求与响应\"><a href=\"#1-4-1-复习请求与响应\" class=\"headerlink\" title=\"1.4.1.复习请求与响应\"></a>1.4.1.复习请求与响应</h4><p>客户端发送到服务端的东西称之为请求报文<br>服务端返回给客户端的东西称之为响应报文</p>\n<h3 id=\"1-5-NPM\"><a href=\"#1-5-NPM\" class=\"headerlink\" title=\"1.5.NPM\"></a>1.5.NPM</h3><h4 id=\"1-5-1-什么是NPM\"><a href=\"#1-5-1-什么是NPM\" class=\"headerlink\" title=\"1.5.1.什么是NPM\"></a>1.5.1.什么是NPM</h4><p><a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"external\">https://www.npmjs.com/</a></p>\n<ul>\n<li>Node Package Manager</li>\n<li>Node应用程序依赖包的管理工具</li>\n<li>安装卸载更新之类的操作</li>\n</ul>\n<h4 id=\"1-5-2-为什么使用NPM\"><a href=\"#1-5-2-为什么使用NPM\" class=\"headerlink\" title=\"1.5.2.为什么使用NPM\"></a>1.5.2.为什么使用NPM</h4><ul>\n<li>包很多</li>\n<li>场景：我需要用一个A，A依赖B，B依赖C</li>\n<li>常见的包管理工具都有循环依赖的功能</li>\n<li>你只需记住你要什么东西</li>\n</ul>\n<h4 id=\"1-5-3-常见的NPM操作\"><a href=\"#1-5-3-常见的NPM操作\" class=\"headerlink\" title=\"1.5.3.常见的NPM操作\"></a>1.5.3.常见的NPM操作</h4><p>// 安装一个包，默认安装最新稳定版本<br>npm install package_name<br>// –save<br>// 初始化操作，给项目添加一个配置文件<br>npm init<br>// –yes参数走默认配置</p>\n<ul>\n<li>如果官方数据源太慢使用</li>\n<li><a href=\"https://npm.taobao.org/\" target=\"_blank\" rel=\"external\">https://npm.taobao.org/</a></li>\n</ul>\n<hr>\n<h2 id=\"2-Bower\"><a href=\"#2-Bower\" class=\"headerlink\" title=\"2.Bower\"></a>2.Bower</h2><h3 id=\"2-1-什么是Bower\"><a href=\"#2-1-什么是Bower\" class=\"headerlink\" title=\"2.1.什么是Bower\"></a>2.1.什么是Bower</h3><ul>\n<li><a href=\"http://bower.io/\" target=\"_blank\" rel=\"external\">官网</a></li>\n<li>web应用程序依赖项管理工具</li>\n</ul>\n<h3 id=\"2-2-为什么使用Bower\"><a href=\"#2-2-为什么使用Bower\" class=\"headerlink\" title=\"2.2.为什么使用Bower\"></a>2.2.为什么使用Bower</h3><ul>\n<li>方便便捷的方式管理包，zhuangbi</li>\n</ul>\n<h3 id=\"2-3-Bower实践\"><a href=\"#2-3-Bower实践\" class=\"headerlink\" title=\"2.3.Bower实践\"></a>2.3.Bower实践</h3><ul>\n<li><p>npm install -g bower // -g:global</p>\n</li>\n<li><p>修改npm全局路径，就是在用户目录下添加.npmrc文件</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"3-Sass-LESS\"><a href=\"#3-Sass-LESS\" class=\"headerlink\" title=\"3.Sass/LESS\"></a>3.Sass/LESS</h2><hr>\n<h2 id=\"4-Gulp\"><a href=\"#4-Gulp\" class=\"headerlink\" title=\"4.Gulp\"></a>4.Gulp</h2><h3 id=\"4-1-Gulp简介\"><a href=\"#4-1-Gulp简介\" class=\"headerlink\" title=\"4.1.Gulp简介\"></a>4.1.Gulp简介</h3><ul>\n<li>链接：<ul>\n<li><a href=\"http://gulpjs.com/\" target=\"_blank\" rel=\"external\">官网</a></li>\n<li><a href=\"http://www.gulpjs.com.cn/\" target=\"_blank\" rel=\"external\">中文网</a></li>\n</ul>\n</li>\n<li>就是用来机械化的完成重复性质的工作</li>\n<li>gulp的机制就是将重复工作抽象成一个个的任务，</li>\n</ul>\n<h3 id=\"4-2-Gulp准备工作\"><a href=\"#4-2-Gulp准备工作\" class=\"headerlink\" title=\"4.2.Gulp准备工作\"></a>4.2.Gulp准备工作</h3><ul>\n<li>安装Node.js</li>\n<li>安装 gulp 命令行工具<ul>\n<li><code>npm install -g gulp</code></li>\n</ul>\n</li>\n<li>初始化 gulp 项目</li>\n<li>创建任务 - gulpfile.js</li>\n</ul>\n<h3 id=\"4-3-基本使用\"><a href=\"#4-3-基本使用\" class=\"headerlink\" title=\"4.3.基本使用\"></a>4.3.基本使用</h3><h3 id=\"4-4-常用插件\"><a href=\"#4-4-常用插件\" class=\"headerlink\" title=\"4.4.常用插件\"></a>4.4.常用插件</h3><ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-less\" target=\"_blank\" rel=\"external\">编译 Less：gulp-less</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-connect\" target=\"_blank\" rel=\"external\">创建本地服务器：gulp-connect</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-concat\" target=\"_blank\" rel=\"external\">合并文件：gulp-concat</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-uglify\" target=\"_blank\" rel=\"external\">最小化 js 文件：gulp-uglify</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-rename\" target=\"_blank\" rel=\"external\">重命名文件：gulp-rename</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-minify-css\" target=\"_blank\" rel=\"external\">最小化 css 文件：gulp-minify-css</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-minify-html\" target=\"_blank\" rel=\"external\">压缩html文件 gulp-minify-html</a></li>\n<li><a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"external\">最小化图像：gulp-imagemin</a></li>\n</ul>\n<hr>\n<h2 id=\"5-Git\"><a href=\"#5-Git\" class=\"headerlink\" title=\"5.Git\"></a>5.Git</h2><h3 id=\"5-1-什么是GIT，什么是GITHUB\"><a href=\"#5-1-什么是GIT，什么是GITHUB\" class=\"headerlink\" title=\"5.1.什么是GIT，什么是GITHUB\"></a>5.1.什么是GIT，什么是GITHUB</h3><ul>\n<li>GIT</li>\n<li>GITHUB</li>\n</ul>\n<h3 id=\"5-2-环境安装\"><a href=\"#5-2-环境安装\" class=\"headerlink\" title=\"5.2.环境安装\"></a>5.2.环境安装</h3><h3 id=\"5-3-GIT常用命令\"><a href=\"#5-3-GIT常用命令\" class=\"headerlink\" title=\"5.3.GIT常用命令\"></a>5.3.GIT常用命令</h3><hr>\n<h2 id=\"6-Markdown\"><a href=\"#6-Markdown\" class=\"headerlink\" title=\"6.Markdown\"></a>6.Markdown</h2><p><a href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\" rel=\"external\">https://guides.github.com/features/mastering-markdown/</a><br><a href=\"https://help.github.com/articles/github-flavored-markdown/\" target=\"_blank\" rel=\"external\">https://help.github.com/articles/github-flavored-markdown/</a><br><a href=\"https://help.github.com/articles/markdown-basics/\" target=\"_blank\" rel=\"external\">https://help.github.com/articles/markdown-basics/</a></p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n\n","excerpt":"学习目标 了解什么是Node，什么是NPM；（Node.js） 掌握Bower的使用； 熟练使用Less/Sass；","categories":[{"name":"技术","slug":"技术","permalink":"http://www.pengmengshan.cn/blog/categories/技术/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"http://www.pengmengshan.cn/blog/tags/gulp/"}]},{"title":"Hello hexo","date":"2016-08-10T10:54:14.000Z","path":"2016/08/10/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 扫描二维码添加彭蒙善为你的好友欢迎交流","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><a id=\"more\"></a>\n<h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n<hr>\n<div align=\"center\"><br>    <center> 扫描二维码添加彭蒙善为你的好友</center><center><font color=\"#f75000\" size=\"\">欢迎交流</font><center><img width=\"40%\" align=\"center\" src=\"/uploads/wechat-qcode.jpg\n\"><br></center></center></div>\n","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","categories":[{"name":"技术","slug":"技术","permalink":"http://www.pengmengshan.cn/blog/categories/技术/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.pengmengshan.cn/blog/tags/hexo/"}]}]